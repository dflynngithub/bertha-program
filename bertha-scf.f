      PROGRAM BERTHA
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         BBBBBBB  EEEEEEEE RRRRRRR TTTTTTTT HH    HH    AA            C
C         BB    BB EE       RR    RR   TT    HH    HH   AAAA           C
C         BB    BB EE       RR    RR   TT    HH    HH  AA  AA          C
C         BBBBBBB  EEEEEE   RR    RR   TT    HHHHHHHH AA    AA         C
C         BB    BB EE       RRRRRRR    TT    HH    HH AAAAAAAA         C
C         BB    BB EE       RR    RR   TT    HH    HH AA    AA         C
C         BBBBBBB  EEEEEEEE RR    RR   TT    HH    HH AA    AA         C
C                                                                      C
C                 (THE PROGRAM FORMERLY KNOWN AS...)                   C
C                                                                      C
C      SSSSSS  WW        WW IIII RRRRRRR  LL      EEEEEEEE SSSSSS      C
C     SS    SS WW        WW  II  RR    RR LL      EE      SS    SS     C
C     SS       WW   WW   WW  II  RR    RR LL      EE      SS           C
C      SSSSSS  WW  WWWW  WW  II  RR    RR LL      EEEEEE   SSSSSS      C
C           SS WW WW  WW WW  II  RRRRRRR  LL      EE            SS     C
C     SS    SS WWWW    WWWW  II  RR    RR LL      EE      SS    SS     C
C      SSSSSS  WW        WW IIII RR    RR LLLLLLL EEEEEEEE SSSSSS      C
C                                                                      C
C ******************************************************************** C
C                                                                      C
C  *   *   *   *   *     SSSSSS   CCCCCC  FFFFFFFF  *   *   *   *   *  C
C    *   *   *   *      SS    SS CC    CC FF          *   *   *   *    C
C  *   *   *   *   *    SS       CC       FF        *   *   *   *   *  C
C    *   *   *   *       SSSSSS  CC       FFFFFF      *   *   *   *    C
C  *   *   *   *   *          SS CC       FF        *   *   *   *   *  C
C    *   *   *   *      SS    SS CC    CC FF          *   *   *   *    C
C  *   *   *   *   *     SSSSSS   CCCCCC  FF        *   *   *   *   *  C
C                                                                      C
C ******************************************************************** C
C                                                                      C
C        A RELATIVISTIC MOLECULAR ELECTRONIC STRUCTURE PROGRAM         C
C            BASED ON THE ANALYTIC FINITE BASIS SET METHOD.            C
C                                                                      C
C                 H.M.QUINEY, H.SKAANE (OXFORD, 1997)                  C
C                       D. FLYNN (UNIMELB, 2020)                       C
C                                                                      C
C -------------------------------------------------------------------- C
C                          HAMILTONIANS (HMLT)                         C
C                          -------------------                         C
C ▶ 'NORL' NON-RELATIVISTIC HAMILTONIAN (PAULI EQUATION).              C
C ▶ 'BARE' BARE NUCLEUS DIRAC HAMILTONIAN (NO ELECTRON INTERACTION).   C
C ▶ 'DHFR' DIRAC-COULOMB HAMILTONIAN.                                  C
C ▶ 'DHFP' DIRAC-COULOMB HAMILTONIAN (+1ST ORDER BREIT AND QED).       C
C ▶ 'DHFB' DIRAC-COULOMB-BREIT HAMILTONIAN.                            C
C ▶ 'DHFQ' DIRAC-COULOMB-BREIT HAMILTONIAN WITH LEADING-ORDER QED.     C
C -------------------------------------------------------------------- C
C                   CALCULATION TREE OPTIONS (TREE)                    C
C                   -------------------------------                    C
C  HFSCF: HARTREE-FOCK SCF CALCULATION.                                C
C  MBPTN: NTH-ORDER MANY-BODY DIAGRAMMATIC PERTURBATION THEORY.        C
C  EXPVL: CALCULATION OF MOLECULAR EXPECTATION VALUES.                 C
C  PLOTS: VISUALS (ELECTROMAGNETIC FIELDS, POTENTIALS, FORM FACTORS).  C
C -------------------------------------------------------------------- C
C                          TABLE OF CONTENTS                           C
C                          -----------------                           C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C   [4] ATOMIC HARTREE-FOCK: AVERAGE OF CONFIG. ATOMIC SCF.            C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE HARTREE-FOCK SCF.          C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C  [12] EQ-COEFFS: BASIS FUNCTION OVERLAP SPIN-STRUCTURE FACTORS.      C
C  [14] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TCPU/TBEG,TNUC,TATM,TSCF,TMPT,TPRP,TPLT,TTOT
C
C     READ DATA FROM USER-SPECIFIED INPUT FILE
      CALL CARDIN
C
C     OPEN FILE FOR TERMINAL RECORD
      OPEN(UNIT=7,FILE=TRIM(OUTFL)//'_scf.out',STATUS='UNKNOWN')
C
C     INTER-ATOMIC ANGLES AND NUCLEAR REPULSION ENERGY
      CALL NUCGEOM
C
C     IF(SHAPE.EQ.'ATOMIC') RETURN
C
C     MOLECULAR HARTREE-FOCK SCF ROUTINE
      IF(TREE.EQ.'HFSCF'.OR..NOT.READIN) THEN
C
C       PRINT SUMMARY OF INPUT DATA
        CALL INPUT
C
C       PRINT MEMORY ALLOCATION SUMMARY
        CALL MEMORY
C
C       NUCLEAR POTENTIALS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL NUCCOUL
        CALL NUCVCPL
        CALL SYSTEM_CLOCK(ICL2)
        TNUC = TNUC + DFLOAT(ICL2-ICL1)/RATE
C
C       FOCK MATRIX SYMMETRY TYPE INDICES
        CALL FOCKIND
C
C       CARTESIAN EXPANSION INDICES FOR BASIS FUNCTION OVERLAP PAIRS
        CALL CARTIND
C
C       CALCULATE MOLECULAR DENSITY FROM READ-IN COEFFICIENTS
        CALL DENSTY
C
C       CALL THE MOLECULAR SCF PROCEDURE
        CALL SYSTEM_CLOCK(ICL1)
        CALL HFSCF
        CALL SYSTEM_CLOCK(ICL2)
        TSCF = TSCF + DFLOAT(ICL2-ICL1)/RATE
C
      ENDIF
C
C     PRINT SUMMARY OF OUTPUT DATA
      CALL OUTPUT
C
C     CLOSE FILE FOR TERMINAL RECORD
      CLOSE(UNIT=7)
C
C     SUCCESSFUL EXIT
      END PROGRAM
C
C
C**********************************************************************C
C ==================================================================== C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] CARDIN: READ MOLECULAR DATA FROM A USER-SPECIFIED FILE.        C
C   [B] INPUT: WRITE A SUMMARY OF DATA INPUT OPTIONS TO TERMINAL.      C
C   [C] MEMORY: WRITE A SUMMARY OF MEMORY REQUIREMENTS OF BIG ARRAYS.  C
C   [D] OUTPUT: WRITE A SUMMARY OF TOTAL CALCULATION STATS/DATA.       C
C   [E] PHYSPRM: PHYSICAL CONSTANTS, TRANSCENDENTALS AND ELEMENT NAMES.C
C   [F] GAMGEN: LIST OF GAMMA FUNCTIONS FOR INT AND HALF-INT ARGS.     C
C   [G] FACTRL: LIST OF FACTORIALS AND DOUBLE FACTORIALS.              C
C**********************************************************************C
C
C
      SUBROUTINE CARDIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            CCCCCC     AA    RRRRRRR  DDDDDDD IIII NN    NN           C
C           CC    CC   AAAA   RR    RR DD    DD II  NNN   NN           C
C           CC        AA  AA  RR    RR DD    DD II  NNNN  NN           C
C           CC       AA    AA RR    RR DD    DD II  NN NN NN           C
C           CC       AAAAAAAA RRRRRRR  DD    DD II  NN  NNNN           C
C           CC    CC AA    AA RR    RR DD    DD II  NN   NNN           C
C            CCCCCC  AA    AA RR    RR DDDDDDD IIII NN    NN           C
C                                                                      C
C                          INPUT ROUTINE FOR                           C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  CARDIN READS AND PREPARES DATA FROM A USER-SPECIFIED INPUT FILE.    C
C  THIS IS ALSO WHERE ATOMIC ELEMENT NAMES AND CV ARE SPECIFIED.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C     INCLUDE 'omp_lib.h'
C
      LOGICAL FILETHERE
C
      CHARACTER*1  DUMLIN
      CHARACTER*5  NMDL
      CHARACTER*6  CNFG
      CHARACTER*7  HMINT(50),PTYPE(10)
      CHARACTER*9  BTYP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/PT1B/NHMINT,HMINT
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     GENERATE SOME MATHEMATICAL LISTS
      CALL FACTRL
      CALL GAMGEN
C
C     MANUAL CHOICES
      EQFILE = .TRUE.
      OPENMP = .FALSE.
C
C**********************************************************************C
C     MOLECULE NAME AND CALCULATION TYPE                               C
C**********************************************************************C
C
C     MOLECULE OUTPUT STRING
      READ(5, *) DUMLIN
      READ(5, *) MOLCL
C
C     CALCULATION TREE: HFSCF, MBPTN, EXPVL, PLOTS
      READ(5, *) DUMLIN
      READ(5, *) TREE
C
C     CALCULATION TREE CHECK -- IF UNKNOWN, EXIT.
      IF(TREE.NE.'HFSCF'.AND.TREE.NE.'MBPTN'.AND.
     &   TREE.NE.'EXPVL'.AND.TREE.NE.'PLOTS') THEN
        WRITE(6, *) 'In CARDIN: invalid calculation tree. ',TREE
        WRITE(7, *) 'In CARDIN: invalid calculation tree. ',TREE
        STOP
      ENDIF
C
C     HAMILTONIAN: NORL, BARE, DHFR, DHFP, DHFB OR DHFQ
10    FORMAT(A4)
      READ(5, *) DUMLIN
      READ(5,10) HMLT
C
C     HAMILTONIAN CHECK -- IF UNKNOWN, EXIT.
      IF(HMLT.NE.'NORL'.AND.HMLT.NE.'BARE'.AND.HMLT.NE.'DHFR'.AND.
     &   HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
        WRITE(6, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
        WRITE(7, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
        STOP
      ENDIF
C
C     WAVE FUNCTION FILE NAME
      WFNFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'.wfn'
C
C     OUTPUT FILE NAME
      OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_'//TREE
C
C     CONTINUING CALCULATION: READ-IN (TRUE), NEW START (FALSE)
      READ(5, *) DUMLIN
      READ(5, *) READIN
C
C**********************************************************************C
C     ATOMIC CENTRES AND BASIS FUNCTIONS                               C
C**********************************************************************C
C
C     NUMBER OF ATOMIC CENTRES
      READ(5, *) DUMLIN
      READ(5, *) NCNT
C
C     CHECK THAT NCNT CAN BE SUPPORTED BY SYSTEM PARAMETERS
      IF(NCNT.GT.MCT) THEN
        WRITE(6, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        WRITE(7, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        STOP
      ENDIF
C
C     INITIALISE MAXIMUM LQN AND DIMENSION COUNTERS
      LBIG = 0
      NDIM = 0
C
C     LOOP OVER ATOMIC CENTRES
      DO IZ=1,NCNT
C
C       CARTESIAN COORDINATES OF THIS CENTRE
        READ(5, *) DUMLIN
        READ(5, *) DUMLIN
        READ(5, *) (BXYZ(J,IZ),J=1,3)
C
C       NUCLEUS: MODEL, CHARGE, MASS
        READ(5, *) DUMLIN
        READ(5, *) NMDL(IZ),ZNUC(IZ),ANUC(IZ)
C
C       CHECK THAT NUCLEAR MODEL IS ALLOWED
        IF(NMDL(IZ).NE.'POINT'.AND.NMDL(IZ).NE.'GAUSS'.AND.
     &     NMDL(IZ).NE.'FERMI'.AND.NMDL(IZ).NE.'UNIFM') THEN
          WRITE(6, *) 'In CARDIN: illegal nuclear model.',NMDL(IZ)
          WRITE(7, *) 'In CARDIN: illegal nuclear model.',NMDL(IZ)
          STOP
        ENDIF
C
C       ATOMIC BASIS: TYPE AND LMAX
        READ(5, *) DUMLIN
        READ(5, *) BTYP,LMAX
C
C       CHECK THAT BASIS TYPE IS ALLOWED
        IF(BTYP.NE.'OPTIMISED'.AND.BTYP.NE.'GEOMETRIC'
     &                        .AND.BTYP.NE.'EVENTEMPR') THEN
          WRITE(6, *) 'In CARDIN: illegal basis type.',BTYP
          WRITE(7, *) 'In CARDIN: illegal basis type.',BTYP
          STOP
        ENDIF
C
C       NUMBER OF KAPPA VALUES FOR THIS ATOM
        NKAP(IZ) = 2*LMAX+1
C
C       CHECK THAT LMAX CAN BE SUPPORTED BY SYSTEM PARAMETERS
        IF(2*LMAX+1.GT.MKP) THEN
          WRITE(6, *) 'In CARDIN: LMAX runs outside MKP storage.'
          WRITE(7, *) 'In CARDIN: LMAX runs outside MKP storage.'
          STOP
        ENDIF
C
C       ELECTRON CONFIGURATION CHOICE AND NUCLEAR ELECTRONIC CHARGE
        READ(5, *) DUMLIN
        READ(5, *) CNFG(IZ),IQNC(IZ)
C
C       CHECK THAT CNFG IS ALLOWED
        IF(CNFG(IZ).NE.'AUFBAU'.AND.CNFG(IZ).NE.'MANUAL') THEN
          WRITE(6, *) 'In CARDIN: illegal CNFG option.',CNFG(IZ)
          WRITE(7, *) 'In CARDIN: illegal CNFG option.',CNFG(IZ)
          STOP
        ENDIF
C
C       IF FILLING IS MANUAL, IMPORT ATOMIC ELECTRON CONFIGURATION
        IF(CNFG(IZ).EQ.'MANUAL') THEN
          READ(5, *) DUMLIN
          DO L=0,LMAX
            READ(5, *) NLVL(IZ,L),(NCNF(IZ,L,N),N=1,NLVL(IZ,L))
          ENDDO
        ENDIF
C
C       UPDATE OVERALL MAXIMUM OCCURRING LQN
        IF(LMAX.GT.LBIG) LBIG = LMAX
C
C       OPTIMISED EXPONENTS FROM A RECORDED LIST
        IF(BTYP.EQ.'OPTIMISED') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         READ IN THE OPTIMISED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ NUMBER OF BASIS FUNCTIONS
            READ(5, *) NFNC(LQN,IZ)
C
C           CHECK THAT THIS CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
C           READ BASIS EXPONENTS FROM A LIST
            DO IBAS=1,NFNC(LQN,IZ)
              READ(5, *) BEXL(IBAS,LQN,IZ)
            ENDDO
C
          ENDDO
C
C       GEOMETRIC BASIS FUNCTIONS
        ELSEIF(BTYP.EQ.'GEOMETRIC') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ GENERATING PARAMETERS A, B AND NFNC
            READ(5, *) ALPH,BETA,NFNC(LQN,IZ)
C
C           GENERATE NFNC BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = ALPH
            DO IBAS=1,NFNC(LQN,IZ)
              BEXL(IBAS,LQN,IZ) = ZETA
              ZETA = ZETA*BETA
            ENDDO
C
C           CHECK THAT NFNC CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
          ENDDO
C
C       EVEN-TEMPERED GEOMETRIC BASIS FUNCTIONS
        ELSEIF(BTYP.EQ.'EVENTEMPR') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ GENERATING PARAMETERS A, B, NFNC AND STARTING POINT
            READ(5, *) ALPH,BETA,NFNC(LQN,IZ),N1
C
C           GENERATE NFNC BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = ALPH
            DO IBAS=1,N1-1
              ZETA = ZETA*BETA
            ENDDO
            DO IBAS=1,NFNC(LQN,IZ)
              BEXL(IBAS,LQN,IZ) = ZETA
              ZETA = ZETA*BETA
            ENDDO
C
C           CHECK THAT NFNC CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
          ENDDO
C
C       END IF STATEMENT FOR TYPE OF BASIS FUNCTION
        ENDIF
C
C       LOOP OVER ALL LQNS IN THIS CENTRE AND ADD TO FOCK DIMENSION
        DO LQN=0,LMAX
C
C         EXTEND DIMENSION OF FOCK MATRIX
          NDIM = NDIM + 4*(2*LQN+1)*NFNC(LQN,IZ)
C
C         ASSIGN KQN VALUES
          IF(LQN.NE.0) THEN
            KAPA(2*LQN  ,IZ) = LQN
          ENDIF
          KAPA(2*LQN+1,IZ) =-LQN-1
C
        ENDDO
C
C     END LOOP OVER ATOMIC CENTRES
      ENDDO
C
C     TOTAL DIMENSION DEPENDING ON CHOICE OF HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
        NDIM = NDIM/2
        NSKP = 0
      ELSE
        NSKP = NDIM/2
      ENDIF
C
C     CHECK THAT SYSTEM PARAMETERS CAN SUPPORT NDIM
      IF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        WRITE(7, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        STOP
      ENDIF
C
C**********************************************************************C
C     CLOSED/OPEN SHELL DETAILS                                        C
C**********************************************************************C
C
C     NUMBER OF CLOSED- AND OPEN-SHELL ORBITALS AND OPEN SHELL ELECTRONS
      READ(5, *) DUMLIN
      READ(5, *) NCLS,NOPN,NOELEC
C
C     TOTAL NUMBER OF 'OCCUPIED' AND 'VIRTUAL' ORBITALS IN SYSTEM
      NOCC = NCLS+NOPN
      NVRT = NDIM-NSKP-NOCC
C
C     INVALID CHOICE OF NOPN
      IF(NOPN.LT.0) THEN
        WRITE(6, *) 'In CARDIN: invalid value NOPN.',NOPN
        WRITE(7, *) 'In CARDIN: invalid value NOPN.',NOPN
        STOP
      ENDIF
C
C     CLOSED-SHELL MOLECULAR CONFIGURATION
      IF(NOPN.EQ.0) THEN
C
C       LABEL THE CLOSED-SHELL ELECTRON ORBITALS
        DO JCL=1,NCLS
          ICLS(JCL) = JCL
        ENDDO
C
C     OPEN-SHELL MOLECULAR CONFIGURATION
      ELSEIF(NOPN.GT.0) THEN
C
C       FRACTIONAL OCCUPANCY OF THE OPEN-SHELL ORBITALS
        FOPN = DFLOAT(NOELEC)/DFLOAT(NOPN)
C
C       SYMMETRY-ADAPTED CONFIGURATION OF OPEN-SHELL ORBITALS
        READ(5, *) DUMLIN
        READ(5, *) ACFF,BCFF,(IOPN(M),M=1,NOPN)
C
C       LABEL THE CLOSED-SHELL ELECTRON ORBITALS
        JCL = 1
        JOP = 1
        DO JCOUNT=1,NOCC
C
C         APPLY LABEL TO EACH ORBITAL
          IF(JCOUNT.NE.IOPN(JOP)) THEN
            ICLS(JCL) = JCOUNT
            JCL = JCL + 1
          ELSE
            JOP = JOP + 1
          ENDIF
C
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     LEVEL SHIFTING AND INTEGRAL INCLUSION STARTING POINT             C
C**********************************************************************C
C
C     LEVEL SHIFT PARAMETER FOR EACH INTEGRAL STAGE (SKAANE 4.4.3)
      READ(5, *) DUMLIN
      READ(5, *) (SHLEV(N),N=1,3)
C
C     STARTING STAGE OF INTEGRAL INCLUSION LEVEL (1-3)
      READ(5, *) DUMLIN
      READ(5, *) ILEV
C
C     CHECK FOR INVALID CHOICE OF ILEV
      IF(ILEV.LT.1.AND.ILEV.GT.4) THEN
        WRITE(6, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        WRITE(7, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        STOP
      ENDIF
C
C     REASONS TO CHANGE THE INTEGRAL INCLUSION LEVEL (STAGE)
      IF(HMLT.EQ.'NORL') THEN
        ILEV = 1
      ENDIF
C
      IF(NCNT.EQ.1.OR.READIN) THEN
        ILEV = 3
      ENDIF
C
C     IMPLEMENT THE STARTING SHIFT FACTOR
      IF(ILEV.GE.1.AND.ILEV.LE.3) THEN
        SHLV = SHLEV(ILEV)
      ELSEIF(ILEV.EQ.4) THEN
        SHLV = 0.0D0
      ENDIF
C
C**********************************************************************C
C     NON-HF CALCULATION DETAILS                                       C
C**********************************************************************C
C
C     EXPECTATION VALUE CALCULATIONS: ORTHGNL,MAGDIPL ETC
      IF(TREE.EQ.'EXPVL') THEN
C
C       READ NUMBER OF EXPECTATION VALUES
        READ(5, *) DUMLIN
        READ(5, *) NHMINT
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NHMINT.LT.1.OR.NHMINT.GT.50) THEN
          WRITE(6, *) 'In CARDIN: invalid number of expectation values.'
          WRITE(7, *) 'In CARDIN: invalid number of expectation values.'
          STOP
        ENDIF
C
C       READ IN EACH INTERACTION HAMILTONIAN
        DO N=1,NHMINT
          READ(5, *) HMINT(N)
        ENDDO
C
      ENDIF
C
C     DATA PLOTTING: AMPLITUDES, EM FIELDS AND POTENTIALS
      IF(TREE.EQ.'PLOTS') THEN
C
C       READ NUMBER OF PLOT TYPES
        READ(5, *) DUMLIN
        READ(5, *) NPTYPE
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NPTYPE.LT.1.OR.NPTYPE.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of plot types.'
          WRITE(7, *) 'In CARDIN: invalid number of plot types.'
          STOP
        ENDIF
C
C       READ IN EACH PLOT TYPE
        DO N=1,NPTYPE
          READ(5, *) PTYPE(N)
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     READ IN ANY EXTERNAL DATA FILES                                  C
C**********************************************************************C
C
C     READ IN A WAVE FUNCTION FILE IF PROMPTED
C     IF(READIN) THEN
        INQUIRE(FILE=WFNFL,EXIST=FILETHERE)
        IF(FILETHERE) THEN
          OPEN(UNIT=8,FILE=WFNFL,STATUS='UNKNOWN')
          REWIND(UNIT=8)
          DO I=1,NDIM
            READ(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
          ENDDO
          CLOSE(UNIT=8)
        ELSE
          READIN = .FALSE.
        ENDIF
C     ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE INPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               IIII NN    NN PPPPPPP  UU    UU TTTTTTTT               C
C                II  NNN   NN PP    PP UU    UU    TT                  C
C                II  NNNN  NN PP    PP UU    UU    TT                  C
C                II  NN NN NN PP    PP UU    UU    TT                  C
C                II  NN  NNNN PPPPPPP  UU    UU    TT                  C
C                II  NN   NNN PP       UU    UU    TT                  C
C               IIII NN    NN PP        UUUUUU     TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  INPUT PRINTS MOLECULAR DATA INPUT OPTIONS TO THE TERMINAL.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/TCPU/TCPUS(8)
      COMMON/TMMD/TMMDS(9)
      COMMON/TSCF/TSCFS(41)
C
C     INITIALISE TIME COUNTERS
      DO NT=1,8
        TCPUS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,41
        TSCFS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,9
        TMMDS(NT) = 0.0D0
      ENDDO
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'BERTHA-SCF'
      WRITE(7, *) REPEAT(' ',30),'BERTHA-SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',29),'Input summary'
      WRITE(7, *) REPEAT(' ',29),'Input summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     PRINT THE HAMILTONIAN OPTION
      WRITE(6, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
      WRITE(7, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
C
C     PRINT INPUT FILE NAME
      LF = LEN(TRIM(MOLCL))
      WRITE(6, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
      WRITE(7, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
C
C     CONFIRM SOLUTION SPACE DIMENSION OR EXIT
      IF(NDIM.LE.MDM) THEN
        WRITE(6, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
        WRITE(7, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
      ELSEIF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        WRITE(7, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        STOP
      ENDIF
C
C     NEW START OR READ IN HFSCF EXPANSION COEFFICIENTS
      IF(READIN) THEN
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
      ELSE
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
      ENDIF
C
C     EQ-COEFFICIENT CALCULATION
      IF(EQFILE) THEN
        WRITE(6, *) 'Eq-coefficients:',REPEAT(' ',44),'Save to file'
        WRITE(7, *) 'Eq-coefficients:',REPEAT(' ',44),'Save to file'
      ELSE
        WRITE(6, *) 'Eq-coefficients:',REPEAT(' ',48),'By batch'
        WRITE(7, *) 'Eq-coefficients:',REPEAT(' ',48),'By batch'
      ENDIF
C
C     OPENMP PARALLEL OPTION
      IF(OPENMP) THEN
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(6, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),NPRCSR
        WRITE(7, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),NPRCSR
      ELSE
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
      ENDIF
C
C     SECTION FOR FILE NAMES
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT FILE OUTPUT NAMES
      LN = LEN(TRIM(OUTFL))
      WRITE(6, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
      WRITE(7, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
C
C     RECORD TIME AT BEGINNING OF CALCULATION
      CALL SYSTEM_CLOCK(ICL1,RATE)
      TCPUS(1) = DFLOAT(ICL1)/RATE
      CALL TIMENOW(STAMP)
      WRITE(6, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
C
C     SECTION FOR PHYSICAL PARAMETERS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT SPEED OF LIGHT
20    FORMAT(1X,A,43X,F14.10)
      WRITE(6,20) 'Speed of light:',CV
      WRITE(7,20) 'Speed of light:',CV
C
C     END OF INPUT SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE MEMORY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RRRRRRR  YY    YY      C
C     MMM     MMM EE       MMM     MMM OO    OO RR    RR YY    YY      C
C     MMMM   MMMM EE       MMMM   MMMM OO    OO RR    RR  YY  YY       C
C     MM MM MM MM EEEEEE   MM MM MM MM OO    OO RR    RR   YYYY        C
C     MM  MMM  MM EE       MM  MMM  MM OO    OO RRRRRRR     YY         C
C     MM   M   MM EE       MM   M   MM OO    OO RR    RR    YY         C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RR    RR    YY         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MEMORY SUMMARISES THE SIZE AND MEMORY REQUIREMENTS OF BIG ARRAYS.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      INTEGER*16 NCMEM,NDMEM,NEMEM,NMMEM,NRMEM,NTMEM
      INTEGER*16 NHMEM
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
C
C     TITLE FOR MEMORY SUMMARY
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',24),'Stack memory allocation'
      WRITE(7, *) REPEAT(' ',24),'Stack memory allocation'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     APPROXIMATE THE MEMORY STORAGE ALLOCATION
      NCMEM = 2*SIZE(COEF)
      NDMEM = 2*SIZE(DENC) + 2*SIZE(DENO) + 2*SIZE(DENT)
      NEMEM = SIZE(E0LLFL) + SIZE(E0SSFL) + SIZE(EILSFL) + SIZE(EISLFL)
      NHMEM = 20*MFL
      NMMEM = 2*SIZE(FOCK) + 2*SIZE(OVLP) + 2*SIZE(HNUC) + 2*SIZE(HKIN)
     &      + 2*SIZE(GDIR) + 2*SIZE(GXCH) + 2*SIZE(BDIR) + 2*SIZE(BXCH)
     &      + 2*SIZE(VANM) + 2*SIZE(VSLF) + 2*SIZE(VUEH) + 2*SIZE(VWKR)
     &      + 2*SIZE(VKSB) + 2*SIZE(QDIR) + 2*SIZE(QXCH) + 2*SIZE(QDIR)
     &      + 2*SIZE(QXCH) + 2*SIZE(WDIR) + 2*SIZE(WXCH) + 2*SIZE(CPLE)
      NTMEM = NCMEM + NDMEM + NEMEM + NHMEM + NMMEM
C
C     SIZES (IN GIGABYTES)
      SCMEM = DFLOAT(NCMEM)*8.0D-9
      SDMEM = DFLOAT(NDMEM)*8.0D-9
      SEMEM = DFLOAT(NEMEM)*8.0D-9
      SHMEM = DFLOAT(NHMEM)*8.0D-9
      SMMEM = DFLOAT(NMMEM)*8.0D-9
      STMEM = DFLOAT(NTMEM)*8.0D-9
C
20    FORMAT(1X,A,4X,A,19X,A,9X,A)
21    FORMAT(1X,A,6X,A,5X,I12,9X,F9.5)
      WRITE(6,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(7,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(7,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(6,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(7,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(6,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(7,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(6,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(7,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(6,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(7,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) '    ','Total                      ',NTMEM,STMEM
      WRITE(7,21) '    ','Total                      ',NTMEM,STMEM
C
C     END OF MEMORY SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE OUTPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  UU    UU TTTTTTTT PPPPPPP  UU    UU TTTTTTTT        C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PPPPPPP  UU    UU    TT           C
C         OO    OO UU    UU    TT    PP       UU    UU    TT           C
C          OOOOOO   UUUUUU     TT    PP        UUUUUU     TT           C
C                                                                      C
C                      EXIT SUMMARY ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  OUTPUT PRINTS A SUMMARY OF TOTAL CALCULATION DATA TO TERMINAL.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
C
      COMMON/TCPU/TBEG,TNUC,TATM,TSCF,TMPT,TPRP,TPLT,TTOT
C
C     OVERALL CALCULATION TIME
      CALL SYSTEM_CLOCK(ICL2,RATE)
      TTOT = DFLOAT(ICL2)/RATE-TBEG
C
C     PRINT TABLE OF DATA
20    FORMAT(1X,A,26X,A)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',28),'CPU time summary'
      WRITE(7, *) REPEAT(' ',28),'CPU time summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Nuclear fitting:              ',HMS(TNUC)
      WRITE(7,20) 'Nuclear fitting:              ',HMS(TNUC)
      WRITE(6,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
      WRITE(7,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(7,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     RECORD TIME AT BERTHA EXIT
      CALL TIMENOW(STAMP)
C
C     SUCCESSFUL EXIT MESSAGE
30    FORMAT(1X,A,22(' '),A)
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6,30) 'Successful BERTHA-SCF exit at:',STAMP
      WRITE(7,30) 'Successful BERTHA-SCF exit at:',STAMP
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      RETURN
      END
C
C
      BLOCK DATA PHYSPRM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  PPPPPPP  HH    HH YY    YY  SSSSSS  PPPPPPP  RRRRRRR  MM       MM   C
C  PP    PP HH    HH YY    YY SS    SS PP    PP RR    RR MMM     MMM   C
C  PP    PP HH    HH YY    YY SS       PP    PP RR    RR MMMM   MMMM   C
C  PP    PP HHHHHHHH  YY  YY   SSSSSS  PP    PP RR    RR MM MM MM MM   C
C  PPPPPPP  HH    HH   YYYY         SS PPPPPPP  RRRRRRR  MM  MMM  MM   C
C  PP       HH    HH    YY    SS    SS PP       RR    RR MM   M   MM   C
C  PP       HH    HH    YY     SSSSSS  PP       RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  BLOCK DATA FOR PHYSICAL CONSTANTS, CALCULATED TRANSCENDENTALS AND   C
C  PERIODIC TABLE ELEMENT NAMES.                                       C
C**********************************************************************C
C
      CHARACTER*2 ELMT(120)
C
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     PERIODIC TABLE ELEMENT NAMES
      DATA ELMT/'H' ,'He','Li','Be','B' ,'C' ,'N' ,'O' ,'F' ,'Ne',
     &          'Na','Mg','Al','Si','P' ,'S' ,'Cl','Ar','K' ,'Ca',
     &          'Sc','Ti','V' ,'Cr','Mn','Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y' ,'Zr',
     &          'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I' ,'Xe','Cs','Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W' ,'Re','Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
     &          'Pa','U' ,'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds',
     &          'Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og','Ue','Un'/
C
C     PI AND ROOTS
      DATA PI,PI12,PI32,PI52/3.1415926535897932D0,1.7724538509055160D0,
     &                       5.5683279968317078D0,1.7493418327624863D1/
C
C     NATURAL LOGARITHM DATA
      DATA PILG,TWLG,THLG/1.1447298858494002D0,0.6931471805599453D0,
     &                                         1.0986122886681097D0/
C
C     NATURAL CONSTANTS
      DATA EULR/0.5772156649015329D0/
C
C     OTHER ROOTS
      DATA TW12/1.4142135623730950D0/
C
C     SPEED OF LIGHT (CODATA 2018 MEASUREMENT - UNCERTAINTY 0.000000021)
      DATA CV/137.035999084D0/
C
C     SPEED OF LIGHT (CODATA 2010 MEASUREMENT)
c     DATA CV/137.0359990D0/
C
C     SPEED OF LIGHT (CODATA 1999 MEASUREMENT)
C     DATA CV/137.03599976D0/
C
C     SPEED OF LIGHT (USED IN HAAKON'S THESIS)
c     DATA CV/137.0359898D0/
C
C     RELATIVE ELECTRON, MUON AND TAUON MASSES (ATOMIC UNITS)
      DATA EMSS,UMSS,TMSS/1.0000D0,206.7683D0,3477.1429D0/
C
C     RATIO OF PROTON MASS TO ELECTRON MASS AND PROTON RADIUS (IN fm)
      DATA PMSS,PRAD/1836.153D0,0.842D0/
C
C     COMPTON WAVELENGTH (1.0D0/CV)
      DATA CMPW/7.297353064D-3/
C
C     FREE ELECTRON G-FACTOR
      DATA GFREE/2.0023193043622D0/
C
C     FERMI COUPLING CONSTANT (IN eV^-2)
C     DATA GFRMI/1.1663787D-23/
C
C     FERMI COUPLING CONSTANT (IN au -- USED IN HAAKON'S THESIS)
C     DATA GFRMI/2.22D-14/
C
C     FERMI COUPLING CONSTANT (IN au)
      DATA GFRMI/2.22255D-14/
C
C     WEINBERG MIXING ANGLE SIN(θ_W)^2
      DATA WEIN/0.23120D0/
C
C     CONVERSION FACTORS: HARTREE TO HZ, HARTREE TO eV, HARTREE TO cm^-1
      DATA CHZ,CEV,CCM/6.579684D+15,2.7211332663D+01,2.1947422215D+05/
C
C     CONVERSION FACTORS: BOHR RADIUS TO FM OR ÅNGSTROM
      DATA CFM,CNG/5.29177211D+4,5.29177211D-1/
C
C     CONVERSION FACTOR: ELECTRON CHARGE ÅNGSTROM TO DEBYE (eÅ -> D)
      DATA CDB/2.54174623D+0/
C
C     http://www.fileformat.info/info/unicode/font/gnu_unifont/grid.htm
C     https://coolsymbol.com/
C     WRITE(6, *) 'αβγδεζηθικλμνξοπρϱςστυφχψω'
C     WRITE(6, *) 'ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ  ΣΤΥΦΧΨΩ'
C     WRITE(6, *) 'ⅈℵℎℏℓℒℋℛℐℜℑℕℙℚℝℤℂ℘' 
C     WRITE(6, *) '×·∕−±∓≠∞—–…≪≫≤≥'
C     WRITE(6, *) '⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘'
C     WRITE(6, *) 'π∞Σ√∛'∜∫∬∭∮∯∰∀∂∃∄∅∆∇∈∉∋∌∎∏∐∑'
C     WRITE(6, *) '∗∝∠∡∢∧∨∩∪∴∵∶∷∼∽∿⊕⊖⊗⊘⊙⊚⊛⊜⊝␢Å'
C     WRITE(6, *) '‗‘’‚‛“”„‟•‣❛❜❝❞¿'
C     WRITE(6, *) '✓✔✗✘☓√☑☐☒☼❄❆♤♠♧♣♡♥♢♦'
C     WRITE(6, *) '¢$€£¥®™☎⌨✁✂✎✏✐§☛'
C     WRITE(6, *) '↕↖↗↘↙↚↛↥↦↧↰↱↲↳↴↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇠⇡⇢⏎▶➔➘➙➚➛➜➞↵⇑⇓'
C     WRITE(6, *) '★☆✡✦✧✩✪✰✢✣✤✥✱✲✳✴✵✶✷✸✹✺✻✼✽✾✿❀❁❂❃❇❈❉❊❋❄❆❅≛'
C     WRITE(6, *) 'äÄéÉ'
C
      END
C
C
      SUBROUTINE GAMGEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C       GG    GG   AAAA   MMM     MMM GG    GG EE       NNN   NN       C
C       GG        AA  AA  MMMM   MMMM GG       EE       NNNN  NN       C
C       GG       AA    AA MM MM MM MM GG       EEEEEE   NN NN NN       C
C       GG   GGG AAAAAAAA MM  MMM  MM GG   GGG EE       NN  NNNN       C
C       GG    GG AA    AA MM   M   MM GG    GG EE       NN   NNN       C
C        GGGGGG  AA    AA MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMGEN EVALUATES INTEGER/HALF-INTEGER GAMMA VALUES AND THEIR LOGS.  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ GAMLOG(N) = DLOG(GAMMA(N/2))                                      C
C  ▶ GAMHLF(N) = GAMMA(N/2)                                            C
C**********************************************************************C
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     STARTING VALUES
      GAMLOG(1) = PILG*0.5D0
      GAMLOG(2) = 0.0D0
      GAMHLF(1) = PI12
      GAMHLF(2) = 1.0D0
C
C     SEED VALUES FOR INCREMENT
      F1 = 0.5D0
      F2 = 1.0D0
C
C     FILL TABLE VALUES
      DO N=4,300,2
        GAMLOG(N-1) = GAMLOG(N-3)+DLOG(F1)
        GAMLOG(N  ) = GAMLOG(N-2)+DLOG(F2)
        GAMHLF(N-1) = GAMHLF(N-3)*F1
        GAMHLF(N  ) = GAMHLF(N-2)*F2
        F1 = F1+1.0D0
        F2 = F2+1.0D0
      ENDDO
C
      RETURN
      END
C
C
       SUBROUTINE FACTRL
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         FFFFFFFF   AA     CCCCCC TTTTTTTT RRRRRRR  LL                C
C         FF        AAAA   CC    CC   TT    RR    RR LL                C
C         FF       AA  AA  CC         TT    RR    RR LL                C
C         FFFFFF  AA    AA CC         TT    RR    RR LL                C
C         FF      AAAAAAAA CC         TT    RRRRRRR  LL                C
C         FF      AA    AA CC    CC   TT    RR    RR LL                C
C         FF      AA    AA  CCCCCC    TT    RR    RR LLLLLLLL          C
C                                                                      C
C -------------------------------------------------------------------- C
C  FACTRL GENERATES A SET OF N! AND N!! AS REAL NUMBERS.               C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ RFACT - REGULAR FACTORIALS, RFACT(N) = N!                         C
C  ▶ SFACT - SEMI-FACTORIALS,    SFACT(N) = N!!                        C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
      RFACT(0) = 1.0D0
      RFACT(1) = 1.0D0
      SFACT(0) = 1.0D0
      SFACT(1) = 1.0D0
      DO I=2,80
        RNUMBER  = DFLOAT(I)
        RFACT(I) = RNUMBER*RFACT(I-1)
        SFACT(I) = RNUMBER*SFACT(I-2)
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] NUCCOUL: NUCLEAR CHARGE DISTRIBUTION DETAILS.                  C
C   [C] POLYLOG: THE POLYLOGARITHM OF NEGATIVE EXPONENTIAL ARGUMENT.   C
C   [D] NUCGEOM: BOND DISTANCES AND NUCLEAR REPULSION ENERGY.          C
C   [E] FOCKIND: CALCULATE ADDRESSES OF FOCK MATRIX FOR BASIS QN'S.    C
C   [F] CARTIND: GENERATES INDICES FOR EQ-COEFFS AND R-INTEGRALS.      C
C   [G] AUFBAU: DETERMINES GROUND STATE ATOMIC ELECTRON CONFIG.        C
C   [I] SPECTRM: MOLECULAR SPECTRUM W/ EIGENVALUES AND TERM SYMBOLS.   C
C   [J] LLAB: GIVES THE CHARACTER CORRESPONDING TO LQN VALUE LQN.      C
C   [K] ROTATE: PERFORM TWO EULER ROTATIONS ON ALL ATOMIC CENTRES.     C
C   [L] MMPROD: PRODUCT OF TWO SQUARE ARRAYS OF DOUBLES.               C
C   [M] MVPROD: PRODUCT OF A SQUARE MATRIX AND VECTOR OF DOUBLES.      C
C   [N] HMS: RETURNS A QUOTED TIME IN SECONDS AS 'MIN-SEC'.            C
C   [O] MS: RETURNS A QUOTED TIME IN SECONDS AS 'HR-MIN-SEC'.          C
C   [P] TIMENOW: RETURNS A DATE STRING FOR THE CPU TIME.               C
C**********************************************************************C
C
C
      SUBROUTINE NUCCOUL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   CCCCCC   OOOOOO  UU    UU LL          C
C    NNN   NN UU    UU CC    CC CC    CC OO    OO UU    UU LL          C
C    NNNN  NN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN NN NN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN  NNNN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN   NNN UU    UU CC    CC CC    CC OO    OO UU    UU LL          C
C    NN    NN  UUUUUU   CCCCCC   CCCCCC   OOOOOO   UUUUUU  LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCCOUL CONTROLS THE CHARGE POTENTIALS THAT APPLY TO EACH NUCLEAR   C
C  CENTRE, GIVEN A RANGE OF NUCLEAR CHARGE MODELS AND QED OPTIONS.     C
C -------------------------------------------------------------------- C
C  THIS VERSION OF THE ROUTINE READS IN RESULTS FROM BERTHA-NUCLEAR.   C
C -------------------------------------------------------------------- C
C  ▶ NCOUL = 0 (POINT), NCOUL = 1 (GAUSS), NCOUL > 1 (FERMI).          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL FILETHERE
      CHARACTER*2 ELMT(120)
      CHARACTER*5 NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL,NUCFL
C
      DIMENSION RSQ(MCT),NCOUL(MCT)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
C
C     GAUSSIAN FITTING FOR ALL NUCLEI
      DO IZ=1,NCNT
C
C       NUCLEAR RADIUS
        IF(INT(ZNUC(IZ)).EQ.1) THEN
C         PROTON HAS A VERY SMALL RADIUS (IN FM)
          RFM = PRAD
        ELSEIF(ZNUC(IZ).GT.1.0D0.AND.ZNUC(IZ).LT.90.0D0) THEN
C         EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z < 90 (IN FM)
          RFM = 0.836D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.57D0
C         RFM = 1.20D0*(ANUC(IZ)**(1.0D0/3.0D0))
        ELSE
C         EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z > 90 (IN FM)
          RFM = 0.770D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.98D0
        ENDIF
C
C       CONVERT RESULT TO ATOMIC UNITS
        RNUC(IZ) = RFM/CFM
C
C       GAUSSIAN MODEL
        NNUC(IZ)   = 0
        FNUC(IZ,0) = 1.0D0
        XNUC(IZ,0) = 1.5D0/(RNUC(IZ)*RNUC(IZ))
C
C       FERMI MODEL
        TFMI(IZ) = 2.30D0/CFM
        AFMI(IZ) = 0.25D0*TFMI(IZ)/THLG
C
      ENDDO
C
C     NUCLEUS FILE NAME
      NUCFL = 'output/'//TRIM(MOLCL)//'_nuclear.dat'
C
C     TRY TO READ THE FILE IN
      INQUIRE(FILE=TRIM(NUCFL),EXIST=FILETHERE)
C
C     READ IN AN EXISTING FILE
      IF(FILETHERE) THEN
        OPEN(UNIT=8,FILE=TRIM(NUCFL),STATUS='UNKNOWN')
C
C         LOOP OVER NUCLEAR CENTERS
          DO IZ=1,NCNT
C
C           NUMBER OF FITTING FUNCTIONS AND RMS RADIUS
            READ(8, *) NNUC(IZ),RNUC(IZ)
C
C           AMPLITUDES AND PARAMETERS FOR EACH NUCLEAR FITTING FUNCTION
            DO IFT=0,NNUC(IZ)
              READ(8, *) FNUC(IZ,IFT),XNUC(IZ,IFT)
            ENDDO
C
C          LOCK OUT ACCESS TO FUNCTIONS FOR GAUSSIAN NUCLEUS
           IF(NMDL(IZ).EQ.'GAUSS') THEN
             NNUC(IZ) = 0
           ENDIF
C
C         FERMI MODEL PARAMETERS
          TFMI(IZ) = 2.30D0/CFM
          AFMI(IZ) = 0.25D0*TFMI(IZ)/THLG
C
          ENDDO
C
C       CLOSE DATA FILE
        CLOSE(UNIT=8)
C
C     CANNOT OPEN A FILE SO ASSUME GAUSSIAN
      ELSE
C
C       ALERT THE USER THAT THE NUCLEAR FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCCOUL: could not find nuclear data.'
        WRITE(7, *) 'In NUCCOUL: could not find nuclear data.'
C
C       ALERT THE USER THAT NUCLEI ARE GAUSSIAN NOW
21      FORMAT(26X,A)
22      FORMAT(1X,A,2X,'|',3X,A,4X,A,5X,A,1X,'|',1X,A,3X,A,3X,A)
23      FORMAT(1X,I2,' (',A,')',1X,'|',5X,I3,4X,F8.4,5X,F6.4,1X,'|',
     &                                             4X,I2,7X,A,2X,F10.8)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,21) 'Nuclear charge summary'
        WRITE(7,21) 'Nuclear charge summary'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,22) 'Centre','Z (e)','A (m_p+)','R (fm)',
     &              'N_fit','Potential','R-squared'
        WRITE(7,22) 'Centre','Z (e)','A (m_p+)','R (fm)',
     &              'N_fit','Potential','R-squared'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        DO IZ=1,NCNT
          IZNC = INT(ZNUC(IZ))
          WRITE(6,23) IZ,ELMT(IZNC),IZNC,ANUC(IZ),RNUC(IZ)*CFM,NNUC(IZ),
     &                                                 NMDL(IZ),RSQ(IZ)
          WRITE(7,23) IZ,ELMT(IZNC),IZNC,ANUC(IZ),RNUC(IZ)*CFM,NNUC(IZ),
     &                                                 NMDL(IZ),RSQ(IZ)
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE NUCVCPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC  VV    VV  CCCCCC  PPPPPPP  LL          C
C    NNN   NN UU    UU CC    CC VV    VV CC    CC PP    PP LL          C
C    NNNN  NN UU    UU CC       VV    VV CC       PP    PP LL          C
C    NN NN NN UU    UU CC       VV    VV CC       PP    PP LL          C
C    NN  NNNN UU    UU CC        VV  VV  CC       PPPPPPP  LL          C
C    NN   NNN UU    UU CC    CC   VVVV   CC    CC PP       LL          C
C    NN    NN  UUUUUU   CCCCCC     VV     CCCCCC  PP       LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCVCPL CONTROLS THE VACUUM POLARISATION POTENTIALS FOR ALL ATOMIC  C
C  CENTRES, GIVEN A RANGE OF NUCLEAR CHARGE MODELS AND QED OPTIONS.    C
C -------------------------------------------------------------------- C
C  THIS VERSION OF THE ROUTINE READS IN RESULTS FROM BERTHA-NUCLEAR.   C
C -------------------------------------------------------------------- C
C  ▶ NFT > 26 (FOR WHICHEVER NUCLEAR CHARGE MODEL.)                    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL FILETHERE
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*60 VACFL
C
      COMMON/BUEH/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/BKSB/RKSB(MCT,3),FKSB(MCT,MFT),XKSB(MCT,MFT),NKSB(MCT)
      COMMON/BWKR/RWKR(MCT,3),FWKR(MCT,MFT),XWKR(MCT,MFT),NWKR(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/QUEH/RU(0:NRAD),VU(MCT,0:NRAD),R0U,RMU,RIU,NUU,NEU
      COMMON/QWKR/RW(0:NRAD),VW(MCT,0:NRAD),R0W,RMW,RIW,NUW,NEW
      COMMON/QKSB/RK(0:NRAD),VK(MCT,0:NRAD),R0K,RMK,RIK,NUK,NEK
C
C     UEHLING POTENTIAL
      IF(HMLT.NE.'DHFQ'.AND.HMLT.NE.'DHFP') RETURN
C
C     UEHLING FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpuee.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
      IF(FILETHERE) THEN
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NUEH(IZ)
            DO IFT=1,NUEH(IZ)
              READ(8, *) FUEH(IZ,IFT),XUEH(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C       ALERT THE USER THAT THE UEHLING FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Uehling data. ',VACFL
        WRITE(7, *) 'In NUCVCPL: could not find Uehling data. ',VACFL
        DO IZ=1,NCNT
          NUEH(IZ) = 0
        ENDDO
      ENDIF
C
C     UEHLING RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpuee_grid.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
      IF(FILETHERE) THEN
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0U,RMU,RIU,NUU,NEU
          DO N=0,NRAD
            READ(8, *) RU(N),(VU(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
      ELSE
C       ALERT THE USER THAT THE UEH GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Uehling grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find Uehling grid data.'
        DO N=0,NRAD
          RU(N) = 0.0D0
          DO IZ=1,NCNT
            VU(IZ,N) = 0.0D0
          ENDDO
        ENDDO
      ENDIF
C
C     WICHMANN-KROLL FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpwkr.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
      IF(FILETHERE) THEN
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NWKR(IZ)
            DO IFT=1,NWKR(IZ)
              READ(8, *) FWKR(IZ,IFT),XWKR(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
      ELSE
C       ALERT THE USER THAT THE WICHMANN-KROLL FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Wichmann-Kroll data. ',
     &                                                            VACFL
        WRITE(7, *) 'In NUCVCPL: could not find Wichmann-Kroll data. ',
     &                                                            VACFL
        DO IZ=1,NCNT
          NWKR(IZ) = 0
        ENDDO
      ENDIF
CC
CC     WICHMANN-KROLL RADIAL GRID DATA
C      VACFL = 'output/'//TRIM(MOLCL)//'_vpwkr_grid.dat'
C      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C      IF(FILETHERE) THEN
CC       READ FITTING DATA IN FROM AN EXISTING FILE
C        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
C          READ(8, *) R0W,RMW,RIW,NUW,NEW
C          DO N=0,NRAD
C            READ(8, *) RW(N),(VW(IZ,N),IZ=1,NCNT)
C          ENDDO
C        CLOSE(UNIT=8)
C      ELSE
CC       ALERT THE USER THAT THE WKR GRID FILE COULD NOT BE FOUND
C        WRITE(6, *) 'In NUCVCPL: could not find WKR grid data.'
C        WRITE(7, *) 'In NUCVCPL: could not find WKR grid data.'
C        DO N=0,NRAD
C          RW(N) = 0.0D0
C          DO IZ=1,NCNT
C            VW(IZ,N) = 0.0D0
C          ENDDO
C        ENDDO
C      ENDIF
C
C     KÄLLÉN-SABRY FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpksb.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
      IF(FILETHERE) THEN
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NKSB(IZ)
            DO IFT=1,NKSB(IZ)
              READ(8, *) FKSB(IZ,IFT),XKSB(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
      ELSE
C       ALERT THE USER THAT THE KÄLLÉN-SABRY FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Källén-Sabry data.'
        WRITE(7, *) 'In NUCVCPL: could not find Källén-Sabry data.'
        DO IZ=1,NCNT
          NKSB(IZ) = 0
        ENDDO
      ENDIF
C
C     KÄLLÉN-SABRY RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpksb_grid.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
      IF(FILETHERE) THEN
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0K,RMK,RIK,NUK,NEK
          DO N=0,NRAD
            READ(8, *) RK(N),(VK(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
      ELSE
C       ALERT THE USER THAT THE KSB GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find KSB grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find KSB grid data.'
        DO N=0,NRAD
          RW(N) = 0.0D0
          DO IZ=1,NCNT
            VW(IZ,N) = 0.0D0
          ENDDO
        ENDDO
      ENDIF
C
C     NUMBER OF DATA POINTS IN UNIFORMLY-SPACED AND EXPONENTIAL REGION
      NLIN = NRAD/10 - MOD(NRAD/10,10)
      NEXP = NRAD-NLIN
C
C     GENERATE RADIAL GRID (LINEAR FROM FEMTOMETERS, EXPONENTIAL IN AU)
      RORI =  0.0D0/CFM
      RMID = 10.0D0/CFM
      RMAX =  0.5D0
C
      HL = (RMID-RORI)/DFLOAT(NLIN)
      HE = DLOG(RMAX/RMID)/DFLOAT(NEXP)
C
      RETURN
      END
C
C
      FUNCTION ERNUC(MODEL,IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             EEEEEEEE RRRRRRR  NN    NN UU    UU  CCCCCC              C
C             EE       RR    RR NNN   NN UU    UU CC    CC             C
C             EE       RR    RR NNNN  NN UU    UU CC                   C
C             EEEEEE   RR    RR NN NN NN UU    UU CC                   C
C             EE       RRRRRRR  NN  NNNN UU    UU CC                   C
C             EE       RR    RR NN   NNN UU    UU CC    CC             C
C             EEEEEEEE RR    RR NN    NN  UUUUUU   CCCCCC              C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERNUC EVALUATES THE VALUE OF THE NORMALISED NUCLEAR ELECTRIC FIELD  C
C  (RADIAL COMPONENT) AT RADIUS R, BASED ON A NUCLEAR CHARGE MODEL.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL,MODEL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In ERNUC: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In ERNUC: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     REASONS TO USE GAUSSIAN NUCLEAR CHARGE MODEL
      EPS = DSQRT(1.4D0)*PI*0.25D0*TFMI(IZ)/THLG
      IF(EPS.GT.RNUC(IZ)) THEN
C
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        IF(R.LT.0.2D0*RNUC(IZ)) THEN
          X1 = DSQRT(XI)*R
          X3 = XI*R*R*X1
          X5 = XI*R*R*X3
          X7 = XI*R*R*X5
          X9 = XI*R*R*X7
          ERNUC = 4.0D0*X1/3.0D0 - 4.0D0*X3/5.0D0 + 2.0D0*X5/7.0D0
     &          - 2.0D0*X7/27.0D0 + X9/66.0D0
          ERNUC = XI*ERNUC/PI12
        ELSE
          X1 = DSQRT(XI)*R
          ERNUC =-2.0D0*X1*DEXP(-X1*X1)/PI12 + DERF(X1)
          ERNUC = ERNUC/(R*R)
        ENDIF
        RETURN
C
      ENDIF
C
C     GAUSSIAN NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'GAUSS') THEN
C
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        IF(R.LT.0.2D0*RNUC(IZ)) THEN
          X1 = DSQRT(XI)*R
          X3 = XI*R*R*X1
          X5 = XI*R*R*X3
          X7 = XI*R*R*X5
          X9 = XI*R*R*X7
          ERNUC = 4.0D0*X1/3.0D0 - 4.0D0*X3/5.0D0 + 2.0D0*X5/7.0D0
     &          - 2.0D0*X7/27.0D0 + X9/66.0D0
          ERNUC = XI*ERNUC/PI12
        ELSE
          X1 = DSQRT(XI)*R
          ERNUC =-2.0D0*X1*DEXP(-X1*X1)/PI12 + DERF(X1)
          ERNUC = ERNUC/(R*R)
        ENDIF
C      
      ENDIF
C
C     FERMI NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'FERMI') THEN
C
        A = AFMI(IZ)
        C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &    - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
        C = DSQRT(C)
        U = A/C
C
C       NORMALISATION CONSTANT
        Y1 = 1.0D0
        Y2 = PI*PI*U*U
        Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
        YN = 1.0D0/(Y1+Y2+Y3)
C
C       ELECTRIC FIELD BY EXPANSION
        IF(R.LT.0.2D0*C) THEN
          ERNUC =-YN*R/(C*C*C)
        ELSEIF(R.LT.C) THEN
          E1 =-R*R*R/(C*C*C)
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(R-C)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(R-C)/A)/(C*C)
          E6 = 6.0D0*U*U*R*POLYLOG(2,(R-C)/A)/C
          ERNUC = YN*(E1+   E3+E4+E5+E6)/(R*R)
        ELSE
          E1 =-1.0D0
          E2 =-(PI*U)**2
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(C-R)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(C-R)/A)/(C*C)
          E6 =-6.0D0*U*U*R*POLYLOG(2,(C-R)/A)/C
          ERNUC = YN*(E1+E2+E3+E4+E5+E6)/(R*R)
        ENDIF
C
      ENDIF
C
C     HOMOGENEOUS BALL MODEL
      IF(MODEL.EQ.'UNIFM') THEN
C
        B = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
        IF(R.LE.B) THEN
          RN3   = RNUC(IZ)*RNUC(IZ)*RNUC(IZ)
          ERNUC = R/(B*B*B)
        ELSE
          ERNUC = 1.0D0/(R*R)
        ENDIF
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ERNUCDNS(MODEL,IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE RRRRRRR  NN    NN  CCCCCC  DDDDDDD  NN    NN  SSSSSS     C
C    EE       RR    RR NNN   NN CC    CC DD    DD NNN   NN SS    SS    C
C    EE       RR    RR NNNN  NN CC       DD    DD NNNN  NN SS          C
C    EEEEEE   RR    RR NN NN NN CC       DD    DD NN NN NN  SSSSSS     C
C    EE       RRRRRRR  NN  NNNN CC       DD    DD NN  NNNN       SS    C
C    EE       RR    RR NN   NNN CC    CC DD    DD NN   NNN SS    SS    C
C    EEEEEEEE RR    RR NN    NN  CCCCCC  DDDDDDD  NN    NN  SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERNUCDNS EVALUATES THE VALUE OF THE NORMALISED NUCLEAR E_R FIELD    C
C  AT RADIUS R, MULTIPLIED BY R**2, BASED ON A NUCLEAR CHARGE MODEL.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL,MODEL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In ERNUCDNS: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In ERNUCDNS: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     POINT-LINE NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'POINT') THEN
        ERNUCDNS = 1.0D0
      ENDIF
C
C     GAUSSIAN NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'GAUSS') THEN
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        X1 = DSQRT(XI)*R
        ERNUCDNS =-2.0D0*X1*DEXP(-X1*X1)/PI12 + DERF(X1)
      ENDIF
C
C     FERMI NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'FERMI') THEN
C
        A = AFMI(IZ)
        C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &    - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
        C = DSQRT(C)
        U = A/C
C
C       NORMALISATION CONSTANT
        Y1 = 1.0D0
        Y2 = PI*PI*U*U
        Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
        YN = 1.0D0/(Y1+Y2+Y3)
C
C       ELECTRIC FIELD BY EXPANSION
        IF(R.LT.C) THEN
          E1 =-R*R*R/(C*C*C)
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(R-C)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(R-C)/A)/(C*C)
          E6 = 6.0D0*U*U*R*POLYLOG(2,(R-C)/A)/C
          ERNUCDNS = YN*(E1+   E3+E4+E5+E6)
        ELSE
          E1 =-1.0D0
          E2 =-(PI*U)**2
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(C-R)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(C-R)/A)/(C*C)
          E6 =-6.0D0*U*U*R*POLYLOG(2,(C-R)/A)/C
          ERNUCDNS = YN*(E1+E2+E3+E4+E5+E6)
        ENDIF
C
      ENDIF
C
C     HOMOGENEOUS BALL MODEL
      IF(MODEL.EQ.'UNIFM') THEN
        B = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
        IF(R.LE.B) THEN
          RN3   = RNUC(IZ)*RNUC(IZ)*RNUC(IZ)
          ERNUCDNS = R*R*R/(B*B*B)
        ELSE
          ERNUCDNS = 1.0D0
        ENDIF
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION RHONUC(MODEL,IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        RRRRRRR  HH    HH  OOOOOO  NN    NN UU    UU  CCCCCC          C
C        RR    RR HH    HH OO    OO NNN   NN UU    UU CC    CC         C
C        RR    RR HH    HH OO    OO NNNN  NN UU    UU CC               C
C        RR    RR HHHHHHHH OO    OO NN NN NN UU    UU CC               C
C        RRRRRRR  HH    HH OO    OO NN  NNNN UU    UU CC               C
C        RR    RR HH    HH OO    OO NN   NNN UU    UU CC    CC         C
C        RR    RR HH    HH  OOOOOO  NN    NN  UUUUUU   CCCCCC          C
C                                                                      C
C -------------------------------------------------------------------- C
C  RHONUC EVALUATES THE VALUE OF THE NORMALISED NUCLEAR CHARGE DENSITY C
C  FOR NUCLEUS IZ AT RADIUS R, BASED ON A NUCLEAR CHARGE MODEL.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL,MODEL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In RHONUC: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In RHONUC: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     REASONS TO USE GAUSSIAN NUCLEAR CHARGE MODEL
      EPS = DSQRT(1.4D0)*PI*0.25D0*TFMI(IZ)/THLG
      IF(EPS.GT.RNUC(IZ)) THEN
C
C       NORMALISATION FACTOR
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        YN = XI*DSQRT(XI)/PI32
        RHONUC = YN*DEXP(-R*R*XI)
        RETURN
C
      ENDIF
C
C     GAUSSIAN NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'GAUSS') THEN
C
C       NORMALISATION FACTOR
        ZT = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        YN = ZT*DSQRT(ZT)/(PI*PI12)
        RHONUC = YN*DEXP(-R*R*ZT)
C      
      ENDIF
C
C     FERMI NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'FERMI') THEN
C
        A  = AFMI(IZ)
        C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &    - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
        C = DSQRT(C)
        U  = A/C
        C3 = C*C*C
C
C       NORMALISATION CONSTANT
        Y1 = 1.0D0
        Y2 = PI*PI*U*U
        Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
        YN = 1.0D0/(Y1+Y2+Y3)
        YN = 3.0D0*YN/(4.0D0*PI*C3)
C
C       EXACT FERMI DENSITY FORMULA
        PR = 1.0D0 + DEXP((R-C)/A)
        RHONUC = YN/PR
C
      ENDIF
C
C     HOMOGENEOUS BALL MODEL
      IF(MODEL.EQ.'UNIFM') THEN
C
        B = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
        IF(R.LE.B) THEN
          RHONUC = 0.75D0/(PI*B*B*B)
        ELSE
          RHONUC = 0.00D0
        ENDIF
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION POLYLOG(K,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP   OOOOOO  LL      YY    YY LL       OOOOOO   GGGGGG      C
C     PP    PP OO    OO LL      YY    YY LL      OO    OO GG    GG     C
C     PP    PP OO    OO LL      YY    YY LL      OO    OO GG           C
C     PP    PP OO    OO LL       YY  YY  LL      OO    OO GG           C
C     PPPPPPP  OO    OO LL        YYYY   LL      OO    OO GG   GGG     C
C     PP       OO    OO LL         YY    LL      OO    OO GG    GG     C
C     PP        OOOOOO  LLLLLLLL   YY    LLLLLLLL OOOOOO   GGGGGG      C
C                                                                      C
C -------------------------------------------------------------------- C
C  POLYLOG EVALUATES THE POLYLOGARITHM FUNCTION OF ORDER K AND         C
C  ARGUMENT -DEXP(X) USING A TRUNCATED SERIES EXPANSION OF LENGTH NTR. C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
C     TRUNCATION OPTION SHOULD BE GREATER THAN 1
      IF(NTR.LE.1) THEN
        WRITE(6, *) 'In POLYLOG: series trunction too low. NTR = ',NTR
        WRITE(7, *) 'In POLYLOG: series trunction too low. NTR = ',NTR
        STOP
      ENDIF
C
C     ARGUMENT X MUST BE NEGATIVE
      IF(X.GT.0.0D0) THEN
        WRITE(6, *) 'In POLYLOG: argument X must be negative. X = ',X
        WRITE(7, *) 'In POLYLOG: argument X must be negative. X = ',X
        STOP
      ENDIF
C
C     INITIAL VALUES
      PHS = 1.0D0
      VAL = 0.0D0
      DO N=1,NTR
        PHS =-PHS
        RNK = DFLOAT(N)**K
        VAL = VAL + PHS*DEXP(X*N)/RNK
      ENDDO
C
C     VALUE OF POLYLOG
      POLYLOG = VAL
C
      RETURN
      END
C
C
      FUNCTION SPINDOT(ITT1,ITT2,K1,K2,M1,M2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS  PPPPPPP IIII NN    NN DDDDDDD   OOOOOO TTTTTTTT       C
C       SS    SS PP    PP II  NNN   NN DD    DD OO    OO   TT          C
C       SS       PP    PP II  NNNN  NN DD    DD OO    OO   TT          C
C        SSSSSS  PP    PP II  NN NN NN DD    DD OO    OO   TT          C
C             SS PPPPPPP  II  NN  NNNN DD    DD OO    OO   TT          C
C       SS    SS PP       II  NN   NNN DD    DD OO    OO   TT          C
C        SSSSSS  PP      IIII NN    NN DDDDDDD   OOOOOO    TT          C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPINDOT DETERMINES A DOT PRODUCT OVER ANGULAR SPINOR INTEGRALS:     C
C                                                                      C
C       3                                                              C
C       Σ  A(T1,T1',IQ,κ1,κ2,m1,m2) • A(T2,T2',IQ,κ1,κ2,m1,m2).        C
C     IQ=1                                                             C
C                                                                      C
C  THIS FUNCTION WAS WRITTEN SPECIFICALLY FOR THE SLFLW0 BETHE FORMULA.C
C -------------------------------------------------------------------- C
C  ▶ ITT1  = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C  ▶ ITT2  = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C  ▶ K1,K2 = RELATIVISTIC SYMMETRY (KAPPA) NUMBERS.                    C
C  ▶ M1,M2 = MAGNETIC QUANTUM NUMBERS (INPUT IS DOUBLE THE TRUE VALUE).C
C**********************************************************************C
C
      COMPLEX*16 SPINDOT,SPINANG
C
      SPINDOT = SPINANG(ITT1,1,K1,K2,M1,M2)*SPINANG(ITT2,1,K2,K1,M2,M1)
     &        + SPINANG(ITT1,2,K1,K2,M1,M2)*SPINANG(ITT2,2,K2,K1,M2,M1)
     &        + SPINANG(ITT1,3,K1,K2,M1,M2)*SPINANG(ITT2,3,K2,K1,M2,M1)
C
      RETURN
      END
C
C
      FUNCTION SPINANG(ITT,IQ,K1,K2,M1,M2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       SSSSSS  PPPPPPP IIII NN    NN    AA    NN    NN  GGGGGG        C
C      SS    SS PP    PP II  NNN   NN   AAAA   NNN   NN GG    GG       C
C      SS       PP    PP II  NNNN  NN  AA  AA  NNNN  NN GG             C
C       SSSSSS  PP    PP II  NN NN NN AA    AA NN NN NN GG             C
C            SS PPPPPPP  II  NN  NNNN AAAAAAAA NN  NNNN GG   GGG       C
C      SS    SS PP       II  NN   NNN AA    AA NN   NNN GG    GG       C
C       SSSSSS  PP      IIII NN    NN AA    AA NN    NN  GGGGGG        C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPINANG DETERMINES THE INTEGRAL OVER TWO ANGULAR SPINORS AND A      C
C  PAULI MATRIX, INVOLVING COMPONENT TYPES AND CARTESIAN MATRICES.     C
C                                                                      C
C                                     ↥T            T'                 C
C       A(T,T',IQ,κ1,κ2,m1,m2) = ∬   χ   (θ,φ) σ   χ   (θ,φ) dΩ        C
C                                 4π  κ1,m1     IQ  κ2,m2              C
C                                                                      C
C -------------------------------------------------------------------- C
C  ▶ ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C  ▶ IQ    = {0,1,2,3} THE PAULI COUPLING MATRIX.                      C
C  ▶ K1,K2 = RELATIVISTIC SYMMETRY (KAPPA) NUMBERS.                    C
C  ▶ M1,M2 = MAGNETIC QUANTUM NUMBERS (INPUT IS DOUBLE THE TRUE VALUE).C
C**********************************************************************C
C
      COMPLEX*16 SPINANG
      COMPLEX*16 CONE
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIAL VALUE FOR THIS INTEGRAL
      SPINANG = DCMPLX(0.0D0,0.0D0)
C
C     INITIAL VALUES FOR COEFFICIENTS
C
C     ORBITAL AND PARITY NUMBERS
      IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
        L1 = LVAL( K1)
        N1 = K1/IABS(K1)
      ELSE
        L1 = LVAL(-K1)
        N1 =-K1/IABS(K1)
      ENDIF
C
      IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
        L2 = LVAL( K2)
        N2 = K2/IABS(K2)
      ELSE
        L2 = LVAL(-K2)
        N2 =-K2/IABS(K2)
      ENDIF
C
C     LQN SELECTION RULES
      IF(L1.NE.L2) RETURN
C
C     COEFFICIENTS BASED ON MQN SELECTION RULES
      C11 = DCMPLX(0.0D0,0.0D0)
      C22 = DCMPLX(0.0D0,0.0D0)
      IF(M1.EQ.M2) THEN
        C11 = N1*N2*CLEBSCH(L1,M1,-N1)*CLEBSCH(L2,M2,-N2)
        C22 =       CLEBSCH(L1,M1, N1)*CLEBSCH(L2,M2, N2)
      ENDIF
C
      C12 = DCMPLX(0.0D0,0.0D0)
      IF(M1.EQ.M2+2) THEN
        C12 =-N1*   CLEBSCH(L1,M1,-N1)*CLEBSCH(L2,M2, N2)
      ENDIF
C
      C21 = DCMPLX(0.0D0,0.0D0)
      IF(M1.EQ.M2-2) THEN
        C21 =-   N2*CLEBSCH(L1,M1, N1)*CLEBSCH(L2,M2,-N2)
      ENDIF
C
C     IMPLEMENT PAULI MATRICES
      IF(IQ.EQ.0) THEN
        SPINANG = C11+C22
      ELSEIF(IQ.EQ.1) THEN
        SPINANG = C12+C21
      ELSEIF(IQ.EQ.2) THEN
        SPINANG =-C12+C21
        SPINANG = CONE*SPINANG
      ELSEIF(IQ.EQ.3) THEN
        SPINANG = C11-C22
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION CLEBSCH(LQN,MQN,NSGN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC  LL       EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C    CC       LL       EE       BB    BB SS       CC       HH    HH    C
C    CC       LL       EEEEEE   BBBBBBB   SSSSSS  CC       HHHHHHHH    C
C    CC       LL       EE       BB    BB       SS CC       HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C     CCCCCC  LLLLLLLL EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLEBSCH DETERMINES A CLEBSCH-GORDAN COEFFICIENT FOR LQN, MQN AND    C
C  NSGN -- THESE ARE THE COEFFICIENTS IN FRONT OF THE SPIN-ANGULAR     C
C  FUNCTIONS FOR A GIVEN COMPONENT TYPE.                               C
C**********************************************************************C
C
      T1 = 2.0D0*LQN + 1.0D0 + MQN*NSGN
      T2 = 4.0D0*LQN + 2.0D0
C
      CLEBSCH = DSQRT(T1/T2)
C
      RETURN
      END
C
C
      SUBROUTINE NUCGEOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  NN    NN UU    UU  CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C  NNN   NN UU    UU CC    CC GG    GG EE       OO    OO MMM     MMM   C
C  NNNN  NN UU    UU CC       GG       EE       OO    OO MMMM   MMMM   C
C  NN NN NN UU    UU CC       GG       EEEEEE   OO    OO MM MM MM MM   C
C  NN  NNNN UU    UU CC       GG   GGG EE       OO    OO MM  MMM  MM   C
C  NN   NNN UU    UU CC    CC GG    GG EE       OO    OO MM   M   MM   C
C  NN    NN  UUUUUU   CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGEOM TRANSLATES AND ROTATES A MOLECULE IN A WAY THAT IS BEST     C
C  SUITED TO EFFICIENT COMPUTATION, IDENTIFIES MOLECULAR SHAPE AND     C
C  BOND DISTANCES, AND CALCULATES NUCLEAR REPULSION ENERGY.            C
C -------------------------------------------------------------------- C
C  ▶ THE TSYM PACKAGE (WERNER 1996) CAN BE DIRECTLY IMPLEMENTED HERE - C
C    IT PERFORMS POINT GROUP SYMMETRY ANALYSIS. THIS ALLOWS A BLOCK    C
C    STRUCTURE ACCORDING TO IRREPS FOR THE HAMILTONIAN MATRIX (FASTER).C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL TRANSFORM
C
      CHARACTER*2 ELMT(120),ELA,ELB,ELC
      CHARACTER*4 UCHR
      CHARACTER*5 NMDL
      CHARACTER*8 SPCES
C
      DIMENSION XYZ(3,MCT),DIST(MCT),CENT(3),IZAD(MCT,3)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EANM,ESLF,EUEH,
     &            EWKR,EKSB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
C
C     CHOICE OF UNITS -- 1 FOR AU, 2 FOR ÅNGSTROM
      IUNIT = 1
C
      IF(IUNIT.EQ.1) THEN
        UCHR = '(a0)'
        CFCT = 1.0D0
      ELSEIF(IUNIT.EQ.2) THEN
        UCHR = '(Å)'
        CFCT = CNG
      ENDIF
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',19),'NUCLEAR COORDINATES AND POTENTIALS'
      WRITE(7, *) REPEAT(' ',19),'NUCLEAR COORDINATES AND POTENTIALS'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     LOGICAL OPTION TO DISABLE ROTATION/TRANSLATION
      TRANSFORM = .TRUE.
C
      IF(.NOT.TRANSFORM) GOTO 500
C
C**********************************************************************C
C     IDENTIFY LARGEST ATOMIC CENTRES                                  C
C**********************************************************************C
C
C     IDENTIFY THE THREE LARGEST NUCLEAR CHARGES
      LZ1 = 0
      LZ2 = 0
      LZ3 = 0
      DO N=1,NCNT
        IZ = INT(ZNUC(N))
        IF(IZ.GT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = LZ1
          LZ1 = IZ
        ELSEIF(IZ.GT.LZ2.AND.IZ.LT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = IZ
        ELSEIF(IZ.GT.LZ3.AND.IZ.LT.LZ2) THEN
          LZ3 = IZ
        ENDIF
      ENDDO
C
C     COUNT CENTRES WITH TOP THREE NUCLEAR CHARGES
      NZ1 = 0
      NZ2 = 0
      NZ3 = 0
      DO N=1,NCNT
        IZ = INT(ZNUC(N))
        IF(IZ.EQ.LZ1) THEN
          NZ1 = NZ1 + 1
          IZAD(NZ1,1) = N
        ELSEIF(IZ.EQ.LZ2) THEN
          NZ2 = NZ2 + 1
          IZAD(NZ2,2) = N
        ELSEIF(IZ.EQ.LZ3) THEN
          NZ3 = NZ3 + 1
          IZAD(NZ3,3) = N
        ENDIF
      ENDDO
C
C     DESIGNATE SPECIES OF MOLECULE
      IF(NZ2.EQ.0) THEN
        SPCES = 'HOMONUC.'
      ELSE
        SPCES = 'HTRONUC.'
      ENDIF
C
C**********************************************************************C
C     TRANSLATION: ORIGIN COINCIDES WITH CENTRE OF ALL HEAVY ATOMS     C
C**********************************************************************C
C
C     CALCULATE CENTRE OF ALL CHARGES LZ1
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ1
          CENT(I) = CENT(I) + BXYZ(I,IZAD(N,1))
        ENDDO
        CENT(I) = CENT(I)/NZ1
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     TRANSLATE MOLECULE BY CENT(I) AND CALCULATE DISTANCE TO ORIGIN
      DO N=1,NCNT
        DO I=1,3
          XYZ(I,N) = BXYZ(I,N) - CENT(I)
        ENDDO
        DIST(N) = DSQRT(XYZ(1,N)**2 + XYZ(2,N)**2 + XYZ(3,N)**2)
      ENDDO
C
C     ALERT THE USER IF TRANSLATION WAS SUBSTANTIAL
      IF(DCNT.GT.1.0D-4) THEN
        WRITE(6, *) 'In NUCGEOM: molecule has been translated.'
        WRITE(7, *) 'In NUCGEOM: molecule has been translated.'
      ENDIF
C
C     ONE-CENTRE (MUST BE ATOMIC)
      IF(NCNT.EQ.1) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'ATOMIC'
C
C       NO ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     FIRST ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Z-AXIS.   C
C**********************************************************************C
C
C     IF AN LZ1 CENTRE IS ON Z-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(3,N))
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 200
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        IF(DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 35
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE Z-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON Z-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DABS(CENT(3))
      IF(DABS(X).LT.1.0D-4.AND.DCNT.GT.1.0D-4) THEN
        GOTO 200
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON AN LZ2 NOT ON THE ORIGIN
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          IF(DIST(N).GT.1.0D-4) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 35
          ENDIF
        ENDDO
      ENDIF
C
C     LZ1 AND LZ2 ALWAYS SUFFICIENT TO DEFINE A Z ORIENTATION
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
35    CONTINUE
C
C     CALCULATE FIRST ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
C     BETA  IS ROTATION ANGLE FROM (X,Z) TO (0,Z')
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      BETA  = DACOS(CENT(3)/DCNT)
      CALL ROTATE(XYZ,NCNT,ALPHA,BETA)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Z-AXIS ROTATION NECESSARY
200   CONTINUE
C
C     TWO-CENTRE (MUST BE DIATOMIC)
      IF(NCNT.EQ.2) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'DIATOM'
C
C       NO FURTHER ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     SECOND ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Y-AXIS.  C
C**********************************************************************C
C
C     CHECK WHETHER MOLECULE IS LINEAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2 + XYZ(2,N)**2
        IF(TEST.GT.1.0D-6) GOTO 40
      ENDDO
      SHAPE = 'LINEAR'
      GOTO 300
40    CONTINUE
C
C     IF AN LZ1 CENTRE IS ON YZ-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DSQRT(XYZ(2,N)**2 + XYZ(3,N)**2)
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 300
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN OR Z-AXIS
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(2,N))
        IF(DABS(X).GT.1.0D-4.AND.DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 50
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     IF THERE ARE NO LZ2 CENTRES, SKIP ROTATION
      IF(NZ2.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ2 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ2 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ3.
C
C     IF THERE ARE NO LZ3 CENTRES, SKIP ROTATION
      IF(NZ3.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ3
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ3
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ3
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ3 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ3 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
50    CONTINUE

C     CALCULATE ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      CALL ROTATE(XYZ,NCNT,ALPHA,0.0D0)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Y-AXIS ROTATION NECESSARY
300   CONTINUE
C
C     IF MOLECULE ALREADY HAS LABEL, SKIP
      IF(SHAPE.EQ.'ATOMIC') GOTO 400
      IF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') GOTO 400
C
C     CHECK WHETHER MOLECULE IS PLANAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2
        IF(TEST.GT.1.0D-6) GOTO 60
      ENDDO
      SHAPE = 'PLANAR'
60    CONTINUE
C
C     NO MOLECULAR SYMMETRY
      SHAPE = 'NOSYMM'
C
400   CONTINUE
C
C     TRANSFER ALL TEMPORARY COORDINATES TO THE COMMON ARRAY
      DO N=1,NCNT
        DO I=1,3
          BXYZ(I,N) = XYZ(I,N)
        ENDDO
      ENDDO
C
C     ROTATION/TRANSLATION SKIP
500   CONTINUE
C
C**********************************************************************C
C     MOLECULAR GEOMETRY, BOND DISTANCES AND NUCLEAR REPULSION ENERGY  C
C**********************************************************************C
C
C     ATOMIC COORDINATES
20    FORMAT(11X,A,1X,A)
21    FORMAT(1X,A,12X,A,14X,A,14X,A)
22    FORMAT(1X,I2,' (',A,') ',6X,F16.10,5X,F16.10,5X,F16.10)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) '  Molecular geometry A: Cartesian coordinates',UCHR
      WRITE(7,20) '  Molecular geometry A: Cartesian coordinates',UCHR
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(7,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IZ=1,NCNT
        ELA = ELMT(INT(ZNUC(IZ)))
        WRITE(6,22) IZ,ELA,(CFCT*BXYZ(IX,IZ),IX=1,3)
        WRITE(7,22) IZ,ELA,(CFCT*BXYZ(IX,IZ),IX=1,3)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     BOND ANGLES AND DISTANCES
30    FORMAT(21X,A)
31    FORMAT(1X,A,6X,A,1X,A,11X,A,12X,A)
32    FORMAT(1X,A,2X,A,7X,F14.6)
33    FORMAT(40X,A,2X,A,2X,A,9X,F14.6)
      IF(NCNT.EQ.1) THEN
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
      ELSEIF(NCNT.GT.1) THEN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Molecular geometry B: R-matrix'
        WRITE(7,30) 'Molecular geometry B: R-matrix'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,31) 'C1  C2','Bond length',UCHR,'C1  C2  C3',
     &                                                    'Angle (deg)'
        WRITE(7,31) 'C1  C2','Bond length',UCHR,'C1  C2  C3',
     &                                                    'Angle (deg)'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
        ICNT = 1
        DO JCNT=2,NCNT
          ELA = ELMT(INT(ZNUC(ICNT)))
          ELB = ELMT(INT(ZNUC(JCNT)))
          R1X = BXYZ(1,JCNT) - BXYZ(1,ICNT)
          R1Y = BXYZ(2,JCNT) - BXYZ(2,ICNT)
          R1Z = BXYZ(3,JCNT) - BXYZ(3,ICNT)
          D1  = DSQRT(R1X*R1X + R1Y*R1Y + R1Z*R1Z)
          WRITE(6,32) ELA,ELB,CFCT*D1
          WRITE(7,32) ELA,ELB,CFCT*D1
C
          DO KCNT=2,JCNT-1
            ELA = ELMT(INT(ZNUC(ICNT)))
            ELB = ELMT(INT(ZNUC(JCNT)))
            ELC = ELMT(INT(ZNUC(KCNT)))
            R2X = BXYZ(1,KCNT) - BXYZ(1,ICNT)
            R2Y = BXYZ(2,KCNT) - BXYZ(2,ICNT)
            R2Z = BXYZ(3,KCNT) - BXYZ(3,ICNT)
            D2  = DSQRT(R2X*R2X + R2Y*R2Y + R2Z*R2Z)
            SP  = (R1X*R2X + R1Y*R2Y + R1Z*R2Z)
            D12 = D1*D2
            DEG = 180.0D0/PI
            ANG = DEG*DACOS(SP/D12)
            WRITE(6,33) ELB,ELA,ELC,ANG
            WRITE(7,33) ELB,ELA,ELC,ANG
          ENDDO
          IF(JCNT.NE.NCNT) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
          ENDIF
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
        DO ICNT=1,NCNT
          DO JCNT=1,ICNT-1
            SEP  = DSQRT((BXYZ(1,ICNT) - BXYZ(1,JCNT))**2
     #                  +(BXYZ(2,ICNT) - BXYZ(2,JCNT))**2
     #                  +(BXYZ(3,ICNT) - BXYZ(3,JCNT))**2)
            EPNT = ZNUC(ICNT)*ZNUC(JCNT)/SEP
C
CC          TODO: MAKE SURE THIS IS RIGHT -- UPDATED WITH FERMI CHARGE
CC          THIS CODE INCLUDES GAUSSIAN CHARGE STRUCTURE EFFECTS,
CC          BUT CORRECTIONS EXCEED DOUBLE FLOAT ACCURACY LIMITS...
C           EERF = 0.0D0
C           DO IFT=1,NNUC(ICNT)
C             DO JFT=1,NNUC(JCNT)
C               EPRD = XNUC(ICNT,IFT)*XNUC(JCNT,JFT)
C               ESUM = XNUC(ICNT,IFT)+XNUC(JCNT,JFT)
C               EGAU = DSQRT(EPRD/ESUM)*SEP
C               EERF = EERF + FNUC(ICNT,IFT)*FNUC(JCNT,JFT)*DERF(EGAU)
C             ENDDO
C           ENDDO
C           ESEP = EPNT*EERF
C
            ESEP = EPNT
            ENUC = ENUC + ESEP

          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FOCKIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C       FF      OO    OO CC    CC KK   KK   II  NNN   NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NNNN  NN DD    DD      C
C       FFFFFF  OO    OO CC       KKKKK     II  NN NN NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NN  NNNN DD    DD      C
C       FF      OO    OO CC    CC KK   KK   II  NN   NNN DD    DD      C
C       FF       OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FOCKIND ASSIGNS INDICES FOR FOCK MATRIX BLOCKS DEPENDING ON BASIS   C
C  NUMBERS IZ, KQN AND MQN QUANTUM NUMBERS OF EACH BASIS FUNCTION.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
C     QUANTUM NUMBER LABELS
      ILST = 0
      DO IZ=1,NCNT
        DO IMV=0,MEL
          MQN = 2*IMV+1
C
C         LABEL MQN<0 BLOCKS
          DO KA=1,NKAP(IZ)
            KQN = KAPA(KA,IZ)
            LQN = LVAL(KQN)
            NBAS  = NFNC(LQN,IZ)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(IZ,KA,MQN) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = IZ
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) =-MQN
              ENDDO
              ILST = ILST+NBAS
            ENDIF
          ENDDO
C
C         LABEL MQN>0 BLOCKS
          DO KA=1,NKAP(IZ)
            KQN = KAPA(KA,IZ)
            LQN = LVAL(KQN)
            NBAS  = NFNC(LQN,IZ)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(IZ,KA,MQN+1) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = IZ
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) = MQN
              ENDDO
              ILST = ILST + NBAS
            ENDIF
          ENDDO

        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE CARTIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        CCCCCC     AA    RRRRRRR TTTTTTTT IIII NN    NN DDDDDDD       C
C       CC    CC   AAAA   RR    RR   TT     II  NNN   NN DD    DD      C
C       CC        AA  AA  RR    RR   TT     II  NNNN  NN DD    DD      C
C       CC       AA    AA RR    RR   TT     II  NN NN NN DD    DD      C
C       CC       AAAAAAAA RRRRRRR    TT     II  NN  NNNN DD    DD      C
C       CC    CC AA    AA RR    RR   TT     II  NN   NNN DD    DD      C
C        CCCCCC  AA    AA RR    RR   TT    IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CARTIND GENERATES INDICES FOR EQ-COEFFICIENTS AND R-INTEGRALS.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     LOOP OVER ALL (A,B,C) SO THAT A+B+C=LAM AND APPLY ORDERED ADDRESS
C     (USE T, U AND V AS INTERMEDIATE COUNTERS RESPECTIVELY)
      N = 0
      DO LAM=0,ML4
        DO IT=0,LAM
          DO IU=0,LAM
            DO IV=0,LAM
C
C             TEST WHETER A+B+C=LAM
              IF(IT+IU+IV.NE.LAM) GOTO 10
C
C             UPDATE ADDRESS
              N = N+1
C
C             CARTESIAN INDICES (A,B,C) AND LAM VALUE FOR THIS ADDRESS
              IA(N) = IT
              IB(N) = IU
              IC(N) = IV
              ILAM(N) = LAM
C
C             GLOBAL ADDRESS FOR THIS (A,B,C) INDEX
              IABC(IT,IU,IV) = N
C
C             SKIP POINT FOR (A,B,C) THAT DO NOT ADD TO LAM
10            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AUFBAU(IZNC,IQNC,NORB,NOCC,LMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            AA    UU    UU FFFFFFF BBBBBBB     AA    UU    UU         C
C           AAAA   UU    UU FF      BB    BB   AAAA   UU    UU         C
C          AA  AA  UU    UU FF      BB    BB  AA  AA  UU    UU         C
C         AA    AA UU    UU FFFFF   BBBBBBB  AA    AA UU    UU         C
C         AAAAAAAA UU    UU FF      BB    BB AAAAAAAA UU    UU         C
C         AA    AA UU    UU FF      BB    BB AA    AA UU    UU         C
C         AA    AA  UUUUUU  FF      BBBBBBB  AA    AA  UUUUUU          C
C                                                                      C
C -------------------------------------------------------------------- C
C  AUFBAU DETERMINES THE GROUND STATE ELECTRONIC CONFIGURATION OF AN   C
C  ATOM WITH IQNC ELECTRONS. LIMITS ON # ELECTRONS IN THE ATOM:        C
C -------------------------------------------------------------------- C
C  LMAX |  0    1    2    3    4    5 |   OR IN GENERAL FOR LMAX,      C
C  NMAX |  4   20   56  120  220  364 |   NMAX = (2L+2)(2L+3)(2L+4)/6. C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ LMAX IS THE HIGHEST LQN REQUIRED TO DESCRIBE THE GROUND STATE     C
C  ▶ NOCC SAVES THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS      C
C  ▶ NORB SAVES THE NUMBER OF ELECTRONS IN OF TYPE LQN IN SHELL N      C
C  PARAMETERS:                                                         C
C  ▶ IORD STORES THE LQN OF ORBITALS IN ORDER OF HYDROGENIC ENERGY     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION NORB(0:MEL,MKP+1),NOCC(0:MEL),IORD((MEL+1)*(MEL+2))
C
C     INITIALISE THE OCCUPIED NQN SHELL COUNTER FOR EACH LQN
      DO LQN=0,MEL
        NOCC(LQN) = 0
      ENDDO
C
C     RECORD LQNS AS THEY APPEAR IN A FULL AUFBAU COUNT UP TO LMAX
      ICT = 0
C
C     EACH LQN AS THE HIGHEST
      DO LHIGH=0,MEL
C
C       GET TWO DIAGONAL STRIKES FOR THIS LHIGH
        DO MDIAG=1,2
C
C         GO BACKWARDS FROM THIS LQN DOWN TO ZERO AND RECORD LQN
          DO LQN=LHIGH,0,-1
            ICT = ICT + 1
            IORD(ICT) = LQN
          ENDDO
C
        ENDDO
C
      ENDDO
C
C     INITIALISE THE MAX LQN COUNTER
      LMAX = 0
C
C     INITIALISE THE NUMBER OF ELECTRONS LEFT TO FILL ORBITALS WITH
      ILEFT = IQNC
C
C     INITIALISE LOOP OVER ORBITALS
      DO M=1,(MEL+1)*(MEL+2)
C
C       EXIT IF THERE ARE NO ELECTRONS LEFT TO COUNT
        IF(ILEFT.EQ.0) GOTO 20
C
C       THE LQN OF THIS ORBITAL IS STORED IN IORD
        LQN = IORD(M)
C
C       UPDATE THE MAX LQN COUNTER IF NECESSARY
        IF(LQN.GT.LMAX) THEN
          LMAX = LQN
        ENDIF
C
C       ADD TO THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS
        NOCC(LQN) = NOCC(LQN)+1
C
C       DETERMINE NO. OF ELECTRONS REQ'D TO FULLY OCCUPY THIS SUBSHELL
        IFULL = 4*LQN + 2
C
C       BEGIN IF STATEMENT TO DETERMINE THE SUBSHELL OCCUPATION
        IF(ILEFT.GT.IFULL) THEN
C
C         IF THERE ARE MORE ELECTRONS LEFT THAN IFULL, FILL THE SUBSHELL
          NORB(LQN,NOCC(LQN)) = IFULL
          ILEFT = ILEFT-IFULL
C
        ELSE
C
C         OTHERWISE, LEAVE ALL REMAINING ELECTRONS IN THIS NSHELL
          NORB(LQN,NOCC(LQN)) = ILEFT
          GOTO 20
C
C       END THE NSHELL IF STATEMENT
        ENDIF
C
C     END LOOP OVER ATOMIC ORBITALS
      ENDDO
20    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM(IBND,IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  PPPPPPP  EEEEEEEE  CCCCCC TTTTTTTT RRRRRRR  MM       MM   C
C   SS    SS PP    PP EE       CC    CC   TT    RR    RR MMM     MMM   C
C   SS       PP    PP EE       CC         TT    RR    RR MMMM   MMMM   C
C    SSSSSS  PP    PP EEEEEE   CC         TT    RR    RR MM MM MM MM   C
C         SS PPPPPPP  EE       CC         TT    RRRRRRR  MM  MMM  MM   C
C   SS    SS PP       EE       CC    CC   TT    RR    RR MM   M   MM   C
C    SSSSSS  PP       EEEEEEEE  CCCCCC    TT    RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM SUMMARISES THE ENERGY LEVELS OF AN SCF ITERATION, USING     C
C  ATOMIC TERM SYMBOLS, ATOMIC CENTRES AND FRACTIONAL POPULATIONS.     C
C  IT ALSO APPLIES SYMMETRY LABELS TO EACH STATE AND SORTS MQN M'FOLDS.C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IBND - NUMBER OF BOUND ORBITALS TO INCLUDE.                       C
C  ▶ IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE.                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 CHL,LLAB
      CHARACTER*5 NMDL
      CHARACTER*2 ELMT(120),ELA
C
      DIMENSION FRAC(MDM,MCT,MKP,MKP+1),NPR(MCT,MKP,MKP+1)
      DIMENSION ICNLST(MDM),KQNLST(MDM),MQNLST(MDM),NQNLST(MDM),
     &          POPLST(MDM)
C
      COMPLEX*16 CTEMP,ROT1,ROT2
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SPEC/KQNLST,MQNLST,NQNLST
C
C     CALCULATE OVERLAP FOR NEW CALCULATION RUN
      CALL OVRLP
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-16
C
C     INITIALISE COUNTER ARRAYS
      DO IZ=1,NCNT
        DO IKAP=1,NKAP(IZ)
          IKQN = KAPA(IKAP,IZ)
          IF(IKQN.LT.0) THEN
            ILQN =-IKQN-1
          ELSE
            ILQN = IKQN
          ENDIF
          NMV = 2*IABS(IKQN)
          DO IMV=1,NMV
            DO IOCC=1,IBND+IVIR
              FRAC(IOCC,IZ,IKAP,IMV) = 0.0D0
            ENDDO
            NPR(IZ,IKAP,IMV) = ILQN
          ENDDO
        ENDDO
      ENDDO
C
C     INTERNAL ROTATION BETWEEN PAIRS OF STATES
      DO IPAIR=1,NDIM-NSKP,2
C
C       SKIP NEGATIVE ENERGY SPECTRUM
        MPAIR = IPAIR+NSKP
C
C       TEMPORARY LARGE VALUE
        RLRG = 10.0D+10
C
C       INITIAL INCREMENTAL RADIAN (SWEEP OVER ALL POSSIBLE ANGLES)
        RINC = PI/180.0D0
C
C       SEARCH FOR STARTING POINT BY SWEEPING ANGLES 0 <= φ < PI
        DO NPHI=0,179
C
C         CALCULATE ROTATION ANGLE AND COS/SIN TRANSFORMATIONS
          PHI  = RINC*DFLOAT(NPHI)
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         FIND PHI WHICH RESULTS IN SMALLEST SUM OF PRODUCTS
          IF(OLAP.LT.RLRG) THEN
            PHI0 = PHI
            RLRG = OLAP
          ENDIF
        ENDDO
C
C       NEW STARTING ROTATION ANGLE BASED ON THE ABOVE SEARCH
        PHI  = PHI0 - RINC
        SOLD = 1.0D+11
C
C       SWEEP THROUGH INCREMENTAL ANGLES AND SEARCH AGAIN
        DO NPHI=1,4000
          PHI  = PHI + RINC
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + ABS(CONJG(ROT1)*(ROT2))
          ENDDO
C
C         IF THE NEW VALUE IS BELOW A TOLERANCE, FINISH.
          IF(DABS(OLAP-SOLD).LT.EPS) GOTO 1
C
C         IF SUM OF COEFFICIENT PRODUCTS IS BIGGER THAN COUNTER, REFINE.
          IF(OLAP.GT.SOLD) THEN
            RINC =-RINC/10.0D0
          ENDIF
C
C         DECREASE COUNTER VALUE
          SOLD = OLAP
C
        ENDDO
1       CONTINUE
C
C       PERFORM THE ACTUAL ROTATION USING THE BEST SOLUTION PHI
        CPHI = DCOS(PHI)
        SPHI = DSIN(PHI)
        DO I=1,NDIM
C
          ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
          ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
C
          COEF(I,MPAIR  ) = ROT1
          COEF(I,MPAIR+1) = ROT2
C
        ENDDO
C
      ENDDO
C
C     CALCULATE FRACTIONAL OCCUPATION FOR EACH SOLUTION VECTOR
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,IBND+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC+NSKP
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSKP
          IS = I+NSKP
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = LABMQN(I)
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IF(IMQN.LT.0) THEN
            IMV = IABS(IMQN)
          ELSE
            IMV = IMQN+1
          ENDIF
C
          DO J=1,NDIM-NSKP
            JS = J+NSKP
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = LABMQN(J)
C
C           LARGE AND SMALL CONTRIBUTIONS
            TMP = DREAL(DCONJG(COEF(I ,MOCC))*COEF(J ,MOCC)*OVLP(I ,J ))
     &          + DREAL(DCONJG(COEF(IS,MOCC))*COEF(JS,MOCC)*OVLP(IS,JS))
C
C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRAC(IOCC,ICNT,IKAP,IMV) = FRAC(IOCC,ICNT,IKAP,IMV) + TMP
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     IDENTIFY CONVENTIONAL DIRAC QUANTUM NUMBERS BASED ON FRAC.
C
C     LOOP OVER POSITIVE ENERGY SPECTRUM IN PAIRS
      DO IOCC=1,NDIM-NSKP
C
C       SEARCH FOR HIGHEST POPULATED ATOMIC STATE
        PLTN = 0.0D0
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = 2*IABS(IKQN)
            DO IMV=1,NMV
              IF(FRAC(IOCC,ICNT,IKAP,IMV).GT.PLTN) THEN
                PLTN = FRAC(IOCC,ICNT,IKAP,IMV)
                KCNT = ICNT
                KKQN = IKQN
                KKAP = IKAP
                KMV  = IMV
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        NPR(KCNT,KKAP,KMV) = NPR(KCNT,KKAP,KMV)+1
C
C       APPLY DIRAC LABELS ACCORDING TO HIGHEST POPULATED STATE
        NQNLST(IOCC) = NPR(KCNT,KKAP,KMV)
        ICNLST(IOCC) = KCNT
        KQNLST(IOCC) = KKQN
        POPLST(IOCC) = FRAC(IOCC,KCNT,KKAP,KMV)
        IF(MOD(KMV,2).EQ.1) THEN
          MQNLST(IOCC) =-KMV
        ELSE
          MQNLST(IOCC) = KMV-1
        ENDIF
C
C     END LOOP OVER ORBITALS
      ENDDO
C
C     SORTING: ORGANISE POSITIVE-ENERGY SOLUTIONS IN MQN PAIRS
C
      IF(NCNT.EQ.1) THEN
C
C       LOOP OVER ALL STATES
        DO IOCC=1,NDIM-NSKP
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MOCC = IOCC+NSKP
C
C         IDENTIFY KQN OF STATE
          IKQN = KQNLST(IOCC)
C
C         FOR THIS KQN VALUE, SEARCH NEXT 2*|KQN| ENTRIES AND ORDER
C
        ENDDO
C
      ELSEIF(NCNT.GT.1) THEN
C
C       LOOP OVER PAIRS OF STATES
        DO IPAIR=1,NDIM-NSKP,2
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MPAIR = IPAIR+NSKP
C
C         NO NEED TO SWAP IF MQN OF THE FIRST STATE IS NEGATIVE
          IF(MQNLST(IPAIR).LT.0) GOTO 100
C
C         SWAP EIGENVALUES, EXPANSION COEFFICIENTS AND MQN VALUES
          ETEMP         = EIGN(MPAIR+1)
          EIGN(MPAIR+1) = EIGN(MPAIR  )
          EIGN(MPAIR  ) = ETEMP
C
          DO I=1,NDIM
            CTEMP           = COEF(I,MPAIR+1)
            COEF(I,MPAIR+1) = COEF(I,MPAIR  )
            COEF(I,MPAIR  ) = CTEMP
          ENDDO
C
          MTEMP           = MQNLST(IPAIR+1)
          MQNLST(IPAIR+1) = MQNLST(IPAIR  )
          MQNLST(IPAIR  ) = MTEMP
C
          PTEMP           = POPLST(IPAIR+1)
          POPLST(IPAIR+1) = POPLST(IPAIR  )
          POPLST(IPAIR  ) = PTEMP
C
C         SKIP POINT FOR ALREADY-SORTED PAIRS
100       CONTINUE
C
        ENDDO
C
      ENDIF
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Orb.',2X,'Centre',4X,'Term sym.',3X,'m_j',14X,
     &                                    'Energy (au)',6X,'Population')
21    FORMAT(1X,I3,2X,I2,' (',A,')',4X,I2,A,'_',I1,'/2',4X,I2,'/2',3X,
     &                                                  F22.12,6X,F10.8)
C
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     SUMMARISE RESULTS
      DO IOCC=1,IBND+IVIR
C
        MOCC = IOCC+NSKP
C
        ICNT = ICNLST(IOCC)
        INQN = NQNLST(IOCC)
        IKQN = KQNLST(IOCC)
        IMQN = MQNLST(IOCC)
        ELA  = ELMT(INT(ZNUC(ICNT)))
        IF(IKQN.LT.0) THEN
          ILQN =-IKQN-1
        ELSE
          ILQN = IKQN
        ENDIF
        CHL  = LLAB(ILQN)
        IJQN = 2*IABS(IKQN)-1

        IF(IOCC.LE.IBND) THEN
          PLTN = POPLST(IOCC)
        ELSE
          PLTN = 0.0D0
        ENDIF
C
        IF(HMLT.EQ.'NORL') THEN
          PLTN = 0.5D0*PLTN
        ENDIF
C
C       OUTPUT TO TERMINAL
        WRITE(6,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        WRITE(7,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        IF(IOCC.EQ.IBND.AND.IVIR.NE.0) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
C
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ROTATE(XYZ,NCNT,ALPHA,BETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          RRRRRRR   OOOOOO TTTTTTTT   AA   TTTTTTTT EEEEEEEE          C
C          RR    RR OO    OO   TT     AAAA     TT    EE                C
C          RR    RR OO    OO   TT    AA  AA    TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EEEEEE            C
C          RRRRRRR  OO    OO   TT   AAAAAAAA   TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EE                C
C          RR    RR  OOOOOO    TT   AA    AA   TT    EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ROTATE PERFORMS TWO ROTATIONS ON ALL ATOMIC CENTRES, FIRST SO THAT  C
C  Y DOES NOT CHANGE, AND THEN SO THAT Z DOES NOT CHANGE.              C
C**********************************************************************C
C
      DIMENSION XYZ(3,NCNT),V(3),W(3)
      DIMENSION AR(3,3),BR(3,3),RR(3,3)
C
C     INITIALISE MATRICES
      DO I=1,3
        DO J=1,3
          AR(I,J) = 0.0D0
          BR(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     FIX ALL VALUES OF Z AND ROTATE BY ALPHA
      AR(3,3) = 1.0D0
      AR(1,1) = DCOS(ALPHA)
      AR(2,2) = DCOS(ALPHA)
      AR(1,2) = DSIN(ALPHA)
      AR(2,1) =-DSIN(ALPHA)
C
C     FIX ALL VALUES OF Y AND ROTATE BY BETA
      BR(2,2) = 1.0D0
      BR(1,1) = DCOS(BETA)
      BR(3,3) = DCOS(BETA)
      BR(3,1) = DSIN(BETA)
      BR(1,3) =-DSIN(BETA)
C
C     EVALUATE OVERALL ROTATION MATRIX
      CALL MMPROD(BR,AR,RR,3)
C
C     ROTATE ALL VECTORS IN XYZ
      DO N=1,NCNT
        DO I=1,3
          V(I) = XYZ(I,N)
        ENDDO
        CALL MVPROD(RR,V,W,3)
        DO I=1,3
          XYZ(I,N) = W(I)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MMPROD(A,B,X,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM MM       MM PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD       C
C     MMM     MMM MMM     MMM PP    PP RR    RR OO    OO DD    DD      C
C     MMMM   MMMM MMMM   MMMM PP    PP RR    RR OO    OO DD    DD      C
C     MM MM MM MM MM MM MM MM PP    PP RR    RR OO    OO DD    DD      C
C     MM  MMM  MM MM  MMM  MM PPPPPPP  RRRRRRR  OO    OO DD    DD      C
C     MM   M   MM MM   M   MM PP       RR    RR OO    OO DD    DD      C
C     MM       MM MM       MM PP       RR    RR  OOOOOO  DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  MMPROD CALCULATES THE PRODUCT OF TWO SQUARE, DOUBLE-PRECISION       C
C  MATRIX ARRAYS OF DIMENSION N, AND OUTPUTS THE RESULT INTO X.        C
C**********************************************************************C
C
      DIMENSION A(N,N),B(N,N),X(N,N)
C
C     INITIALISE X MATRIX
      DO I=1,N
        DO J=1,N
          X(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          DO K=1,N
            X(I,J) = X(I,J) + A(I,K)*B(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MVPROD(A,V,W,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       MM       MM VV    VV PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD        C
C       MMM     MMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MMMM   MMMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM MM MM MM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM  MMM  MM  VV  VV  PPPPPPP  RRRRRRR  OO    OO DD    DD       C
C       MM   M   MM   VVVV   PP       RR    RR OO    OO DD    DD       C
C       MM       MM    VV    PP       RR    RR  OOOOOO  DDDDDDD        C
C                                                                      C
C -------------------------------------------------------------------- C
C  MVPROD CALCULATES THE PRODUCT OF A SQUARE MATRIX OF DIMENSION N     C
C  AND A VECTOR OF DIMENSION N, AND OUTPUTS THE RESULT INTO W.         C
C**********************************************************************C
C
      DIMENSION A(N,N),V(N),W(N)
C
C     INITIALISE W MATRIX
      DO I=1,N
        W(I) = 0.0D0
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          W(I) = W(I) + A(I,J)*V(J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION MS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          MM       MM  SSSSSS                         C
C                          MMM     MMM SS    SS                        C
C                          MMMM   MMMM SS                              C
C                          MM MM MM MM  SSSSSS                         C
C                          MM  MMM  MM       SS                        C
C                          MM   M   MM SS    SS                        C
C                          MM       MM  SSSSSS                         C
C                                                                      C
C -------------------------------------------------------------------- C
C   MS RETURNS A QUOTED TIME IN SECONDS USING 'MIN-SEC' FORMAT.        C
C**********************************************************************C
      CHARACTER*4 MINUTES
      CHARACTER*7 SECONDS
      CHARACTER*11 MS
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      NMIN = 0
      DO WHILE (TSEC.GE.60.0D0)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PRINT THE MINUTE
      IF(NMIN.EQ.0) THEN
        WRITE(MINUTES,'(A)') '    '
      ELSE
        WRITE(MINUTES,'(I3,A)') NMIN,'m'
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F4.2,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F4.2,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(MS,'(A,A)') MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      FUNCTION HMS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                     HH    HH MM       MM  SSSSSS                     C
C                     HH    HH MMM     MMM SS    SS                    C
C                     HH    HH MMMM   MMMM SS                          C
C                     HHHHHHHH MM MM MM MM  SSSSSS                     C
C                     HH    HH MM  MMM  MM       SS                    C
C                     HH    HH MM   M   MM SS    SS                    C
C                     HH    HH MM       MM  SSSSSS                     C
C                                                                      C
C -------------------------------------------------------------------- C
C   HMS RETURNS A QUOTED TIME IN SECONDS USING 'HR-MIN-SEC' FORMAT.    C
C**********************************************************************C
      CHARACTER*4 HOURS,MINUTES
      CHARACTER*8 SECONDS
      CHARACTER*16 HMS
C
C     INITIALISE COUNTERS
      NMIN = 0
      NHRS = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0 <= NMIN < 60
      DO WHILE (NMIN.GE.60)
        NMIN = NMIN - 60
        NHRS = NHRS + 1
      ENDDO
C
C     PRINT THE HOUR
      IF(NHRS.EQ.0) THEN
        WRITE(HOURS,'(A)') '    '
      ELSE
        WRITE(HOURS,'(I3,A)') NHRS,'h'
      ENDIF
C
C     PRINT THE MINUTE
      IF(NHRS.EQ.0) THEN
        IF(NMIN.EQ.0) THEN
          WRITE(MINUTES,'(1X,A)') '   '
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ELSEIF(NHRS.NE.0) THEN
        IF(NMIN.LT.10) THEN
          WRITE(MINUTES,'(1X,I1,I1,A)') 0,NMIN,'m'
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F5.3,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F5.3,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(HMS,'(A,A,A)') HOURS//MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      SUBROUTINE TIMENOW(STAMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  TTTTTTTT IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW        WW   C
C     TT     II  MMM     MMM EE       NNN   NN OO    OO WW        WW   C
C     TT     II  MMMM   MMMM EE       NNNN  NN OO    OO WW   WW   WW   C
C     TT     II  MM MM MM MM EEEEEE   NN NN NN OO    OO WW  WWWW  WW   C
C     TT     II  MM  MMM  MM EE       NN  NNNN OO    OO WW WW  WW WW   C
C     TT     II  MM   M   MM EE       NN   NNN OO    OO WWWW    WWWW   C
C     TT    IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW        WW   C
C                                                                      C
C -------------------------------------------------------------------- C
C  TIMENOW CREATES A DATE STRING SPECIFYING CPU TIME WHEN CALLED.      C
C**********************************************************************C
      CHARACTER*5  ZONE
      CHARACTER*8  DATE
      CHARACTER*10 TIME
      CHARACTER*20 STAMP
C
      DIMENSION IVL(8)
C
C     CALL TIME AND DATE ROUTINE
      CALL DATE_AND_TIME(DATE,TIME,ZONE,IVL)
C
C     PRINT THE DAY
      IF(IVL(3).LT.10) THEN
        WRITE(STAMP,'(1X,I1,I1,A)') 0,IVL(3),'/'
      ELSE
        WRITE(STAMP,'(1X,I2,A)') IVL(3),'/'
      ENDIF
C
C     PRINT THE MONTH
      IF(IVL(2).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(2),'/'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(2),'/'
      ENDIF
C
C     PRINT THE YEAR
      WRITE(STAMP,'(A,I4)') TRIM(STAMP),IVL(1)
C
C     PRINT THE HOUR
      IF(IVL(5).LT.10) THEN
        WRITE(STAMP,'(A,A,I1,I1,A)') TRIM(STAMP),' ',0,IVL(5),':'
      ELSE
        WRITE(STAMP,'(A,A,I2,A)') TRIM(STAMP),' ',IVL(5),':'
      ENDIF
C
C     PRINT THE MINUTE
      IF(IVL(6).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(6),':'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(6),':'
      ENDIF
C
C     PRINT THE SECOND
      IF(IVL(7).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1)') TRIM(STAMP),0,IVL(7)
      ELSE
        WRITE(STAMP,'(A,I2)') TRIM(STAMP),IVL(7)
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [B] DENSTY: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.    C
C   [C] LEVSHFT: APPLIES A LEVEL SHIFT TO OCCUPIED ORBITALS IN FOCK.   C
C   [D] ENERGIES: USE DENSITY MATRIX TO CALCULATE ENERGY TERMS.        C
C   [E] DIIS: DIRECT INVERSION OF THE ITERATIVE SUBSPACE (CONVERGENCE).C
C**********************************************************************C
C
C
      SUBROUTINE EIGSORT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       EEEEEEEE IIII GGGGGG   SSSSSS   OOOOOO  RRRRRRR TTTTTTTT       C
C       EE        II GG    GG SS    SS OO    OO RR    RR   TT          C
C       EE        II GG       SS       OO    OO RR    RR   TT          C
C       EEEEEE    II GG        SSSSSS  OO    OO RR    RR   TT          C
C       EE        II GG   GGG       SS OO    OO RRRRRRR    TT          C
C       EE        II GG    GG SS    SS OO    OO RR    RR   TT          C
C       EEEEEEEE IIII GGGGGG   SSSSSS   OOOOOO  RR    RR   TT          C
C                                                                      C
C -------------------------------------------------------------------- C
C  EIGSORT RE-ORGANISES THE ENERGY EIGENVALUES AND COEFFCIENT ARRAY    C
C  IN PREPARATION FOR MOLECULAR CALCULATIONS (IOCC: 1->NOCC).          C
C  CONTEXT: ONLY ACTUALLY NEED THIS WHEN DEALING WITH SELF-ENERGY.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 CTMP(MDM)
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
C
C     LOOP OVER OCCUPIED LEVELS AS INDICATED IN IOCPN
      DO IOCC=1,IOCCM0
        IOCAD = IOCPN(IOCC)
C
C       SKIP IF IOCC AND IOCAD ARE THE SAME
        IF(IOCC.EQ.IOCAD) GOTO 101
C
C       EXECUTE A SWAP
        ETMP = EIGN(IOCAD+NSKP)
        DO I=1,NDIM
          CTMP(I) = COEF(I,IOCAD+NSKP)
        ENDDO
C
        EIGN(IOCAD+NSKP) = EIGN(IOCC+NSKP)
        DO I=1,NDIM
          COEF(I,IOCAD+NSKP) = COEF(I,IOCC+NSKP)
        ENDDO
        
        EIGN(IOCC+NSKP) = ETMP
        DO I=1,NDIM
          COEF(I,IOCC+NSKP) = CTMP(I)
        ENDDO
C
101     CONTINUE
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DENSTY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY         C
C         DD    DD EE       NNN   NN SS    SS   TT    YY    YY         C
C         DD    DD EE       NNNN  NN SS         TT     YY  YY          C
C         DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY           C
C         DD    DD EE       NN  NNNN       SS   TT       YY            C
C         DD    DD EE       NN   NNN SS    SS   TT       YY            C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY GENERATES DENSITY MATRICES FROM THE EXPANSION COEFFS COEF.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
c
      COMPLEX*16 SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     MAKE CLOSED-SHELL DENSITY AND EMPTY OPEN-SHELL DENSITY (RSCF 81)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NCLS
            ICL = ICLS(IOCC)
            SUM = SUM +      DCONJG(COEF(I,ICL+NSKP))*COEF(J,ICL+NSKP)
          ENDDO
          DENC(I,J) = SUM
          DENT(I,J) = DENC(I,J)
          DENO(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      IF(NOPN.EQ.0) GOTO 100
C
C     MAKE THE OPEN-SHELL DENSITY (RSCF 82)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NOPN
            IOP = IOPN(IOCC)
            SUM = SUM + FOPN*DCONJG(COEF(I,IOP+NSKP))*COEF(J,IOP+NSKP)
          ENDDO
          DENO(I,J) = SUM
          DENT(I,J) = DENT(I,J)+DENO(I,J)
        ENDDO
      ENDDO
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE LEVSHFT(SHLV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   LL       EEEEEEEE VV      VV  SSSSSS  HH    HH FFFFFFFF TTTTTTTT   C
C   LL       EE       VV      VV SS    SS HH    HH FF          TT      C
C   LL       EE       VV      VV SS       HH    HH FF          TT      C
C   LL       EEEEEE    VV    VV   SSSSSS  HHHHHHHH FFFFFF      TT      C
C   LL       EE         VV  VV         SS HH    HH FF          TT      C
C   LL       EE          VVVV    SS    SS HH    HH FF          TT      C
C   LLLLLLLL EEEEEEEE     VV      SSSSSS  HH    HH FF          TT      C
C                                                                      C
C -------------------------------------------------------------------- C
C  LEVSHFT APPLIES A LEVEL SHIFT OF SHLV TO UNOCCUPIED ORBITALS IN THE C
C  FOCK MATRIX.                                                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 A(MDM),SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
C
C     LOOP OVER ALL NON-OCCUPIED POSITIVE-ENERGY (I.E., VIRTUAL) OCCS
      DO IVIR=NSKP+NOCC+1,NDIM
C
C       LIST OF FOCK ADDRESSES WITH 'I' WITH AN AMOUNT FROM EACH IVIR
        DO I=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO J=1,NDIM
            SUM = SUM + OVLP(I,J)*COEF(J,IVIR)
          ENDDO
          A(I) = SUM
        ENDDO
C
C       ADD A LEVEL SHIFT'S WORTH OF INTERACTION ENERGY TO ALL FOCK(I,J)
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = FOCK(I,J) + SHLV*A(I)*DCONJG(A(J))
          ENDDO
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ENRGIES
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE NN    NN EEEEEEEE RRRRRRR   GGGGGG IIII EEEEEEEE SSSSSS   C
C   EE       NNN   NN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EE       NNNN  NN EE       RR    RR GG       II  EE      SS        C
C   EEEEEE   NN NN NN EEEEEE   RR    RR GG       II  EEEEEE   SSSSSS   C
C   EE       NN  NNNN EE       RRRRRRR  GG   GGG II  EE            SS  C
C   EE       NN   NNN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EEEEEEEE NN    NN EEEEEEEE RR    RR  GGGGGG IIII EEEEEEEE SSSSSS   C
C                                                                      C
C -------------------------------------------------------------------- C
C  ENRGIES CALCULATES INTERACTION ENERGIES OF THE CURRENT DENSITY      C
C  MATRIX OVER OCCUPIED SPINORS WITH THE MATRIX REP OF OPERATORS.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 ETMP(16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EANM,ESLF,EUEH,
     &            EWKR,EKSB
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INITIALISE MOLECULAR ENERGY COUNTERS
      DO N=1,16
        ETMP(N) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C**********************************************************************C
C     BARE HAMILTONIAN                                                 C
C**********************************************************************C
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP( 1) = ETMP( 1) +       DENT(I,J)*HKIN(I,J)
          ETMP( 2) = ETMP( 2) +       DENT(I,J)*HNUC(I,J)
          ETMP(16) = ETMP(16) +       DENT(I,J)*FOCK(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EHKN = DREAL(ETMP( 1))
      EHNC = DREAL(ETMP( 2))
      EDHF = DREAL(ETMP(16))
C
C     CONTRIBUTIONS TO TOTAL ENERGY COUNTERS
      EONE = EHKN+EHNC
      ETOT = ENUC+EONE
C
      IF(HMLT.EQ.'BARE') RETURN
C
C**********************************************************************C
C     NORL AND DHFR HAMILTONIANS                                       C
C**********************************************************************C
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP( 8) = ETMP( 8) + 0.5D0*DENT(I,J)*GDIR(I,J)
          ETMP( 9) = ETMP( 9) + 0.5D0*DENT(I,J)*GXCH(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EGDR = DREAL(ETMP( 8))
      EGXC = DREAL(ETMP( 9))
C
C     CONTRIBUTIONS TO TOTAL ENERGY COUNTERS
      ECLG = EGDR-EGXC
      ETOT = ETOT+ECLG
C
C     OPEN-SHELL SYSTEMS
      IF(NOPN.EQ.0) GOTO 200
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP(12) = ETMP(12) + 0.5D0*DENT(I,J)*QDIR(I,J)
     &                        + 0.5D0*DENO(I,J)*QDIR(I,J)*(FOPN-1.0D0)
          ETMP(13) = ETMP(13) + 0.5D0*DENT(I,J)*QXCH(I,J)
     &                        + 0.5D0*DENO(I,J)*QXCH(I,J)*(FOPN-1.0D0)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EQDR = DREAL(ETMP(12))
      EQXC = DREAL(ETMP(13))
C
C     CONTRIBUTIONS TO TOTAL ENERGY COUNTERS
      ECLQ = EQDR-EQXC
      ETOT = ETOT+ECLQ
C
200   CONTINUE
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') RETURN
C
C**********************************************************************C
C     DHFB HAMILTONIAN                                                 C
C**********************************************************************C
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP(10) = ETMP(10) + 0.5D0*DENT(I,J)*BDIR(I,J)
          ETMP(11) = ETMP(11) + 0.5D0*DENT(I,J)*BXCH(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EBDR = DREAL(ETMP(10))
      EBXC = DREAL(ETMP(11))
C
C     CONTRIBUTIONS TO TOTAL ENERGY COUNTERS
      EBRG = EBDR-EBXC
      ETOT = ETOT+EBRG
C
C     OPEN-SHELL SYSTEMS
      IF(NOPN.EQ.0) GOTO 300
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP(14) = ETMP(14) + 0.5D0*DENT(I,J)*WDIR(I,J)
     &                        + 0.5D0*DENO(I,J)*WDIR(I,J)*(FOPN-1.0D0)
          ETMP(15) = ETMP(15) + 0.5D0*DENT(I,J)*WXCH(I,J)
     &                        + 0.5D0*DENO(I,J)*WXCH(I,J)*(FOPN-1.0D0)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EWDR = DREAL(ETMP(14))
      EWXC = DREAL(ETMP(15))
C
C     CONTRIBUTIONS TO TOTAL ENERGY COUNTERS
      EBRQ = EWDR-EWXC
      ETOT = ETOT+EBRQ
C
300   CONTINUE
      IF(HMLT.EQ.'DHFB') RETURN
C
C**********************************************************************C
C     NORL AND DHFR HAMILTONIANS                                       C
C**********************************************************************C
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP( 3) = ETMP( 3) + DENT(I,J)*VANM(I,J)
          ETMP( 4) = ETMP( 4) + DENT(I,J)*VSLF(I,J)
          ETMP( 5) = ETMP( 5) + DENT(I,J)*VUEH(I,J)
          ETMP( 6) = ETMP( 6) + DENT(I,J)*VWKR(I,J)
          ETMP( 7) = ETMP( 7) + DENT(I,J)*VKSB(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EANM = DREAL(ETMP( 3))
      ESLF = DREAL(ETMP( 4))
      EUEH = DREAL(ETMP( 5))
      EWKR = DREAL(ETMP( 6))
      EKSB = DREAL(ETMP( 7))
C
C     CONTRIBUTIONS TO TOTAL ENERGY COUNTERS
      EONE = EONE+EANM+ESLF+EUEH+EWKR+EKSB
C     ETOT = 0.5D0*EONE+0.5D0*EDHF-ECLQ-EBRQ
      ETOT = ETOT+EANM+ESLF+EUEH+EWKR+EKSB
C
      RETURN
      END
C
C
      SUBROUTINE DIIS(NMLEV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      DDDDDDD IIII IIII SSSSSS                        C
C                      DD    DD II   II SS    SS                       C
C                      DD    DD II   II SS                             C
C                      DD    DD II   II  SSSSSS                        C
C                      DD    DD II   II       SS                       C
C                      DD    DD II   II SS    SS                       C
C                      DDDDDDD IIII IIII SSSSSS                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  DIIS EMPLOYS THE (COMMUTATOR OR ENERGY) DIRECT INVERSION OF THE     C
C  ITERATIVE SUBSPACE ALGORITHM OF GARZA AND SCUSERIA (2012).          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL ILLUSTRATE
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      CHARACTER*80 TITLE
C
      COMPLEX*16 ZGEMMIP,Y,Z
      COMPLEX*16 WKC(LWK)
      COMPLEX*16 AMAT(MDM,MDM),BTMP(MDM,MDM),ETMP(MDM,MDM)
      COMPLEX*16 EVEC(MDM,MDM),ELHS(MDM,MDM),ERHS(MDM,MDM)
      COMPLEX*16 EHFT(MSV)
      COMPLEX*16 DCNJ(MDM,MDM)
      COMPLEX*16 ERRM(MDM,MDM,MSV),FCKM(MDM,MDM,MSV),DENM(MDM,MDM,MSV)
      COMPLEX*16 BMAT(MSV,MSV),EMAT(MSV,MSV),DMAT(1,MSV),RK(3*MSV)
      COMPLEX*16 BSAV(MSV,MSV),ESAV(MSV,MSV)
      COMPLEX*16 CENG(MSV),CCOM(MSV),CMAS(MSV),ZVEC(MSV),YVEC(1)
      COMPLEX*16 BMI,BMN,CCOMTOT,CENGTOT,CMASTOT
C
      SAVE ERRM,FCKM,DENM,AMAT,BSAV,ESAV,EHFT
C
      COMMON/QCNV/BMAT,DMAT,CCOM,ZVEC,YVEC
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EANM,ESLF,EUEH,
     &            EWKR,EKSB
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
C
C     DECISION PARAMETERS FOR DIIS ALGORITHM
      ERRCOM = 1.0D-1
      ERRENG = 1.0D-1
C
      ILLUSTRATE = .FALSE.
C
C**********************************************************************C
C     PREPARE ORTHOGONAL BASIS TRANSFORMATION                          C
C**********************************************************************C
C
      IF(NMLEV.EQ.1) THEN
C
C       INITIALISE INNER PRODUCT ARRAY
        DO M=1,MSV
          DO N=1,MSV
            BSAV(M,N) = DCMPLX(0.0D0,0.0D0)
            ESAV(M,N) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
C
C       RAISE OVERLAP MATRIX TO POWER -1/2
C       CALL ZGEMPW(OVLP,AMAT,-0.5D0,MDM,NDIM)
C
      ENDIF
C
C**********************************************************************C
C     CONSTRUCT ERROR VECTOR AND FIND ITS SUPNORM.                     C
C**********************************************************************C
C
C     ERROR VECTOR IN PULAY (1982) EQ. 4
C
C     COMPUTE ELHS = F.D*.S
      Y = DCMPLX(1.0D0,0.0D0)
      Z = DCMPLX(0.0D0,0.0D0)
C
C     COMPLEX-CONJUGATE THE DENSITY MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          DCNJ(I,J) = DCONJG(DENT(I,J))
        ENDDO
      ENDDO
C
C     COMPUTE ELHS = F.D*.S
      CALL ZGEMM('N','N',NDIM,NDIM,NDIM,Y,FOCK,MDM,DCNJ,MDM,Z,ETMP,MDM)
      CALL ZGEMM('N','N',NDIM,NDIM,NDIM,Y,ETMP,MDM,OVLP,MDM,Z,ELHS,MDM)
C
C     COMPUTE ERHS = S.D*.F
      CALL ZGEMM('N','N',NDIM,NDIM,NDIM,Y,OVLP,MDM,DCNJ,MDM,Z,ETMP,MDM)
      CALL ZGEMM('N','N',NDIM,NDIM,NDIM,Y,ETMP,MDM,FOCK,MDM,Z,ERHS,MDM)
C
C     CONSTRUCT EVEC = F.D*.S - S.D*.F
      DO I=1,NDIM
        DO J=1,NDIM
          EVEC(I,J) = ELHS(I,J)-ERHS(I,J)
        ENDDO
      ENDDO
C
C     TRANSFORM TO ORTHONORMAL EVEC' IN PULAY (1982) BELOW EQ. 4
C     CALL ZGEMM('N','N',NDIM,NDIM,NDIM,A,AMAT,MDM,EVEC,MDM,B,EVEC,MDM)
C     CALL ZGEMM('N','N',NDIM,NDIM,NDIM,A,EVEC,MDM,AMAT,MDM,B,EVEC,MDM)
C
C     FIND LARGEST ABSOLUTE MATRIX ELEMENT IN ERROR ARRAY
      ERRMAX = 0.0D0
      DO I=1,NDIM
        DO J=1,NDIM
          IF(ABS(EVEC(I,J)).GT.ERRMAX) ERRMAX = ABS(EVEC(I,J))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PREPARE DATA AND ARRAYS FOR DIIS ALGORITHMS                      C
C**********************************************************************C
C
C     INITIALISE LINEAR COMBINATION VECTORS
      DO M=1,MSV
        CENG(M) = DCMPLX(0.0D0,0.0D0)
        CCOM(M) = DCMPLX(0.0D0,0.0D0)
        CMAS(M) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     ARRAY LOCATION
      KLC = MOD(NMLEV,MSV)
      IF(KLC.EQ.0) KLC = MSV
C
C     DIMENSION OF THIS SOLUTION SPACE
      KSS = MIN(NMLEV,MSV)
C
C     STORE HARTREE-FOCK ENERGY
      EHFT(KLC) = ETOT
C
C     STORE ERROR MATRIX AND CURRENT FOCK MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          ERRM(I,J,KLC) = EVEC(I,J)
          DENM(I,J,KLC) = DENT(I,J)
          FCKM(I,J,KLC) = FOCK(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     THE COMMUTATOR-DIIS ALGORITHM                                    C
C**********************************************************************C
C
C     ADD A NEW COLUMN AND ROW TO BSAV
      DO M=1,KSS
C
C       TRANSFER RELEVANT ERROR METRICS TO TEMPORARY ARRAYS
        DO I=1,NDIM
          DO J=1,NDIM
            ELHS(I,J) = ERRM(I,J,M)
          ENDDO
        ENDDO
C
C       FROBENIUS INNER PRODUCTS BETWEEN ERROR MATRICES
        BSAV(M,KLC) = ZGEMMIP(ELHS,EVEC,MDM,NDIM,'F')
        BSAV(KLC,M) = DCONJG(BSAV(M,KLC))
C
      ENDDO
C
C     TRANSFER INTO A WORK MATRIX (TO BE REPLACED WITH ERROR SIGNALS)
      DO M=1,KSS
        DO N=1,KSS
          BMAT(M,N) = BSAV(M,N)
        ENDDO
      ENDDO
C
C     ALGORITHM WILL ONLY BE APPROPRIATE FOR SMALL DIIS ERROR
      IF(ERRMAX.GT.ERRCOM) GOTO 60
C
C     ZERO-VECTOR FOR LEAST-SQUARES MINIMISATION ROUTINE
      DO M=1,KSS
        ZVEC(M) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     C-VECTOR SUM CONSTRAINT
      DO M=1,KSS
        DMAT(1,M) = DCMPLX(1.0D0,0.0D0)
      ENDDO
      YVEC(1) = DCMPLX(1.0D0,0.0D0)
C
C     SOLVE THIS SET OF LINEAR EQUATIONS WITH CONSTRAINTS
      CALL ZGGLSE(KSS,KSS,1,BMAT,MSV,DMAT,1,ZVEC,YVEC,CCOM,WKC,LWK,INF)
      IF(INF.NE.0) THEN
        WRITE(6, *) 'In DIIS: linear equation solver ZGGLSE failed.',INF
        WRITE(7, *) 'In DIIS: linear equation solver ZGGLSE failed.',INF
      ENDIF
C
C     FOR SOMEWHAT LARGE DIIS ERROR, PREPARE A MIXTURE
c      IF(ERRMAX.GT.ERRENG) THEN
c        DO M=1,KSS
c          CCOM(M) = (1.0D0-10.0D0*ERRMAX)*CCOM(M)
c        ENDDO
c      ENDIF
C
C     TRANSFER INTO THE MASTER LIST
      DO M=1,KSS
        CMAS(M) = CMAS(M) + CCOM(M)
      ENDDO
C
C**********************************************************************C
C     FOLLOW THE ENERGY-DIIS ALGORITHM                                 C
C**********************************************************************C
C
C     ALGORITHM IS APPROPRIATE FOR LARGE DIIS ERROR
      IF(ERRMAX.LT.ERRENG) GOTO 20
      goto 20
C
C     ADD A NEW COLUMN AND ROW TO ESAV
      DO M=1,KSS
C
        IF(M.EQ.KSS) THEN
C
           ESAV(M,KSS) = DCMPLX(0.0D0,0.0D0)
C
        ELSE
C
C         TRANSFER RELEVANT ERROR METRICS TO TEMPORARY ARRAYS
          DO I=1,NDIM
            DO J=1,NDIM
              ELHS(I,J) = FCKM(I,J,M)-FOCK(I,J)
              ERHS(I,J) = DENM(I,J,M)-DENT(I,J)
            ENDDO
          ENDDO
C
C         FROBENIUS INNER PRODUCTS BETWEEN ERROR MATRICES
          ESAV(M,KLC) = 0.5D0*ZGEMMIP(ELHS,ERHS,MDM,NDIM,'F')
          ESAV(KLC,M) = DCONJG(ESAV(M,KLC))
C
        ENDIF
C
      ENDDO
C
C     TRANSFER INTO A WORK MATRIX (TO BE REPLACED WITH ERROR SIGNALS)
      DO M=1,KSS
        DO N=1,KSS
          EMAT(M,N) = ESAV(M,N)
        ENDDO
      ENDDO
C
C     ZERO-VECTOR FOR LEAST-SQUARES MINIMISATION ROUTINE
      DO M=1,KSS
        ZVEC(M) = EHFT(M)
      ENDDO
C
C     C-VECTOR SUM CONSTRAINT
      DO M=1,KSS
        DMAT(1,M) = DCMPLX(1.0D0,0.0D0)
      ENDDO
      YVEC(1) = DCMPLX(1.0D0,0.0D0)
C
C     SOLVE THIS SET OF LINEAR EQUATIONS WITH CONSTRAINTS
      CALL ZGGLSE(KSS,KSS,1,EMAT,MSV,DMAT,1,ZVEC,YVEC,CENG,WKC,LWK,INF)
      IF(INF.NE.0) THEN
        WRITE(6, *) 'In DIIS: linear equation solver ZGGLSE failed.',INF
        WRITE(7, *) 'In DIIS: linear equation solver ZGGLSE failed.',INF
      ENDIF
C
C     FOR SOMEWHAT LARGE DIIS ERROR, PREPARE A MIXTURE
C      IF(ERRMAX.LT.ERRCOM) THEN
C        DO M=1,KSS
C          CENG(M) = 10.0D0*ERRMAX*CENG(M)
C        ENDDO
C      ENDIF
C
C     TRANSFER INTO THE MASTER LIST
      DO M=1,KSS
        CMAS(M) = CMAS(M) + CENG(M)
      ENDDO
C
20    CONTINUE
C
C**********************************************************************C
C     CONSTRUCT A NEW FOCK MATRIX                                      C
C**********************************************************************C
C
C     HAVE THIS UNTIL EDIIS
      IF(ERRMAX.GT.ERRCOM) CMAS(KSS) = DCMPLX(1.0D0,0.0D0)
C
C     ILLUSTRATE B MATRIX IF PROMPTED
      IF(ILLUSTRATE) THEN
        DO M=1,KSS
          DO N=1,KSS
            BTMP(M,N) = BSAV(M,N)
          ENDDO
        ENDDO
        TITLE = 'CDIIS-MATRIX'
        CALL ZGNUMAP(BTMP,TITLE,KSS)
      ENDIF
C
C     SKIP IF THE SOLUTION IS TRIVIAL
      IF(KSS.LE.2) GOTO 60
C
C     PRINT THE SUM OF BEST-FIT PARAMETERS
2     FORMAT(' ERRMAX = 'F16.12)
3     FORMAT(I2,3(2X,F9.4))
      WRITE(6, *) 'DIIS Fock combination'
      WRITE(7, *) 'DIIS Fock combination'
      WRITE(6, *) '**********************************'
      WRITE(7, *) '**********************************'
      WRITE(6, 2) ERRMAX
      WRITE(7, 2) ERRMAX
      WRITE(6, *) '**********************************'
      WRITE(7, *) '**********************************'
      CCOMTOT = DCMPLX(0.0D0,0.0D0)
      CENGTOT = DCMPLX(0.0D0,0.0D0)
      CMASTOT = DCMPLX(0.0D0,0.0D0)
      DO M=1,KSS
        CCOMTOT = CCOMTOT + CCOM(M)
        CENGTOT = CENGTOT + CENG(M)
        CMASTOT = CMASTOT + CMAS(M)
        WRITE(6, 3) M,DREAL(CCOM(M)),DREAL(CENG(M)),DREAL(CMAS(M))
        WRITE(7, 3) M,DREAL(CCOM(M)),DREAL(CENG(M)),DREAL(CMAS(M))
      ENDDO
      WRITE(6, *) '**********************************'
      WRITE(7, *) '**********************************'
      WRITE(6, 3) KLC,DREAL(CCOMTOT),DREAL(CENGTOT),DREAL(CMASTOT)
      WRITE(7, 3) KLC,DREAL(CCOMTOT),DREAL(CENGTOT),DREAL(CMASTOT)
      WRITE(6, *) '**********************************'
      WRITE(7, *) '**********************************'
      WRITE(6, *) ''
      WRITE(7, *) ''
C
C     CONSTRUCT A MORE CONVERGENT FOCK MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          FOCK(I,J) = DCMPLX(0.0D0,0.0D0)
          DO M=1,KSS
            FOCK(I,J) = FOCK(I,J) + CMAS(M)*FCKM(I,J,M)
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT WHEN FOCK MATRIX IS NOT TO BE TRIFLED WITH
60    CONTINUE
C
      RETURN
      END
C
C
      FUNCTION ZGEMMIP(AMAT,BMAT,NLG,NSM,MET)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   ZZZZZZZZ GGGGGG  EEEEEEEE MM       MM MM       MM IIII PPPPPPP     C
C        ZZ GG    GG EE       MMM     MMM MMM     MMM  II  PP    PP    C
C       ZZ  GG       EE       MMMM   MMMM MMMM   MMMM  II  PP    PP    C
C      ZZ   GG       EEEEEE   MM MM MM MM MM MM MM MM  II  PP    PP    C
C     ZZ    GG   GGG EE       MM  MMM  MM MM  MMM  MM  II  PPPPPPP     C
C    ZZ     GG    GG EE       MM   M   MM MM   M   MM  II  PP          C
C   ZZZZZZZZ GGGGGG  EEEEEEEE MM       MM MM       MM IIII PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZGEMMIP CALCULATES THE INNER PRODUCT OF TWO MATRICES UNDER A NUMBER C
C  OF METRICS, ASSUMING THE MATRICES ARE OF TYPE COMPLEX*16.           C
C  UNDERLYING MATRICES ARE SQUARE AND OF EQUAL DIMENSION NLG.          C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    NLG = DIMENSION OF MATRIX                                         C
C    NSM = LAST RELEVANT ENTRY IN MATRIX                               C
C    MET = 'F' - FROBENIUS NORM        Tr(AMAT^H.BMAT)                 C
C          'M' - MAX ABSOLUTE ELEMENT  max_ij(AMAT^H.BMAT)             C
C          'O' - ONE-NORM              max column sum (AMAT^H.BMAT)    C
C          'I' - INF-NORM              max row sum (AMAT^H.BMAT)       C
C**********************************************************************C
C
      CHARACTER*1 MET
C
      COMPLEX*16 ZGEMMIP
      COMPLEX*16 AMAT(NLG,NLG),BMAT(NLG,NLG),CMAT(NSM,NSM)
C
      DIMENSION V(NSM),W(NSM)
C
C     CHECK INNER PRODUCT SPACE
      IF(MET.NE.'O'.AND.MET.NE.'I'.AND.MET.NE.'F'.AND.MET.NE.'M') THEN
        WRITE(6, *) 'In ZGEMMIP: invalid metric choice!',MET
        WRITE(7, *) 'In ZGEMMIP: invalid metric choice!',MET
        RETURN
      ENDIF
C
C     INITIALISE THE INNER PRODUCT
      ZGEMMIP = DCMPLX(0.0D0,0.0D0)
C
C     FROBENIUS METRIC
      IF(MET.EQ.'F') THEN
C
        DO I=1,NSM
          DO J=1,NSM
            ZGEMMIP = ZGEMMIP + DCONJG(AMAT(I,J))*BMAT(I,J)
          ENDDO
        ENDDO
C
C       NO NEED TO CALCULATE CMAT NOW
        RETURN
C
      ENDIF
C
C     CALCULATE PRODUCT MATRIX, AMAT^H.BMAT
      DO I=1,NSM
        DO J=1,NSM
          CMAT(I,J) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NSM
            CMAT(I,J) = CMAT(I,J) + DCONJG(AMAT(K,I))*BMAT(K,J)
          ENDDO
        ENDDO
      ENDDO
C
C     MAX ABSOLUTE ELEMENT METRIC
      IF(MET.EQ.'M') THEN
C
C       SEARCH FOR ELEMENT OF CMAT WITH LARGEST MAGNITUDE
        DO I=1,NSM
          DO J=1,NSM
            IF(ABS(CMAT(I,J)).GT.ABS(ZGEMMIP)) THEN
              ZGEMMIP = ABS(CMAT(I,J))
            ENDIF
          ENDDO
        ENDDO
C
C     ONE-NORM METRIC (LARGEST COLUMN SUM OF CMAT)
      ELSEIF(MET.EQ.'O') THEN
C
C       CALCULATE COLUMN SUMS
        DO J=1,NSM
          W(J) = DCMPLX(0.0D0,0.0D0)
          DO I=1,NSM
            W(J) = W(J) + ABS(CMAT(I,J))
          ENDDO
        ENDDO
C
C       SEARCH FOR ELEMENT OF V WITH LARGEST MAGNITUDE
        DO J=1,NSM
          IF(ABS(W(J)).GT.ABS(ZGEMMIP)) THEN
            ZGEMMIP = ABS(W(J))
          ENDIF
        ENDDO
C
C     INF-NORM METRIC (LARGEST ROW SUM OF CMAT)
      ELSEIF(MET.EQ.'I') THEN
C
C       CALCULATE ROW SUMS
        DO I=1,NSM
          V(I) = DCMPLX(0.0D0,0.0D0)
          DO J=1,NSM
            V(I) = V(I) + ABS(CMAT(I,J))
          ENDDO
        ENDDO
C
C       SEARCH FOR ELEMENT OF V WITH LARGEST MAGNITUDE
        DO I=1,NSM
          IF(ABS(V(I)).GT.ABS(ZGEMMIP)) THEN
            ZGEMMIP = ABS(V(I))
          ENDIF
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ZGEMPW(AMAT,BMAT,RK,NLG,NSM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     ZZZZZZZZ GGGGGG  EEEEEEEE MM       MM PPPPPPP  WW        WW      C
C          ZZ GG    GG EE       MMM     MMM PP    PP WW        WW      C
C         ZZ  GG       EE       MMMM   MMMM PP    PP WW   WW   WW      C
C        ZZ   GG       EEEEEE   MM MM MM MM PP    PP WW  WWWW  WW      C
C       ZZ    GG   GGG EE       MM  MMM  MM PPPPPPP  WW WW  WW WW      C
C      ZZ     GG    GG EE       MM   M   MM PP       WWWW    WWWW      C
C     ZZZZZZZZ GGGGGG  EEEEEEEE MM       MM PP       WW        WW      C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZGEMPW CALCULATES THE REAL POWER RK OF A COMPLEX*16-VALUED SQUARE   C
C  MATRIX AMAT, AND THEN RETURNS THE RESULT TO BMAT.                   C
C -------------------------------------------------------------------- C
C                 k         k   -1            A = ORIGINAL MATRIX      C
C          B  =  A  =  P . D . P              D = EIGENVALUES OF A     C
C                                             P = EIGENVECTORS OF A    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    AMAT - INPUT SQUARE MATRIX OF COMPLEX*16 VALUES.                  C
C    NLG  - DIMENSION SQUARE OF MATRIX                                 C
C    NSM  - LAST RELEVANT ENTRY IN MATRIX                              C
C    RK   - REAL-VALUED POWER.                                         C
C  OUTPUT:                                                             C
C    BMAT - OUTPUT SQUARE MATRIX OF COMPLEX*16 VALUES.                 C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 AMAT(NLG,NLG),BMAT(NLG,NLG),PMAT(NLG,NLG)
      COMPLEX*16 WKC(LWK)
C      
      DIMENSION RWK(LWK)
      DIMENSION DVEC(NLG)
C
C     COPY AMAT TO PMAT
      DO I=1,NSM
        DO J=1,NSM
          PMAT(I,J) = AMAT(I,J)
        ENDDO
      ENDDO
C
C     DIAGONALISE OVERLAP MATRIX (REQUIRES LAPACK LIBRARY)
      CALL ZHEEV('V','L',NSM,PMAT,NLG,DVEC,WKC,LWK,RWK,INF)
      IF(INF.NE.0) THEN
        WRITE(6, *) 'In ZGEMPW: eigenvalue solver ZHEEV failed.',INF
        WRITE(7, *) 'In ZGEMPW: eigenvalue solver ZHEEV failed.',INF
      ENDIF
C                       k      -1
C     BMAT = PMAT . DVEC . PMAT
      DO I=1,NSM
        DO J=1,NSM
          PMAT(I,J) = PMAT(I,J)*(DVEC(I)**RK)
        ENDDO
      ENDDO
C
C     FINISH THE MATRIX
      DO I=1,NSM
        DO J=1,NSM
          BMAT(I,J) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NSM
            BMAT(I,J) = BMAT(I,J) + DCONJG(PMAT(K,I))*PMAT(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [4] ATOMIC HARTREE-FOCK: SINGLE-CENTRE SCF CALCULATIONS.           C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] ERFINT0: INTEGRAL OVER A GAUSSIAN AND ERROR FUNCTION.          C
C   [N] GAMLWR: LOWER INCOMPLETE GAMMA FUNCTION gamma(A,X).            C
C**********************************************************************C
C
C
      FUNCTION ERFINT0(L,EIJ,ZTA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE RRRRRRR  FFFFFFFF IIII NN    NN TTTTTTTT 000000        C
C      EE       RR    RR FF        II  NNN   NN    TT   00   000       C
C      EE       RR    RR FF        II  NNNN  NN    TT   00  0000       C
C      EEEEEE   RR    RR FFFFFF    II  NN NN NN    TT   00 00 00       C
C      EE       RRRRRRR  FF        II  NN  NNNN    TT   0000  00       C
C      EE       RR    RR FF        II  NN   NNN    TT   000   00       C
C      EEEEEEEE RR    RR FF       IIII NN    NN    TT    000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERFINT0 CALCULATES THE VALUE OF AN INTEGRAL OVER A GAUSSIAN WITH    C
C  EXPONENT EIJ, AN ERROR FUNCTION WITH NUCLEAR WIDTH PARAMETER ZTA    C
C  AND AN ODD POLYNOMIAL ORDER, 2L+1. SUPPORTS UP TO RELATIVISTIC L=9. C
C                           ∞                                          C
C          ERFINT(L,λ,ζ) = ∫ r^2L+1 exp(-λ r^2) erf(√ζ r) dr.          C
C                           0                                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In ERFINT0: order L must be positive. L = ',L
        WRITE(7, *) 'In ERFINT0: order L must be positive. L = ',L
        STOP
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS L
      X   = EIJ/ZTA
      X5  = X*X*X*X*X
      T0  = ZTA+EIJ
      RAT = ZTA/T0
      TRM = 0.5D0*DSQRT(ZTA)/EIJ/DSQRT(T0)
      DO I=1,L
        TRM = 0.5D0*TRM*RAT/EIJ
      ENDDO
C
      IF(L.EQ.0) THEN
        TRM = TRM
      ELSEIF(L.EQ.1) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(L.EQ.2) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(L.EQ.3) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(L.EQ.4) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(L.EQ.5) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(L.EQ.6) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(L.EQ.7) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(L.EQ.8) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(L.EQ.9) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(L.EQ.10) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In ERFINT0: order L too large. L = ',L
        WRITE(7, *) 'In ERFINT0: order L too large. L = ',L
      ENDIF
C
C     TRANSFER DATA TO ERFINT0
      ERFINT0 = TRM
C
      RETURN
      END
C
C
      FUNCTION GAMUPR(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM UU    UU PPPPPPP  RRRRRRR        C
C       GG    GG   AAAA   MMM     MMM UU    UU PP    PP RR    RR       C
C       GG        AA  AA  MMMM   MMMM UU    UU PP    PP RR    RR       C
C       GG       AA    AA MM MM MM MM UU    UU PP    PP RR    RR       C
C       GG   GGG AAAAAAAA MM  MMM  MM UU    UU PPPPPPP  RRRRRRR        C
C       GG    GG AA    AA MM   M   MM UU    UU PP       RR    RR       C
C        GGGGGG  AA    AA MM       MM  UUUUUU  PP       RR    RR       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMUPR RETURNS THE UPPER INCOMPLETE GAMMA FUNCTION FOR INTEGER OR   C
C  HALF-INTEGER ARGUMENTS. INPUT L IS TWICE THE ACTUAL ARGUMENT.       C
C  SOLUTIONS ARE FINITE AND ALGEBRAIC -- NO APPROXIMATIONS NEEDED.     C
C  NECESSARY -- AN ALGEBRAIC SOLUTION HAS BEEN DEDUCED.                C
C                                                                      C
C                GAMUPR(ℓ,x) = Γ(ℓ/2,x) with ℓ>0 and x>0.              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PIM(L)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In GAMUPR: order L must be at least 1. L = ',L
        WRITE(7, *) 'In GAMUPR: order L must be at least 1. L = ',L
        STOP
      ENDIF
C
C     INTEGER ARGUMENTS L
      IF(MOD(L,2).EQ.0) THEN
C
C       EXPONENTIAL FACTOR
        FC1 = DEXP(-X)
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-2)/2
          POLY = POLY + XPOW*RFACT((L-2)/2)/RFACT(I)
          XPOW = XPOW*X
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMUPR = FC1*POLY
C
      ELSE
C
C       FACTORS REQUIRED FOR ALL ORDERS
        X12 = DSQRT(X)
        FC1 = PI12*(1.0D0-DERF(X12))
        FC2 = DEXP(-X)*X12
C
C       POCHHAMMER SYMBOL
        P32 = 1.0D0
        DO K=0,(L-3)/2
          P32 = P32*(0.5D0+DFLOAT(K))
        ENDDO
C
C       FACTOR FOR EACH POWER TERM
        LST = (L-1)/2
        IF(LST.GT.0) THEN
          PSD = 1.0D0
          DO I=1,LST
            PIM(I) = PSD
            PSD    = 0.5D0*PSD*DFLOAT(L-2*I)
          ENDDO
        ENDIF
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-3)/2
C
          POLY = POLY + XPOW*PIM(LST-I)
          XPOW = XPOW*X
C
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMUPR = P32*FC1 + POLY*FC2
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION GAMLWR(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      GGGGGG     AA    MM       MM LL       WW        WW RRRRRRR      C
C     GG    GG   AAAA   MMM     MMM LL       WW        WW RR    RR     C
C     GG        AA  AA  MMMM   MMMM LL       WW   WW   WW RR    RR     C
C     GG       AA    AA MM MM MM MM LL       WW  WWWW  WW RR    RR     C
C     GG   GGG AAAAAAAA MM  MMM  MM LL       WW WW  WW WW RRRRRRR      C
C     GG    GG AA    AA MM   M   MM LL       WWWW    WWWW RR    RR     C
C      GGGGGG  AA    AA MM       MM LLLLLLLL WW        WW RR    RR     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMLWR RETURNS THE LOWER INCOMPLETE GAMMA FUNCTION FOR INTEGER OR   C
C  HALF-INTEGER ARGUMENTS. INPUT L IS TWICE THE ACTUAL ARGUMENT.       C
C  SOLUTIONS ARE FINITE AND ALGEBRAIC -- NO APPROXIMATIONS NEEDED.     C
C                                                                      C
C                GAMLWR(ℓ,x) = γ(ℓ/2,x) with ℓ>0 and x>0.              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PIM(L)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In GAMLWR: order L must be at least 1. L = ',L
        WRITE(7, *) 'In GAMLWR: order L must be at least 1. L = ',L
        STOP
      ENDIF
C
C     INTEGER ARGUMENTS L
      IF(MOD(L,2).EQ.0) THEN
C
C       EXPONENTIAL FACTOR
        FC1 = DEXP(-X)
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-2)/2
          POLY = POLY + XPOW*RFACT((L-2)/2)/RFACT(I)
          XPOW = XPOW*X
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMLWR = RFACT((L-2)/2) - FC1*POLY
C
      ELSE
C
C       FACTORS REQUIRED FOR ALL ORDERS
        X12 = DSQRT(X)
        FC1 = PI12*DERF(X12)
        FC2 = DEXP(-X)*X12
C
C       POCHHAMMER SYMBOL
        P32 = 1.0D0
        DO K=0,(L-3)/2
          P32 = P32*(0.5D0+DFLOAT(K))
        ENDDO
C
C       FACTOR FOR EACH POWER TERM
        LST = (L-1)/2
        IF(LST.GT.0) THEN
          PSD = 1.0D0
          DO I=1,LST
            PIM(I) = PSD
            PSD    = 0.5D0*PSD*DFLOAT(L-2*I)
          ENDDO
        ENDIF
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-3)/2
C
          POLY = POLY + XPOW*PIM(LST-I)
          XPOW = XPOW*X
C
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMLWR = P32*FC1 - POLY*FC2
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION FMIINT0(L,EIJ,A,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF MM       MM IIII IIII NN    NN TTTTTTTT 000000        C
C       FF       MMM     MMM  II   II  NNN   NN    TT   00   000       C
C       FF       MMMM   MMMM  II   II  NNNN  NN    TT   00  0000       C
C       FFFFFF   MM MM MM MM  II   II  NN NN NN    TT   00 00 00       C
C       FF       MM  MMM  MM  II   II  NN  NNNN    TT   0000  00       C
C       FF       MM   M   MM  II   II  NN   NNN    TT   000   00       C
C       FF       MM       MM IIII IIII NN    NN    TT    000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  FMIINT0 CALCULATES AN AUXILLIARY FERMI POTENTIAL INTEGRAL OVER      C
C  A PAIR OF ATOMIC BASIS FUNCTIONS, WHERE L IS A POSITIVE INTEGER.    C
C                        ∞                                             C
C      FMIINT0(L,λ,ζ) = ∫ r^2L+1 exp(-λ r^2) r*V_fermi(r) dr.          C
C                        0                                             C
C  THIS ROUTINE USES MY OWN RECIPE FOR THE ANNOYING INTEGRAL CLASSES,  C
C  FOR THE FIRST FEW L CASES AND ON THE CONDITION THAT A√λ < 0.05D0.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
c
      DIMENSION U(0:60),P(24)
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In FMIINT0: invalid parameter L. L = ',L
        WRITE(7, *) 'In FMIINT0: invalid parameter L. L = ',L
        STOP
      ENDIF
C
C     MULTIPLES OF THE FACTOR U
      U(0) = 1.0D0
      DO K=1,60
        U(K) = U(K-1)*A/C
      ENDDO
C
C     SPECIAL VALUES OF THE RIEMANN-ZETA FUNCTION
      P( 4) =-(PI**4)*7.0D0/720.0D0
      P( 6) =-(PI**6)*31.0D0/30240.0D0
      P( 8) =-(PI**8)*127.0D0/12096.0D2
      P(10) =-(PI**10)*73.0D0/684288.0D1
      P(12) =-(PI**12)*1414477.0D0/1307674368.0D3
      P(14) =-(PI**14)*8191.0D0/747242496.0D2
      P(16) =-(PI**16)*16931177.0D0/152437569184.0D4
      P(18) =-(PI**18)*5749691557.0D0/5109094217170944.0D3
      P(20) =-(PI**20)*91546277357.0D0/8028576626982912.0D5
      P(22) =-(PI**22)*3324754717.0D0/28777755182432256.0D4
      P(24) =-(PI**24)*1982765468311237.0D0/16938241367317436694528.0D5
C
C     CORRECT DIMENSIONS ARISE FROM THESE TERMS
      EL1 = 1.0D0/(EIJ**(L+1))
      C2L = C**(2*L+2)
C
C     DIMENSIONLESS GAUSSIAN PARAMETER
      SIGMA = EIJ*C*C
C
C     FERMI NORMALISATION CONSTANT
      FNRM = 1.0D0 + PI*PI*U(2) - 6.0D0*U(3)*POLYLOG(3,-1.0D0/U(1))
      FNRM = 1.0D0/FNRM
C
C     INTEGRAL TYPE: INCOMPLETE GAMMA FUNCTIONS
      FA  = 1.5D0 + PI*PI*U(2)*0.5D0
      FB  =-0.5D0
      FC  = 1.0D0 + PI*PI*U(2)
      Y1A = 0.5D0*GAMLWR(2*L+3,SIGMA)/(DSQRT(SIGMA))
      Y1B = 0.5D0*GAMLWR(2*L+5,SIGMA)/(SIGMA*DSQRT(SIGMA))
      Y1C = 0.5D0*GAMUPR(2*L+2,SIGMA)
      Y1  = FA*Y1A + FB*Y1B + FC*Y1C
C
C     INTEGRAL TYPE: SEMI-INFINITE GAMMA FUNCTIONS
      FD  =-6.0D0*U(3)*POLYLOG(3,-1.0D0/U(1))
      Y2D = 0.5D0*RFACT(L)
      
      Y2  = FD*Y2D
C
C     INTEGRAL TYPE: POLYLOG FUNCTIONS WITH GAUSSIANS AND POLYNOMIALS
C                    (EVALUATION METHOD DEPENDS ON SIGMA PARAMETER)
      Y34 = 0.0D0
C
C     EXPAND THE GAUSSIAN FACTOR IN TAYLOR SERIES AND ASSUME LARGE N/U
C      IF(SIGMA.LT.1.0D0) THEN
       GOTO 123
C
C       MAXIMUM EXPANSION ORDER FOR GAUSSIAN
        KMAX = 20
C
C       INITIALISE BINS FOR GAUSSIAN EXPANSION SERIES     
        PHK = 1.0D0
        SGK = 1.0D0
        FTK = 1.0D0
C
C       TAYLOR EXPANSION OVER THE GAUSSIAN FOR SMALL SIGMA
        DO K=0,KMAX
C
          BIN = U(1)*U(2*L+2*K)*POLYLOG(2*L+2*K+5,-1.0D0/U(1))
          DO J=0,MIN(L+K,10)
C
            PR = 1.0D0/RFACT(2*L+2*K-2*J+1)
            BIN = BIN + 2.0D0*U(2*J)*P(2*J+4)*PR
C
          ENDDO
C             
          Y34 = Y34 + PHK*SGK*DFLOAT(L+K+2)*RFACT(2*L+2*K+1)*BIN/FTK
C
C         UPDATE PHASES, FACTORIALS AND POLYNOMIALS IN K
          PHK =-PHK
          SGK = SGK*SIGMA
          FTK = FTK*DFLOAT(K+1)
C          
        ENDDO
C     
C       INCLUDE MULTIPLICATIVE FACTOR
        Y34 = 6.0D0*U(4)*Y34
C
C     NUMERICAL QUADRATURE (WORKS FOR ANY CASE BUT COMPUTATIONALLY SLOW)
C     ELSE
123     CONTINUE
C
C       INTEGRATION GRID DETAILS
        NLIN = 100
        NEXP = 1000
        RMAX = 15.0D0
        ELIN = 1.0D0/DFLOAT(NLIN)
        EEXP = DLOG(RMAX/C)/DFLOAT(NEXP)
C
C       NUMERICALLY INTEGRATE REMAINING TERMS FROM 0 TO C (LINEAR)
        X0C = 0.0D0
        DO N=0,NLIN
          ZN  = ELIN*DFLOAT(N)
          Z1  = ZN**(2*L+1)
          Z2  = DEXP(-SIGMA*ZN*ZN)
          Z3  =-ZN*POLYLOG(2,(ZN-1.0D0)/U(1))
          Z4  = 2.0D0*U(1)*POLYLOG(3,(ZN-1.0D0)/U(1))
          X0C = X0C + EXTINT11(Z1*Z2*(Z3+Z4),N,NLIN)
        ENDDO
        X0C = 15.0D0*U(2)*ELIN*X0C/299376.0D0
C
C       NUMERICALLY INTEGRATE REMAINING TERMS FROM C TO INFINITY (EXP.)
        XCI = 0.0D0
        DO N=0,NEXP
          TN  = EEXP*DFLOAT(N)
          ZN  = DEXP(TN)
          Z1  = ZN**(2*L+2)
          Z2  = DEXP(-SIGMA*ZN*ZN)
          Z3  = ZN*POLYLOG(2,(1.0D0-ZN)/U(1))
          Z4  = 2.0D0*U(1)*POLYLOG(3,(1.0D0-ZN)/U(1))
          XCI = XCI + EXTINT11(Z1*Z2*(Z3+Z4),N,NEXP)
        ENDDO
        XCI = 15.0D0*U(2)*EEXP*XCI/299376.0D0
C        
        Y34 = X0C+XCI
C
C      ENDIF
C
C     COMBINE ALL TERMS AND APPLY NORMALISATION FACTOR
      FMIINT0 = FNRM*(EL1*Y1 + EL1*Y2 + C2L*Y34)
C
      RETURN
      END
C
C
      SUBROUTINE RNORM0(RN,EXL,NBAS,LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       RRRRRRR  NN    NN  OOOOOO  RRRRRRR  MM       MM  000000        C
C       RR    RR NNN   NN OO    OO RR    RR MMM     MMM 00   000       C
C       RR    RR NNNN  NN OO    OO RR    RR MMMM   MMMM 00  0000       C
C       RR    RR NN NN NN OO    OO RR    RR MM MM MM MM 00 00 00       C
C       RRRRRRR  NN  NNNN OO    OO RRRRRRR  MM  MMM  MM 0000  00       C
C       RR    RR NN   NNN OO    OO RR    RR MM   M   MM 000   00       C
C       RR    RR NN    NN  OOOOOO  RR    RR MM       MM  000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNORM0 EVALUATES NORMALISATION CONSTANTS OF ALL VARIETIES.          C
C  USE THIS ROUTINE IF YOU'RE IN A BLOCK WITH THE SAME IZ AND KQN.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RN(MB2,4),EXL(MBS),RNL(MBS),RNS(MBS)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      RL = DFLOAT(LQN)
      G1 = TWLG-GAMLOG(2*LQN+3)
      G2 = TWLG-GAMLOG(2*LQN+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO IBAS=1,NBAS
        ELOG      = DLOG(2.0D0*EXL(IBAS))
        RNL(IBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNS(IBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     RN(M,1) ARE THE LL NORMALISATION CONSTANTS
C     RN(M,2) ARE THE LS NORMALISATION CONSTANTS
C     RN(M,3) ARE THE SL NORMALISATION CONSTANTS
C     RN(M,4) ARE THE SS NORMALISATION CONSTANTS
C
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
          RN(M,1) = RNL(IBAS)*RNL(JBAS)
          RN(M,2) = RNL(IBAS)*RNS(JBAS)
          RN(M,3) = RNS(IBAS)*RNL(JBAS)
          RN(M,4) = RNS(IBAS)*RNS(JBAS)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION ANGSQLS(L1,L2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    NN    NN  GGGGGG   SSSSSS    QQQQQQ    LL       SSSSSS    C
C     AAAA   NNN   NN GG    GG SS    SS  QQ    QQ   LL      SS    SS   C
C    AA  AA  NNNN  NN GG       SS       QQ      QQ  LL      SS         C
C   AA    AA NN NN NN GG        SSSSSS  QQ      QQ  LL       SSSSSS    C
C   AAAAAAAA NN  NNNN GG   GGG       SS QQ      QQ  LL            SS   C
C   AA    AA NN   NNN GG    GG SS    SS  QQ    QQ   LL      SS    SS   C
C   AA    AA NN    NN  GGGGGG   SSSSSS    QQQQQQ QQ LLLLLLLL SSSSSS    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGSQLS EVALUATES THE NON-RELATIVISTIC 3-J SYMBOL FOR ATOMIC        C
C  COULOMB ANGULAR COEFFICIENT ROUTINES, TAKEN FROM BRINK AND SATCHLER.C
C  L1,L2, AND K MUST BE EQUAL TO THE ACTUAL (INTEGER) ANGULAR MOMENTA  C
C  OF THE ELECTRON AND PHOTON.                                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE INEQUALITY RESTRICTIONS
      IF(K.LT.IABS(L1-L2).OR.K.GT.(L1+L2)) THEN
        ANGSQLS = 0.0D0
        RETURN
      ENDIF
      LLK = L1+L2+K
C
C     PARITY SELECTION RULE
      IF((LLK/2)*2.NE.LLK) THEN
        ANGSQLS = 0.0D0
        RETURN
      ENDIF
C
      RF1 = RFACT(  L1+L2-K   )
      RF2 = RFACT(- L1+L2+K   )
      RF3 = RFACT(  L1-L2+K   )
      RF4 = RFACT(  L1+L2+K +1)
      RF5 = RFACT(( L1+L2+K)/2)
      RF6 = RFACT(( L1+L2-K)/2)
      RF7 = RFACT(( L1-L2+K)/2)
      RF8 = RFACT((-L1+L2+K)/2)
C
      T1 = RF1*RF2*RF3
      T2 = T1/RF4
      T3 = RF6*RF7*RF8
      T4 = RF5/T3
C
      ANGSQLS = T2*T4*T4
C
      RETURN
      END
C
C
      FUNCTION ANGSQJJ(J1,J2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    NN    NN  GGGGGG   SSSSSS    QQQQQQ       JJJJ     JJJJ   C
C     AAAA   NNN   NN GG    GG SS    SS  QQ    QQ        JJ       JJ   C
C    AA  AA  NNNN  NN GG       SS       QQ      QQ       JJ       JJ   C
C   AA    AA NN NN NN GG        SSSSSS  QQ      QQ       JJ       JJ   C
C   AAAAAAAA NN  NNNN GG   GGG       SS QQ      QQ       JJ       JJ   C
C   AA    AA NN   NNN GG    GG SS    SS  QQ    QQ  JJ    JJ JJ    JJ   C
C   AA    AA NN    NN  GGGGGG   SSSSSS    QQQQQQ QQ JJJJJJ   JJJJJJ    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGSQJJ EVALUATES THE SQUARE OF A 3-J SYMBOL,   /  j   K   j' \^2   C
C  WHERE j = J1/2 AND j' = J2/2, FOR THE           \-1/2  0  1/2 /     C
C  COULOMB/BREIT ANGULAR COEFFICIENT ROUTINES.                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(K.LT.IABS((J1-J2)/2).OR.K.GT.(J1+J2)/2) THEN
        ANGSQJJ = 0.0D0
        RETURN
      ELSEIF(J1.LE.0.OR.J2.LE.0) THEN
        ANGSQJJ = 0.0D0
        RETURN
      ENDIF
C
C     VARIABLE WHICH DEPENDS ON PARITY OF ARGUMENTS
      JJK = (J1+J2)/2 + K
      IF((JJK/2)*2.EQ.JJK) THEN
        M = K
      ELSE
        M = K+1
      ENDIF
C
      RN1 = RFACT(( J1+J2)/2 - K)
      RN2 = RFACT((-J1+J2)/2 + K)
      RN3 = RFACT(( J1-J2)/2 + K)
      RN4 = SFACT(( J1+J2)/2 + M)
      RD1 = DFLOAT(J1+1)
      RD2 = DFLOAT(J2+1)
      RD3 = RFACT(( J1+J2)/2 + K + 1)
      RD4 = SFACT(( J1+J2)/2 - M    )
      RD5 = SFACT(( J1-J2)/2 + M - 1)
      RD6 = SFACT((-J1+J2)/2 + M - 1)
      PHS = (-1.0D0)**((J2-(3*J1))/2+M)
C
      RNUM  = RN1*RN2*RN3*(RN4)**2
      RDEN  = RD1*RD2*RD3*(RD4*RD5*RD6)**2
C
      ANGSQJJ = PHS*RNUM/RDEN
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE SCF CALCULATIONS.          C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] HFSCF: MAIN ROUTINE FOR MOLECULAR HARTREE-FOCK SCF PROCEDURE.  C
C   [B] OVRLP: CONSTRUCTS THE ONE-ELECTRON OVERLAP MATRIX.             C
C   [C] ONEEL: ONE-ELECTRON MULTI-CENTRE MATRIX OF INTEGRALS.          C
C   [D] SLFINT: CONSTRUCTS MULTI-CENTRE ELECTRON SELF ENERGY ELEMENTS. C
C   [E] UEHNUC: CONSTRUCTS MULTI-CENTRE UEHLING ELEMENTS.              C
C   [F] WKRNUC: CONSTRUCTS MULTI-CENTRE WICHMANN-KROLL ELEMENTS.       C
C   [G] KSBNUC: CONSTRUCTS MULTI-CENTRE KÄLLÉN-SABRY ELEMENTS.         C
C   [H] COULOMB: CONSTRUCTS ALL MULTI-CENTRE COULOMB SCF ELEMENTS.     C
C   [I] ERI: GENERATES A BLOCK OF ELECTRON REPULSION INTEGRALS.        C
C   [J] CLMMTZ: COULOMB MATRIX FROM MOLECULAR INTEGRALS (Z-SYMM).      C
C   [J] CLMMTG: COULOMB MATRIX FROM MOLECULAR INTEGRALS (GENERAL).     C
C   [K] BREIT: MATRIX REP OF MEAN-FIELD BREIT INTERACTION.             C
C   [L] BII: GENERATES A BLOCK OF BREIT INTERACTION INTEGRALS.         C
C   [J] BRTMTZ: BREIT MATRIX FROM MOLECULAR INTEGRALS (Z-SYMM).        C
C   [J] BRTMTG: BREIT MATRIX FROM MOLECULAR INTEGRALS (GENERAL).       C
C   [N] COUPLE: ESTABLISH OPEN/CLOSED SHELL COUPLING BETWEEN ARRAYS.   C
C   [O] SPARSITY: SEARCHES FOR VANISHING MATRIX ELEMTNS IN A MATRIX.   C
C   [P] NCART: RETURNS THE CARTESIAN INDEX FROM A LOOP INDEX.          C
C   [Q] NCNTRS: RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT.   C
C   [R] ZPROJ: RETURNS A METRIC FOR Z-AXIS DEVIATION OF SOME COORDS.   C
C   [S] KLAB: RETURNS THE CONVENTIONAL DIRAC SYMMETRY TYPE STRING.     C
C   [T] MLAB: RETURNS THE CONVENTIONAL DIRAC MAGNETIC STATE STRING.    C
C**********************************************************************C
C
C
      SUBROUTINE HFSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF             C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF      SS       CC       FF                   C
C              HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF               C
C              HH    HH FF            SS CC       FF                   C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF       SSSSSS   CCCCCC  FF                   C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS A SINGLE-DETERMINANT ITERATIVE SELF-CONSISTENT FIELD C
C  PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*7  HMINT(50),PTYPE(10)
      CHARACTER*11 MS
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION RK(3*MDM),ESAV(0:MIT),DNRM(MIT),WEDN(0:MIT)
      DIMENSION NMLEV(5),TMLEV(5)
C
      COMPLEX*16 WK(LWK)
      COMPLEX*16 COEF(MDM,MDM),DTMP(MDM,MDM),OTMP(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 DOLD(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DAMP/DOLD
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EANM,ESLF,EUEH,
     &            EWKR,EKSB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/PT1B/NHMINT,HMINT
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C**********************************************************************C
C     SCF CALCULATION CHOICES AND ARRAY INITIALISATION                 C
C**********************************************************************C
C
C     PARAMETERS FOR COMPLETING STAGES
      ENRGLV1 = 1.0D-08
      ENRGLV2 = 5.0D-11
      ENRGTOL = 1.0D-12
      DSTYTOL = 1.0D-10
C
C     INITIALISE ARRAYS AND TEMPORARY DENSITY MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
          VWKR(I,J) = DCMPLX(0.0D0,0.0D0)
          VKSB(I,J) = DCMPLX(0.0D0,0.0D0)
          VSLF(I,J) = DCMPLX(0.0D0,0.0D0)
          VANM(I,J) = DCMPLX(0.0D0,0.0D0)
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          WDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          WXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          FOCK(I,J) = DCMPLX(0.0D0,0.0D0)
          DTMP(I,J) = DENT(I,J)
        ENDDO
      ENDDO
C
C     INITIALISE INTEGRAL INCLUSION LEVEL VALUES
      ITER = 0
      DO N=1,5
        NMLEV(N) = 0
        TMLEV(N) = 0.0D0
      ENDDO
C
C     INITIALISE ENERGY NORM STORAGE
      IF(READIN) THEN
        ESAV(0) = 1.0D0
      ELSE
        ESAV(0) = ETOT
      ENDIF
C
C**********************************************************************C
C     ECONOMISATION STRATEGIES                                         C
C**********************************************************************C
C
C     MULTI-CENTRE INTEGRAL SYMMETRY RELATIONS FOR RECYCLING RR BATCHES
      INTSYM = .TRUE.
C
C     TOGGLE FOR ATOMIC COULOMB/BREIT INTEGRAL SPLICING BY RACAH ALGEBRA
      RACAH1 = .TRUE.
C
C     CONVERGENCE STRATEGY: DIRECT INVERSION OF THE ITERATIVE SUBSPACE
      DIISQC = .TRUE.
C
C     STATIC DAMPING SCHEME
      DAMPFC = .FALSE.
C
C     STATIC DAMPING COUNTER
      IF(DAMPFC) THEN
        IDMPKEEP = 0
      ENDIF
C
C     TOGGLE FOR R-INTEGRAL BATCH SAVING IN ERI/BII
      RCFILE = EQFILE
C
C     MQN SELECTION RULES FOR MATRIX CONTRACTIONS IN LINEAR MOLECULES
      MQNSLC = .FALSE.
C
C**********************************************************************C
C     APPROXIMATIONS                                                   C
C**********************************************************************C
C
C     MANY-CENTRE GAUNT INTERACTION INSTEAD OF BREIT
      GAUNT2 = .FALSE.
C
C     VISSCHER BREIT CURRENT DENSITY APPROXIMATION
      VSDNSB = .FALSE.
C
C     VISSCHER SMALL-COMPONENT CHARGE DENSITY APPROXIMATION
      VSDNSC = .FALSE.
C
C     3-CENTRE (SS|SS) INTEGRAL SKIPPING
      SSSSI3 = .FALSE.
C
C     4-CENTRE (SS|SS) INTEGRAL SKIPPING
      SSSSI4 = .FALSE.
C
C     TWO-ELECTRON SCHWARZ SCREENING
      SCHWRZ = .FALSE.
C
C**********************************************************************C
C     PRELIMINARY STORAGE OF ARRAYS AND TITLES                         C
C**********************************************************************C
C
C     RECORD TIME AT START OF MOLECULAR SCF CALCULATION
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     REASONS TO SKIP DIRECTLY TO BREIT PERTURBATION ANAYLSIS
      IF(SHAPE.EQ.'ATOMIC'.AND.HMLT.EQ.'DHFP') THEN
        EQFILE = .FALSE.
        GOTO 998
      ENDIF
C
C     CALCULATE THE FULL SET OF EQ-COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL3)
      IF(EQFILE) THEN
        CALL EQSAVE
      ENDIF
      CALL SYSTEM_CLOCK(ICL4)
      TEPP = DFLOAT(ICL4-ICL3)/RATE
C
C     GOTO 998
C
C     GENERATE DIAGONAL TWO-ELECTRON INTEGRALS FOR SCREENING LATER
      CALL SYSTEM_CLOCK(ICL3)
      IF(SCHWRZ.AND.NOCC.GT.1) THEN
        IF(HMLT.NE.'BARE') THEN
          CALL CLMDIAG
          IF(HMLT.NE.'NORL'.AND.HMLT.NE.'DHFR') THEN
            CALL BRTDIAG
          ENDIF
        ENDIF
      ENDIF
      CALL SYSTEM_CLOCK(ICL4)
      TSCR = TSCR + DFLOAT(ICL4-ICL3)/RATE
C
C     PRINT THE FIRST INTEGRAL INCLUSION LEVEL
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      IF(ILEV.EQ.1) THEN
        WRITE(6,40)
        WRITE(7,40)
      ELSEIF(ILEV.EQ.2) THEN
        IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
          WRITE(6,41)
          WRITE(7,41)
        ELSE
          WRITE(6,42)
          WRITE(7,42)
        ENDIF
      ELSEIF(ILEV.EQ.3) THEN
        WRITE(6,43)
        WRITE(7,43)
      ENDIF
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     START OF SELF-CONSISTENT FIELD CALCULATIONS                      C
C**********************************************************************C
C
C     LOOP OVER SCF ITERATIONS
      DO ITER=1,MIT
C
C       TIME AT START OF ITERATION
        CALL SYSTEM_CLOCK(ICL3)
C
C       CALCULATE OVERLAP, KINETIC AND NUCLEAR POTENTIAL ELEMENTS
        CALL SYSTEM_CLOCK(ICL5)
        IF(ITER.EQ.1) THEN
          CALL OVRLP
          CALL ONEEL
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        T1EL =        DFLOAT(ICL6-ICL5)/RATE
        THMX = THMX + DFLOAT(ICL6-ICL5)/RATE
C
C       THE FOLLOWING BATCH OF ROUTINES ARE FOR DHFQ ONLY
        IF(HMLT.NE.'DHFQ') GOTO 65
C
C       CALCULATE ELECTRON ANOMALOUS MAGNETIC MOMENT ELEMENTS
        CALL SYSTEM_CLOCK(ICL5)
        IF(ITER.EQ.1) THEN
c         CALL ANMLS
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        T1EL = T1EL + DFLOAT(ICL6-ICL5)/RATE
        TAMX = TAMX + DFLOAT(ICL6-ICL5)/RATE
C
C       CALCULATE LOW-ENERGY ELECTRON SELF-INTERACTION ELEMENTS
        CALL SYSTEM_CLOCK(ICL5)
c       CALL SLFINT(ITER)
        CALL SYSTEM_CLOCK(ICL6)
        T1EL = T1EL + DFLOAT(ICL6-ICL5)/RATE
        TSMX = TSMX + DFLOAT(ICL6-ICL5)/RATE
C
C       CALCULATE NUCLEAR VACUUM POLARISATION ELEMENTS
        CALL SYSTEM_CLOCK(ICL5)
        IF(ITER.EQ.1) THEN
          CALL UEHNUC
          CALL WKRNUC
          CALL KSBNUC
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        T1EL = T1EL + DFLOAT(ICL6-ICL5)/RATE
        TUMX = TUMX + DFLOAT(ICL6-ICL5)/RATE
C
C       SKIP POINT FOR HMLT OTHER THAN DHFQ
65      CONTINUE
C
C       RESET TWO-ELECTRON INTEGRAL SCREENING COUNTERS
        DO MCNT=1,5
          DO ITT=1,9
            N2EB(MCNT,ITT) = 0
            N2EI(MCNT,ITT) = 0
            N2ES(MCNT,ITT) = 0
            T2ES(MCNT,ITT) = 0.0D0
          ENDDO
        ENDDO
C
C       GENERATE MEAN-FIELD CLOSED- AND OPEN-SHELL COULOMB MATRIX
        IF(HMLT.NE.'BARE'.AND.NOCC.GT.1) THEN
C
C         CALCULATE MANY-CENTRE COULOMB INTEGRALS (MCMURCHIE-DAVIDSON)
          CALL SYSTEM_CLOCK(ICL5)
c         CALL COULOMB
          CALL CLMFAST
          CALL SYSTEM_CLOCK(ICL6)
          TCL2 =        DFLOAT(ICL6-ICL5)/RATE
          TC2T = TC2T + DFLOAT(ICL6-ICL5)/RATE
C
C         SMALL-COMPONENT DENSITIES ON AN ATOMIC CENTRE (VISSCHER)
C         IF(ILEV.GT.1.AND.VSDNSC) THEN
C           CALL SYSTEM_CLOCK(ICL5)
C           CALL VISSCHR
C           CALL SYSTEM_CLOCK(ICL6)
C           TCLV =        DFLOAT(ICL6-ICL5)/RATE
C           TCVT = TCVT + DFLOAT(ICL6-ICL5)/RATE
C         ENDIF
C
C         ADD ALL ONE-CENTRE COULOMB CONTRIBUTIONS (RACAH ALGEBRA)
          CALL SYSTEM_CLOCK(ICL5)
          IF(RACAH1) THEN
            DO IZ=1,NCNT
              CALL COULOMB1(IZ)
            ENDDO
          ENDIF
          CALL SYSTEM_CLOCK(ICL6)
          TCL1 =        DFLOAT(ICL6-ICL5)/RATE
          TC1T = TC1T + DFLOAT(ICL6-ICL5)/RATE
C
        ELSE
C
          TCL1 = 0.0D0
          TCL2 = 0.0D0
          TC1T = 0.0D0
          TB2T = 0.0D0
C
        ENDIF
C
C       GENERATE MEAN-FIELD BREIT MATRIX
        IF((HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ').AND.NOCC.GT.1) THEN
C
C         CALCULATE MANY-CENTRE BREIT INTEGRALS (MCMURCHIE-DAVIDSON)
          CALL SYSTEM_CLOCK(ICL5)
C         CALL BREIT
          CALL BRTFAST
C
          CALL SYSTEM_CLOCK(ICL6)
          TBR2 =        DFLOAT(ICL6-ICL5)/RATE
          TB2T = TB2T + DFLOAT(ICL6-ICL5)/RATE
C
C         ADD ALL ONE-CENTRE BREIT CONTRIBUTIONS (RACAH ALGEBRA)
          CALL SYSTEM_CLOCK(ICL5)
          IF(RACAH1) THEN
            DO IZ=1,NCNT
              CALL BREIT1(IZ)
            ENDDO
          ENDIF
          CALL SYSTEM_CLOCK(ICL6)
          TBR1 =        DFLOAT(ICL6-ICL5)/RATE
          TB1T = TB1T + DFLOAT(ICL6-ICL5)/RATE
C
C         ADD ALL ONE-CENTRE BREIT CONTRIBUTIONS (RACAH ALGEBRA)
          CALL SYSTEM_CLOCK(ICL5)
          IF(VSDNSB) THEN
            CALL BREIT2
          ENDIF
          CALL SYSTEM_CLOCK(ICL6)
          TBR2 = TBR2 + DFLOAT(ICL6-ICL5)/RATE
          TB2T = TB2T + DFLOAT(ICL6-ICL5)/RATE
C
        ELSE
C
          TBR2 = 0.0D0
          TB2T = 0.0D0
          TBR1 = 0.0D0
          TB1T = 0.0D0
C
        ENDIF
C
C       ADD TWO- AND MANY-CENTRE BINS TO (TT|TT) TOTALS
        DO MCNT=1,4
          DO ITT=1,8
            N2EB(5,ITT) = N2EB(5,ITT) + N2EB(MCNT,ITT)
            N2EI(5,ITT) = N2EI(5,ITT) + N2EI(MCNT,ITT)
            N2ES(5,ITT) = N2ES(5,ITT) + N2ES(MCNT,ITT)
            T2ES(5,ITT) = T2ES(5,ITT) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       ADD ALL (TT|TT) RESULTS TO TOTALS
        DO MCNT=1,5
          DO ITT=1,8
            N2EB(MCNT,9) = N2EB(MCNT,9) + N2EB(MCNT,ITT)
            N2EI(MCNT,9) = N2EI(MCNT,9) + N2EI(MCNT,ITT)
            N2ES(MCNT,9) = N2ES(MCNT,9) + N2ES(MCNT,ITT)
            T2ES(MCNT,9) = T2ES(MCNT,9) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       FRACTION OF BLOCKS SCREENED
        DO MCNT=1,5
          DO ITT=1,9
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
C
C       ESTABLISH COUPLING BETWEEN CLOSED- AND OPEN-SHELL MATRIX REPS
        IF(HMLT.NE.'BARE') THEN
          IF(NOCC.GT.1.AND.NOPN.NE.0) THEN
            CALL COUPLE
          ENDIF
        ENDIF
C
C       CONSTRUCT FOCK MATRIX FROM ONE- AND TWO-BODY INTERACTIONS
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = HNUC(I,J) + HKIN(I,J) + GDIR(I,J) - GXCH(I,J)
     &                + BDIR(I,J) - BXCH(I,J) + VANM(I,J) + VSLF(I,J)
     &                + VUEH(I,J) + VWKR(I,J) + VKSB(I,J) + CPLE(I,J)
     &                - QDIR(I,J) + QXCH(I,J) - WDIR(I,J) + WXCH(I,J)
          ENDDO
        ENDDO
C
C       UPDATE MOLECULAR ENERGIES (BASED ON *PREVIOUS* DENSITY D^{N-1})
        CALL ENRGIES
C
C       LEVEL-SHIFT THE VIRTUAL SPACE TO MAKE ORBITALS LESS ACCESSIBLE
        CALL SYSTEM_CLOCK(ICL5)
        IF(READIN.OR.ITER.NE.1) THEN
          IF(ILEV.LE.3) THEN
            CALL LEVSHFT(SHLV)
          ENDIF
        ENDIF
        NMLEV(ILEV) = NMLEV(ILEV)+1
C
C       DIRECT INVERSION OF ITERATIVE SUBSPACE UPDATE
        IF(DIISQC) THEN
          CALL DIIS(NMLEV(ILEV))
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        TCNV =        DFLOAT(ICL6-ICL5)/RATE
        TACC = TACC + DFLOAT(ICL6-ICL5)/RATE
C
C       IMPLEMENT SPARSITY CHECK ON FOCK MATRIX
        CALL SYSTEM_CLOCK(ICL5)
        CALL SPARSITY(FOCK,NDIM,1.0D-10)
C
C       SAVE OVERLAP MATRIX IN TEMPORARY MATRIX (ZHEGV OVERWRITES IT)
        DO I=1,NDIM
          DO J=1,NDIM
            OTMP(I,J) = OVLP(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OTMP,MDM,EIGN,WK,LWK,RK,INF)
        IF(INF.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            COEF(I,J) = FOCK(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.NE.1) THEN
          DO IVIR=NSKP+NOCC+1,NDIM
            EIGN(IVIR) = EIGN(IVIR)-SHLV
          ENDDO
        ENDIF
C
C       WRITE EIGENVECTORS TO OUTPUT FILE
        OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
C
C       MATRIX ARITHMETIC ROUTINES
        CALL SYSTEM_CLOCK(ICL6)
        TDGN =        DFLOAT(ICL6-ICL5)/RATE
        TEIG = TEIG + DFLOAT(ICL6-ICL5)/RATE
C
C       UPDATE THE DENSITY MATRIX
        CALL DENSTY
C
C       WEIGHTED ENERGY DIFFERENCE NORM, WEDN
        DOFF = DABS(ETOT)+1.0D0
        WEDN(ITER) = DABS(ESAV(ITER-1)-ETOT)/DOFF
        ESAV(ITER) = ETOT
C
C       DENSITY DAMPING PARAMETERS
        EFRC = 0.7D0
        PDMP = 0.5D0
C
C       RATIO OF WEIGHTED ENERGY DIFFERENCES
        WEDR = WEDN(ITER)/WEDN(ITER-1)
C
C       REASONS TO ENTER INTO STATIC DAMPING PROCEDURE
        CALL SYSTEM_CLOCK(ICL5)
        IF(DAMPFC) THEN
C
          IF(NMLEV(ILEV).GT.3.AND.WEDR.GT.EFRC) THEN
c          IF(IDMPKEEP.EQ.1) THEN
c          IF(NMLEV(ILEV).GT.3.AND.WEDR.GT.EFRC) IDMPKEEP = 1
c          IF(IDMPKEEP.EQ.1) THEN
C
C
C           ALERT THE USER
            WRITE(6, *) 'ENTERING STATIC DAMPING PHASE'
            WRITE(7, *) 'ENTERING STATIC DAMPING PHASE'
C
C           TRANSFORM DENSITY MATRIX INTO LINEAR ADMIXTURE
            DO I=1,NDIM
              DO J=1,NDIM
                DENT(I,J) = (1.0D0-PDMP)*DENT(I,J) + PDMP*DTMP(I,J)
              ENDDO
            ENDDO
C
          ENDIF
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        TCNV = TCNV + DFLOAT(ICL6-ICL5)/RATE
        TACC = TACC + DFLOAT(ICL6-ICL5)/RATE
C
C       DENSITY DIFFERENCE NORM CALCULATION
        DNRM(ITER) = 0.0D0
        DO J=1,NDIM
          DO I=1,NDIM
            TMP        = ABS(DENT(I,J)-DTMP(I,J))
            DNRM(ITER) = DNRM(ITER)+TMP*TMP
            DTMP(I,J)  = DENT(I,J)
          ENDDO
        ENDDO
        RDM2 = DFLOAT(NDIM*NDIM)
        DNRM(ITER) = DSQRT(DNRM(ITER))/RDM2
C
C       IF DNRM IS SMALL ENOUGH, REDUCE REQUIREMENTS TO ENTER STAGE 3
        IF(DNRM(ITER).LE.1.0D-09) THEN
          ENRGLV2 = 1.0D+02*DNRM(ITER)
        ENDIF
C
C       UPDATE TIME COUNTERS AT END OF ITERATION
        CALL SYSTEM_CLOCK(ICL4)
        TSTP = DFLOAT(ICL4-ICL3)/RATE
        TMLEV(ILEV) = TMLEV(ILEV)+TSTP
C
C       DATE AND TIME AT END OF ITERATION
        CALL TIMENOW(STAMP)
C
C       HEADER FOR ITERATION SUMMARY
20      FORMAT(27X,A,1X,I3)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6,20) 'Iteration number',ITER
        WRITE(7,20) 'Iteration number',ITER
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       PRODUCE SPECTRUM SUMMARY AND INCLUDE FIRST 6 VIRTUAL STATES
        LF = LEN(TRIM(MOLCL))+LEN(TRIM(HMLT))
        LF = 23-LF/2
21      FORMAT(1X,A,'Molecular spectrum for ',A,' (',A,')')
        WRITE(6,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLT)
        WRITE(7,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLT)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        CALL SPECTRM(NOCC,6)
C
C       MOLECULAR ENERGIES
22      FORMAT(1X,A,19X,F21.12)
122     FORMAT(1X,A,19X,ES21.12)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Nucleus-nucleus             (N) ',ENUC
        WRITE(7,22) 'Nucleus-nucleus             (N) ',ENUC
        WRITE(6,22) 'Electron-nucleus            (V) ',EHNC
        WRITE(7,22) 'Electron-nucleus            (V) ',EHNC
        WRITE(6,22) 'Electron kinetic            (T) ',EHKN
        WRITE(7,22) 'Electron kinetic            (T) ',EHKN
        IF(HMLT.NE.'BARE'.AND.NOCC.GT.1) THEN
          WRITE(6,22) 'Coulomb direct (closed)     (GD)',EGDR
          WRITE(7,22) 'Coulomb direct (closed)     (GD)',EGDR
          WRITE(6,22) 'Coulomb exchange (closed)   (GX)',EGXC
          WRITE(7,22) 'Coulomb exchange (closed)   (GX)',EGXC
          IF(NOPN.NE.0) THEN
            WRITE(6,22) 'Coulomb direct (open)       (QD)',EQDR
            WRITE(7,22) 'Coulomb direct (open)       (QD)',EQDR
            WRITE(6,22) 'Coulomb exchange (open)     (QX)',EQXC
            WRITE(7,22) 'Coulomb exchange (open)     (QX)',EQXC
          ENDIF
          IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
            WRITE(6,22) 'Breit exchange (closed)     (BX)',EBXC
            WRITE(7,22) 'Breit exchange (closed)     (BX)',EBXC
            IF(NOPN.NE.0) THEN
              WRITE(6,22) 'Breit exchange (open)       (WX)',EWXC
              WRITE(7,22) 'Breit exchange (open)       (WX)',EWXC
              WRITE(6,22) 'Breit direct (open)         (WD)',EWDR
              WRITE(7,22) 'Breit direct (open)         (WD)',EWDR
            ENDIF
          ENDIF
          IF(HMLT.EQ.'DHFQ') THEN
            WRITE(6,22) 'Electron anomalous moment   (A) ',EANM
            WRITE(7,22) 'Electron anomalous moment   (A) ',EANM
            WRITE(6,22) 'Electron self-interaction   (S) ',ESLF
            WRITE(7,22) 'Electron self-interaction   (S) ',ESLF
            WRITE(6,22) 'Nuclear Uehling             (U) ',EUEH
            WRITE(7,22) 'Nuclear Uehling             (U) ',EUEH
            WRITE(6,22) 'Nuclear Wichmann-Kroll      (W) ',EWKR
            WRITE(7,22) 'Nuclear Wichmann-Kroll      (W) ',EWKR
            WRITE(6,22) 'Nuclear Källén-Sabry        (R) ',EKSB
            WRITE(7,22) 'Nuclear Källén-Sabry        (R) ',EKSB
          ENDIF
        ENDIF
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Molecule total                  ',ETOT
        WRITE(7,22) 'Molecule total                  ',ETOT
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       TWO-ELECTRON INTEGRAL SUMMARY
23      FORMAT(1X,A,4X,'1-centre',4X,'2-centre',4X,'3-centre',
     &                                     4X,'4-centre',7X,'Total')
24      FORMAT(1X,A,3X,I9,3X,I9,3X,I9,3X,I9,3X,I9)
25      FORMAT(1X,A,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2)
26      FORMAT(1X,A,1X,A,1X,A,1X,A,1X,A,1X,A)
C
        IF(HMLT.EQ.'BARE'.OR.NOCC.LE.1) THEN
          GOTO 207
        ENDIF
c
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6,23) '(LL|LL)     '
          WRITE(7,23) '(LL|LL)     '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          IF(SCHWRZ) THEN
            WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
            WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
            WRITE(6,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
            WRITE(7,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
            WRITE(6,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
            WRITE(7,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
          ENDIF
          WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ELSE
          WRITE(6,23) 'Blocks  (#) '
          WRITE(7,23) 'Blocks  (#) '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 211
          WRITE(6,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 211
          WRITE(6,24) '(LS|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(LS|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
          IF(INTSYM) GOTO 211
          WRITE(6,24) '(LS|SL)     ',(N2EB(MCNT,6),MCNT=1,5)
          WRITE(7,24) '(LS|SL)     ',(N2EB(MCNT,6),MCNT=1,5)
          WRITE(6,24) '(SL|LS)     ',(N2EB(MCNT,7),MCNT=1,5)
          WRITE(7,24) '(SL|LS)     ',(N2EB(MCNT,7),MCNT=1,5)
          WRITE(6,24) '(SL|SL)     ',(N2EB(MCNT,8),MCNT=1,5)
          WRITE(7,24) '(SL|SL)     ',(N2EB(MCNT,8),MCNT=1,5)
211       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2EB(MCNT,9),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2EB(MCNT,9),MCNT=1,5)
          IF(SCHWRZ) THEN
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(6,23) 'Integrals(#)'
            WRITE(7,23) 'Integrals(#)'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
            WRITE(7,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
            IF(HMLT.EQ.'NORL') GOTO 212
            WRITE(6,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
            WRITE(7,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
            WRITE(6,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
            WRITE(7,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
            WRITE(6,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
            WRITE(7,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 212
            WRITE(6,24) '(LS|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
            WRITE(7,24) '(LS|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
            IF(INTSYM) GOTO 212
            WRITE(6,24) '(LS|SL)     ',(N2EI(MCNT,6),MCNT=1,5)
            WRITE(7,24) '(LS|SL)     ',(N2EI(MCNT,6),MCNT=1,5)
            WRITE(6,24) '(SL|LS)     ',(N2EI(MCNT,7),MCNT=1,5)
            WRITE(7,24) '(SL|LS)     ',(N2EI(MCNT,7),MCNT=1,5)
            WRITE(6,24) '(SL|SL)     ',(N2EI(MCNT,8),MCNT=1,5)
            WRITE(7,24) '(SL|SL)     ',(N2EI(MCNT,8),MCNT=1,5)
212         CONTINUE
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) 'Total       ',(N2EI(MCNT,9),MCNT=1,5)
            WRITE(7,24) 'Total       ',(N2EI(MCNT,9),MCNT=1,5)
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(6,23) 'Screened (#)'
            WRITE(7,23) 'Screened (#)'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
            WRITE(7,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
            IF(HMLT.EQ.'NORL') GOTO 214
            WRITE(6,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
            WRITE(7,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
            WRITE(6,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
            WRITE(7,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
            WRITE(6,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
            WRITE(7,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 214
            WRITE(6,24) '(LS|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
            WRITE(7,24) '(LS|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
            IF(INTSYM) GOTO 214
            WRITE(6,24) '(LS|SL)     ',(N2ES(MCNT,6),MCNT=1,5)
            WRITE(7,24) '(LS|SL)     ',(N2ES(MCNT,6),MCNT=1,5)
            WRITE(6,24) '(SL|LS)     ',(N2ES(MCNT,7),MCNT=1,5)
            WRITE(7,24) '(SL|LS)     ',(N2ES(MCNT,7),MCNT=1,5)
            WRITE(6,24) '(SL|SL)     ',(N2ES(MCNT,8),MCNT=1,5)
            WRITE(7,24) '(SL|SL)     ',(N2ES(MCNT,8),MCNT=1,5)
214         CONTINUE
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) 'Total       ',(N2ES(MCNT,9),MCNT=1,5)
            WRITE(7,24) 'Total       ',(N2ES(MCNT,9),MCNT=1,5)
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(6,23) 'Screened (%)'
            WRITE(7,23) 'Screened (%)'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
            WRITE(7,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
            IF(HMLT.EQ.'NORL') GOTO 216
            WRITE(6,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
            WRITE(7,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
            WRITE(6,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
            WRITE(7,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
            WRITE(6,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
            WRITE(7,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 216
            WRITE(6,25) '(LS|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
            WRITE(7,25) '(LS|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
            IF(INTSYM) GOTO 216
            WRITE(6,25) '(LS|SL)     ',(F2ES(MCNT,6),MCNT=1,5)
            WRITE(7,25) '(LS|SL)     ',(F2ES(MCNT,6),MCNT=1,5)
            WRITE(6,25) '(SL|LS)     ',(F2ES(MCNT,7),MCNT=1,5)
            WRITE(7,25) '(SL|LS)     ',(F2ES(MCNT,7),MCNT=1,5)
            WRITE(6,25) '(SL|SL)     ',(F2ES(MCNT,8),MCNT=1,5)
            WRITE(7,25) '(SL|SL)     ',(F2ES(MCNT,8),MCNT=1,5)
216         CONTINUE
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,25) 'Total       ',(F2ES(MCNT,9),MCNT=1,5)
            WRITE(7,25) 'Total       ',(F2ES(MCNT,9),MCNT=1,5)
          ENDIF
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Time        '
          WRITE(7,23) 'Time        '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 219
          WRITE(6,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(7,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(6,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(7,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(6,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          WRITE(7,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 219
          WRITE(6,26) '(LS|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
          WRITE(7,26) '(LS|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
          IF(INTSYM) GOTO 219
          WRITE(6,26) '(LS|SL)     ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(7,26) '(LS|SL)     ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(6,26) '(SL|LS)     ',(MS(T2ES(MCNT,7)),MCNT=1,5)
          WRITE(7,26) '(SL|LS)     ',(MS(T2ES(MCNT,7)),MCNT=1,5)
          WRITE(6,26) '(SL|SL)     ',(MS(T2ES(MCNT,8)),MCNT=1,5)
          WRITE(7,26) '(SL|SL)     ',(MS(T2ES(MCNT,8)),MCNT=1,5)
          IF(INTSYM) GOTO 219
219       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) 'Total       ',(MS(T2ES(MCNT,9)),MCNT=1,5)
          WRITE(7,26) 'Total       ',(MS(T2ES(MCNT,9)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ENDIF
207     CONTINUE
C
C       MATRIX CONSTRUCTION STOPWATCH
        TMOR = TSTP-T1EL-TCL1-TCL2-TBR1-TBR2-TCNV-TDGN
30      FORMAT(1X,A,24X,A)
31      FORMAT(1X,A,1X,I3,16X,A)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(7, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'One-electron matrices           ',HMS(T1EL)
        WRITE(7,30) 'One-electron matrices           ',HMS(T1EL)
        IF(HMLT.NE.'BARE') THEN
          WRITE(6,30) 'Coulomb (atomic)                ',HMS(TCL1)
          WRITE(7,30) 'Coulomb (atomic)                ',HMS(TCL1)
          WRITE(6,30) 'Coulomb (many-centre)           ',HMS(TCL2)
          WRITE(7,30) 'Coulomb (many-centre)           ',HMS(TCL2)
          IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
            WRITE(6,30) 'Breit (atomic)                  ',HMS(TBR1)
            WRITE(7,30) 'Breit (atomic)                  ',HMS(TBR1)
            WRITE(6,30) 'Breit (many-centre)             ',HMS(TBR2)
            WRITE(7,30) 'Breit (many-centre)             ',HMS(TBR2)
          ENDIF
        ENDIF
        WRITE(6,30) 'Convergence acceleration        ',HMS(TCNV)
        WRITE(7,30) 'Convergence acceleration        ',HMS(TCNV)
        WRITE(6,30) 'Matrix eigenvalue problem       ',HMS(TDGN)
        WRITE(7,30) 'Matrix eigenvalue problem       ',HMS(TDGN)
        WRITE(6,30) 'Other sources                   ',HMS(TMOR)
        WRITE(7,30) 'Other sources                   ',HMS(TMOR)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(7,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(6,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(7,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       CONVERGENCE STATUS
32      FORMAT(1X,A,42X,I3)
33      FORMAT(1X,A,37X,F8.5)
34      FORMAT(1X,A,29X,1P,D16.9)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(7, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,32) 'Iteration number           ',ITER
        WRITE(7,32) 'Iteration number           ',ITER
        WRITE(6,32) 'Integral inclusion level   ',ILEV
        WRITE(7,32) 'Integral inclusion level   ',ILEV
        WRITE(6,33) 'Level shift parameter      ',SHLV
        WRITE(7,33) 'Level shift parameter      ',SHLV
        WRITE(6,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(7,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(6,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(7,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TEST FOR CONVERGENCE OR INTEGRAL CLASS UPDATE
40      FORMAT(29X,'Stage 1: (LL|LL)')
41      FORMAT(23X,'Stage 2: (LL|SS) and (SS|LL)')
42      FORMAT(23X,'Stage 3: (SS|SS) and (LS|LS)')
43      FORMAT(29X,'Stage 3: (SS|SS)')
C
C       FIVE-STRIKE RULE: IF ENERGY DIFFERENCE KEEPS INCREASING, EXIT
        IF(NMLEV(ILEV).GT.15) THEN
C
C         STORE LAST FEW ENERGY DIFFERENCE VALUES
          WE1 = WEDN(ITER-5)
          WE2 = WEDN(ITER-4)
          WE3 = WEDN(ITER-3)
          WE4 = WEDN(ITER-2)
          WE5 = WEDN(ITER-1)
          WE6 = WEDN(ITER  )
C
C         IF EACH IS SEQUENTIALLY BIGGER THAN THE LAST, EXIT
          IF(WE6.GT.WE5.AND.WE5.GT.WE4.AND.
     &       WE4.GT.WE3.AND.WE3.GT.WE2.AND.WE2.GT.WE1) THEN
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(7, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            STOP
          ENDIF
C
        ENDIF
C
C       BARE NUCLEUS APPROXIMATION: NO COULOMB INTEGRALS AND NO SCF.
        IF(HMLT.EQ.'BARE'.OR.NOCC.LE.1) GOTO 300
C
C       CURRENTLY AT STAGE 1: (LL|LL)
        IF(ILEV.EQ.1) THEN
C
C         NON-RELATIVISTIC HAMILTONIAN ONLY INVOLVES (LL|LL)
          IF(HMLT.EQ.'NORL') THEN
C
C           SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
            IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
              GOTO 300
            ENDIF
C
C         ALL OTHER HAMILTONIANS REQUIRE FURTHER INTEGRAL INCLUSIONS
          ELSE
C
C           IF STAGE 1 HAS NOT CONVERGED, ITERATE AGAIN
            IF(WEDN(ITER).GE.ENRGLV1) THEN
              SHLV = SHLEV(ILEV)
C           IF STAGE 1 HAS CONVERGED, PROCEED TO STAGE 2
            ELSEIF(WEDN(ITER).LT.ENRGLV1) THEN
              ILEV = 2
              SHLV = SHLEV(ILEV)
              IDMPKEEP = 0
              WRITE(6, *) ' '
              WRITE(7, *) ' '
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              WRITE(6,41)
              WRITE(7,41)
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              WRITE(6, *) ' '
              WRITE(7, *) ' '
            ENDIF
C
          ENDIF
C
C       CURRENTLY AT STAGE 2: (LL|SS), (SS|LL)
        ELSEIF(ILEV.EQ.2) THEN

C         IF STAGE 2 HAS CONVERGED, PROCEED TO STAGE 3
          IF(WEDN(ITER).LT.ENRGLV2) THEN
            ILEV = 3
            SHLV = SHLEV(ILEV)
            IDMPKEEP = 0
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
              WRITE(6,43)
              WRITE(7,43)
            ELSE
              WRITE(6,42)
              WRITE(7,42)
            ENDIF
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6, *) ' '
            WRITE(7, *) ' '
          ENDIF
C
C       CURRENTLY AT STAGE 3: (SS|SS), (LS|LS)
        ELSEIF(ILEV.EQ.3) THEN
C
C         SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
          IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
            GOTO 300
          ENDIF
C
        ENDIF
C
C     END LOOP OVER ITERATIONS
      ENDDO
C
C     FORCED EXIT: UNSUCCESSFUL CONVERGENCE
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(7, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      STOP
C
C     EARLY EXIT: SUCCESSFUL CONVERGENCE
300   CONTINUE
C
C**********************************************************************C
C     END OF SELF-CONSISTENT FIELD CALCULATIONS                        C
C**********************************************************************C
C
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) REPEAT('\/',36)
      WRITE(7, *) REPEAT('\/',36)
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(7, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT('/\',36)
      WRITE(7, *) REPEAT('/\',36)
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     ADDITIONAL OPTIONS AFTER CONVERGENCE (1ST ORDER P.T.)            C
C**********************************************************************C
C
998   CONTINUE
C
C     CALCULATE THE PERTUBATIVE VALUE OF THE VARIOUS QED TERMS
      IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFQ') THEN
        CALL SYSTEM_CLOCK(ICL5)
C
C       LET'S CALL THIS STAGE 4
        ILEV = 4
        SHLEV(ILEV) = SHLV
C
C       TITLE FOR CALL TO QED ROUTINES
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'QED contributions (1st order P.T.)'
        WRITE(7, *) REPEAT(' ',19),'QED contributions (1st order P.T.)'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       CALCULATE LOW-ENERGY ELECTRON SELF-INTERACTION ELEMENTS
        CALL SYSTEM_CLOCK(ICL7)
C        CALL ANMLS
        CALL SYSTEM_CLOCK(ICL8)
        T1EL = T1EL + DFLOAT(ICL8-ICL7)/RATE
        TAMX = TAMX + DFLOAT(ICL8-ICL7)/RATE
C
C       CALCULATE LOW-ENERGY ELECTRON SELF-INTERACTION ELEMENTS
        CALL SYSTEM_CLOCK(ICL7)
C       CALL SLFINT(ITER)
        CALL SYSTEM_CLOCK(ICL8)
        T1EL = T1EL + DFLOAT(ICL8-ICL7)/RATE
        TSMX = TSMX + DFLOAT(ICL8-ICL7)/RATE
C
C       CALCULATE NUCLEAR VACUUM POLARISATION ELEMENTS
        CALL SYSTEM_CLOCK(ICL7)
c        CALL UEHNUC
c        CALL WKRNUC
c        CALL KSBNUC
        CALL SYSTEM_CLOCK(ICL8)
        T1EL = T1EL + DFLOAT(ICL8-ICL7)/RATE
        TUMX = TUMX + DFLOAT(ICL8-ICL7)/RATE
C
C       GENERATE MATRIX REP OF BREIT INTERACTION
        IF(NOCC.GT.1) THEN
C
          CALL SYSTEM_CLOCK(ICL7)
C         CALL BREIT
          CALL BRTFAST
          CALL SYSTEM_CLOCK(ICL8)
          TBR2 = TBR2 + DFLOAT(ICL8-ICL7)/RATE
          TB2T = TB2T + DFLOAT(ICL8-ICL7)/RATE
C
          CALL SYSTEM_CLOCK(ICL7)
          IF(RACAH1) THEN
            DO IZ=1,NCNT
              CALL BREIT1(IZ)
            ENDDO
          ENDIF
C         CALL BREIT2
          CALL SYSTEM_CLOCK(ICL8)
C         TCR1 =        DFLOAT(ICL8-ICL7)/RATE
C         TC1T = TC1T + DFLOAT(ICL8-ICL7)/RATE
          TBR1 =        DFLOAT(ICL8-ICL7)/RATE
          TB1T = TB1T + DFLOAT(ICL8-ICL7)/RATE
C
        ENDIF
C
C       CALCULATE FRACTION OF SCREENED INTEGRALS
        DO MCNT=1,5
          DO ITT=5,9
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
CC
CC       BUILD COUPLING MATRIX
C        IF(NOPN.NE.0) THEN
C          CALL COUPLE
C        ENDIF
CC
CC       ADD BREIT MATRIX TO MOST RECENT FOCK MATRIX
C        DO I=1,NDIM
C          DO J=1,NDIM
C            FOCK(I,J) = HNUC(I,J) + HKIN(I,J) + GDIR(I,J) - GXCH(I,J)
C     &                + BDIR(I,J) - BXCH(I,J) + VANM(I,J) + VSLF(I,J)
C     &                + VUEH(I,J) + VWKR(I,J) + VKSB(I,J) + CPLE(I,J)
C     &                - QDIR(I,J) + QXCH(I,J) - WDIR(I,J) + WXCH(I,J)
C          ENDDO
C        ENDDO
CC
CC       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
C        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OVLP,MDM,EIGN,WK,LWK,RK,INF)
C        IF(INF.NE.0) THEN
C          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
C          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
C        ENDIF
CC
CC       TRANSFER EIGENVECTORS TO THE C ARRAY
C        DO J=1,NDIM
C          DO I=1,NDIM
C            COEF(I,J) = FOCK(I,J)
C          ENDDO
C        ENDDO
CC
CC       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
C        IF(ITER.EQ.1) THEN
C          DO IVIR=NSKP+NOCC+1,NDIM
C            EIGN(IVIR) = EIGN(IVIR) - SHLV
C          ENDDO
C        ENDIF
CC
CC       UPDATE EIGENVALUES AND COEFFICIENTS
C        OPEN(UNIT=8,FILE=TRIM(WFNFL)//'(+B).wfn',STATUS='UNKNOWN')
C        REWIND(UNIT=8)
C        DO I=1,NDIM
C          WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
C        ENDDO
C        CLOSE(UNIT=8)
C
C       RECALCULATE TOTAL ENERGY
        CALL ENRGIES
C
C       UPDATE TOTAL BREIT CALCULATION TIME
        CALL SYSTEM_CLOCK(ICL6)
        TBMX = DFLOAT(ICL6-ICL5)/RATE
CC
CC       SUMMARISE DIRECT AND EXCHANGE ENERGIES
C        WRITE(6,22) 'Breit direct (closed)     (BD)',EBDR
C        WRITE(7,22) 'Breit direct (closed)     (BD)',EBDR
C        WRITE(6,22) 'Breit exchange (closed)   (BX)',EBXC
C        WRITE(7,22) 'Breit exchange (closed)   (BX)',EBXC
C        WRITE(6, *) REPEAT('=',72)
C        WRITE(7, *) REPEAT('=',72)
C        WRITE(6,30) 'Total BREIT time                ',HMS(TBMX)
C        WRITE(7,30) 'Total BREIT time                ',HMS(TBMX)
C        WRITE(6, *) REPEAT('=',72)
C        WRITE(7, *) REPEAT('=',72)
CC
CC       TWO-ELECTRON CALCULATION BREAKDOWN
C        WRITE(6, *) REPEAT(' ',72)
C        WRITE(7, *) REPEAT(' ',72)
C        WRITE(6, *) REPEAT('=',72)
C        WRITE(7, *) REPEAT('=',72)
C        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
C        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
C        WRITE(6, *) REPEAT('=',72)
C        WRITE(7, *) REPEAT('=',72)
C        WRITE(6,23) '(LS|LS)     '
C        WRITE(7,23) '(LS|LS)     '
C        WRITE(6, *) REPEAT('-',72)
C        WRITE(7, *) REPEAT('-',72)
C        WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
C        WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
C        IF(SCHWRZ) THEN
C          WRITE(6,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
C          WRITE(7,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
C          WRITE(6,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
C          WRITE(7,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
C        ENDIF
C        WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
C        WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
C        WRITE(6, *) REPEAT('=',72)
C        WRITE(7, *) REPEAT('=',72)
CC
C       LEVEL ITERATIONS AND TIME
        NMLEV(4) = 1
        TMLEV(4) = TBMX
        ITER     = ITER+1
C
C       FLAG A CHANGE OF CALCULATION TREE (QED 1-BODY IN GREATER DETAIL)
C       ONLY DO THIS IF THE TREE WAS HFSCF (AND ABOUT TO END ANYWAY)
        IF(TREE.EQ.'HFSCF') THEN
          TREE = 'EXPVL'
          NHMINT = 5
          HMINT(1) = 'PANOMLS'
          HMINT(2) = 'PSLFLWB'
          HMINT(3) = 'PSLFHIF'
          HMINT(4) = 'PSLFLWA'
          HMINT(5) = 'PVACPOL'
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     SUMMARY OF CALCULATION DETAILS                                   C
C**********************************************************************C
C
C     TIME AT END OF MOLECULAR CALCULATION
      CALL SYSTEM_CLOCK(ICL2)
      TTOT = (ICL2-ICL1)/RATE
C
C     DATE AND TIME AT END OF CALCULATION
      CALL TIMENOW(STAMP)
C
C     PRINT OUT FINAL SCF RESULTS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(7, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     MOLECULAR ENERGIES
      EDIR = EGDR+EQDR+EBDR+EWDR
      EXCH = EGXC+EQXC+EBXC+EWXC
50    FORMAT(1X,A,22X,A,11X,A,14X,A)
51    FORMAT(1X,A,39X,F17.9)
151   FORMAT(1X,A,36X,ES20.9)
52    FORMAT(1X,A,1X,F17.9,2X,F17.9,2X,F17.9)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,50) 'Source','Direct','Exchange','Total'
      WRITE(7,50) 'Source','Direct','Exchange','Total'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,51) 'Nucleus-nucleus ',ENUC
      WRITE(7,51) 'Nucleus-nucleus ',ENUC
      WRITE(6,51) 'Electron-nucleus',EHNC
      WRITE(7,51) 'Electron-nucleus',EHNC
      WRITE(6,51) 'Electron kinetic',EHKN
      WRITE(7,51) 'Electron kinetic',EHKN
      IF(HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFQ') GOTO 405
      WRITE(6,51) 'Anomalous moment',EANM
      WRITE(7,51) 'Anomalous moment',EANM
      WRITE(6,51) 'Self-interaction',ESLF
      WRITE(7,51) 'Self-interaction',ESLF
      WRITE(6,51) 'Uehling nuclear ',EUEH
      WRITE(7,51) 'Uehling nuclear ',EUEH
      WRITE(6,51) 'W-Kroll nuclear ',EWKR
      WRITE(7,51) 'W-Kroll nuclear ',EWKR
      WRITE(6,51) 'Kal-Sab nuclear ',EKSB
      WRITE(7,51) 'Kal-Sab nuclear ',EKSB
405   CONTINUE
      IF(HMLT.EQ.'BARE') GOTO 400
      WRITE(6,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      WRITE(7,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      IF(NOPN.EQ.0) GOTO 410
      WRITE(6,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
      WRITE(7,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
410   CONTINUE
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 400
      WRITE(6,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      WRITE(7,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      IF(NOPN.EQ.0) GOTO 400
      WRITE(6,52) 'Breit (open)    ',EWDR,EWXC,EBRQ
      WRITE(7,52) 'Breit (open)    ',EWDR,EWXC,EBRQ
400   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(7,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     EQ-COEFFICIENT AND R-INTEGRAL ANALYSIS
53    FORMAT(1X,A,4X,A,14X,A,20X,A)
54    FORMAT(1X,A,3X,A,14X,A,A)
64    FORMAT(1X,A,3X,A)
55    FORMAT(38X,A,A)
56    FORMAT(1X,A,2X,A,33X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Eq-coefficients and R-integrals'
      WRITE(7, *) REPEAT(' ',20),'Eq-coefficients and R-integrals'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,53) 'Eq-coefficients','Time','R-integrals','Time'
      WRITE(7,53) 'Eq-coefficients','Time','R-integrals','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      WRITE(7,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      IF(HMLT.EQ.'NORL') GOTO 420
      WRITE(6,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(7,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(6,55)                  '(SS|SS)            ',HMS(TRSS)
      WRITE(7,55)                  '(SS|SS)            ',HMS(TRSS)
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 420
      WRITE(6,54) 'EILS',HMS(TELS),'(LS|LS)            ',HMS(TRBR)
      WRITE(7,54) 'EILS',HMS(TELS),'(LS|LS)            ',HMS(TRBR)
      WRITE(6,64) 'EISL',HMS(TESL)
      WRITE(7,64) 'EISL',HMS(TESL)
420   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,56) 'Total',HMS(TELL+TESS+TELS+TESL),
     &                    HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(7,56) 'Total',HMS(TELL+TESS+TELS+TESL),
     &                    HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CONVERGENCE ANALYSIS
      T1 = TMLEV(1)
      T2 = TMLEV(2)
      T3 = TMLEV(3)
      T4 = TMLEV(4)
59    FORMAT(1X,A,3X,A,16X,A,6X,A,14X,A)
60    FORMAT(1X,I1,7X,A,2X,F8.5,13X,I3,2X,A)
61    FORMAT(1X,I1,7X,A)
62    FORMAT(9X,A,2X,F8.5,13X,I3,2X,A)
63    FORMAT(1X,A,46X,I3,2X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(7, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(7,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      WRITE(7,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      IF(HMLT.EQ.'NORL') GOTO 440
      WRITE(6,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
      WRITE(7,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
      IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
        WRITE(6,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
        WRITE(7,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      ELSE
        WRITE(6,60) 3,'(SS|SS) and (LS|LS) ',SHLEV(3),NMLEV(3),HMS(T3)
        WRITE(7,60) 3,'(SS|SS) and (LS|LS) ',SHLEV(3),NMLEV(3),HMS(T3)
      ENDIF
      IF(HMLT.EQ.'DHFP') THEN
        WRITE(6,60) 4,'(LS|LS)             ',SHLEV(4),NMLEV(4),HMS(T4)
        WRITE(7,60) 4,'(LS|LS)             ',SHLEV(4),NMLEV(4),HMS(T4)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,63) 'Total',ITER,HMS(T1+T2+T3+T4)
      WRITE(7,63) 'Total',ITER,HMS(T1+T2+T3+T4)
440   CONTINUE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     HFSCF LABOUR ANALYIS
57    FORMAT(1X,A,24X,A)
58    FORMAT(1X,A,1X,25X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(7, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLT.EQ.'BARE') GOTO 530
      IF(TC1T.LT.0.1D0) GOTO 531
      TC1O = TC1T-TC1A-TC1I-TC1B-TC1R-TC1F-TC1M
      WRITE(6, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(7, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Angular coefficients            ',HMS(TC1A)
      WRITE(7,57) 'Angular coefficients            ',HMS(TC1A)
      WRITE(6,57) 'Basis function products         ',HMS(TC1I)
      WRITE(7,57) 'Basis function products         ',HMS(TC1I)
      WRITE(6,57) 'Pre-processing beta integrals   ',HMS(TC1B)
      WRITE(7,57) 'Pre-processing beta integrals   ',HMS(TC1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(6,57) 'Full two-electron integrals     ',HMS(TC1F)
      WRITE(7,57) 'Full two-electron integrals     ',HMS(TC1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(6,57) 'Other                           ',HMS(TC1O)
      WRITE(7,57) 'Other                           ',HMS(TC1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC1T)
      WRITE(7,57) 'Total                           ',HMS(TC1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
531   CONTINUE
      IF(TC2T.LT.0.1D0) GOTO 532
      TC2O = TC2T-TCLV-TC2S-TCEC-TCRM-TCRW-TCC1-TCC2-TCMC
      WRITE(6, *) REPEAT(' ',21),'Coulomb (many-centre) details'
      WRITE(7, *) REPEAT(' ',21),'Coulomb (many-centre) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(6,57) 'R-integral write                ',HMS(TCRW)
      WRITE(7,57) 'R-integral write                ',HMS(TCRW)
      WRITE(6,57) '1st contraction                 ',HMS(TCC1)
      WRITE(7,57) '1st contraction                 ',HMS(TCC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(6,57) 'Screening                       ',HMS(TC2S)
      WRITE(7,57) 'Screening                       ',HMS(TC2S)
      IF(VSDNSC) THEN
        WRITE(6,57) 'Visscher small-components       ',HMS(TCLV)
        WRITE(7,57) 'Visscher small-components       ',HMS(TCLV)
      ENDIF
      WRITE(6,57) 'Other                           ',HMS(TC2O)
      WRITE(7,57) 'Other                           ',HMS(TC2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC2T)
      WRITE(7,57) 'Total                           ',HMS(TC2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
532   CONTINUE
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 530
      IF(TB1T.LT.0.1D0) GOTO 533
      TB1O = TB1T-TB1A-TB1I-TB1B-TB1R-TB1F-TB1M
      WRITE(6, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(7, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Angular coefficients            ',HMS(TB1A)
      WRITE(7,57) 'Angular coefficients            ',HMS(TB1A)
      WRITE(6,57) 'Basis function products         ',HMS(TB1I)
      WRITE(7,57) 'Basis function products         ',HMS(TB1I)
      WRITE(6,57) 'Pre-processing beta integrals   ',HMS(TB1B)
      WRITE(7,57) 'Pre-processing beta integrals   ',HMS(TB1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(6,57) 'Full two-electron integrals     ',HMS(TB1F)
      WRITE(7,57) 'Full two-electron integrals     ',HMS(TB1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(6,57) 'Other                           ',HMS(TB1O)
      WRITE(7,57) 'Other                           ',HMS(TB1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB1T)
      WRITE(7,57) 'Total                           ',HMS(TB1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
533   CONTINUE
      IF(TB2T.LT.0.1D0) GOTO 534
      TB2O = TB2T-TB2S-TBEC-TBRM-TBRW-TBC1-TBC2-TBAX-TBMC
      WRITE(6, *) REPEAT(' ',22),'Breit (many-centre) details'
      WRITE(7, *) REPEAT(' ',22),'Breit (many-centre) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(6,57) 'R-integral write                ',HMS(TBRW)
      WRITE(7,57) 'R-integral write                ',HMS(TBRW)
      WRITE(6,57) '1st contraction                 ',HMS(TBC1)
      WRITE(7,57) '1st contraction                 ',HMS(TBC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(6,57) 'Auxilliary/normalisation factors',HMS(TBAX)
      WRITE(7,57) 'Auxilliary/normalisation factors',HMS(TBAX)
      WRITE(6,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(6,57) 'Screening                       ',HMS(TB2S)
      WRITE(7,57) 'Screening                       ',HMS(TB2S)
      WRITE(6,57) 'Other                           ',HMS(TB2O)
      WRITE(7,57) 'Other                           ',HMS(TB2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB2T)
      WRITE(7,57) 'Total                           ',HMS(TB2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
534   CONTINUE
530   CONTINUE
      TOTH = TTOT-TEPP-THMX-TAMX-TSMX-TUMX-TC1T
     &      -TC2T-TCVT-TB1T-TB2T-TACC-TEIG
      WRITE(6, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(7, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Eq-coefficient data file prep.  ',HMS(TEPP)
      WRITE(7,57) 'Eq-coefficient data file prep.  ',HMS(TEPP)
      WRITE(6,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      WRITE(7,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFQ') THEN
        WRITE(6,57) 'Electron anomalous moment       ',HMS(TAMX)
        WRITE(7,57) 'Electron anomalous moment       ',HMS(TAMX)
        WRITE(6,57) 'Electron self-interaction       ',HMS(TSMX)
        WRITE(7,57) 'Electron self-interaction       ',HMS(TSMX)
        WRITE(6,57) 'Nuclear vacuum polarisation     ',HMS(TUMX)
        WRITE(7,57) 'Nuclear vacuum polarisation     ',HMS(TUMX)
      ENDIF
      IF(HMLT.EQ.'BARE') GOTO 430
      WRITE(6,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(7,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(6,57) 'Coulomb (many-centre)           ',HMS(TC2T)
      WRITE(7,57) 'Coulomb (many-centre)           ',HMS(TC2T)
      IF(VSDNSC) THEN
        WRITE(6,57) 'Visscher small-component approx.',HMS(TCVT)
        WRITE(7,57) 'Visscher small-component approx.',HMS(TCVT)
      ENDIF
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 430
      WRITE(6,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(7,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(6,57) 'Breit (many-centre)             ',HMS(TB2T)
      WRITE(7,57) 'Breit (many-centre)             ',HMS(TB2T)
430   CONTINUE
      WRITE(6,57) 'Convergence acceleration        ',HMS(TACC)
      WRITE(7,57) 'Convergence acceleration        ',HMS(TACC)
      WRITE(6,57) 'Matrix eigenvalue problem       ',HMS(TEIG)
      WRITE(7,57) 'Matrix eigenvalue problem       ',HMS(TEIG)
      WRITE(6,57) 'Other sources                   ',HMS(TOTH)
      WRITE(7,57) 'Other sources                   ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TTOT)
      WRITE(7,57) 'Total                           ',HMS(TTOT)
      WRITE(6,58) 'Time at end of calculation',STAMP
      WRITE(7,58) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP               C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP               C
C             OO    OO   VVVV   RR    RR LL      PP                    C
C              OOOOOO     VV    RR    RR LLLLLLL PP                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP CONSTRUCTS A MOLECULAR BASIS FUNCTION OVERLAP MATRIX.         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RC(MB2,MRC),EXL(MBS,4),XYZ(3,4)
      DIMENSION KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS=+1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL6-ICL5)/RATE
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC OVERLAP CALCULATIONS COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS=+1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO OVLP.            C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC OVERLAP MATRIX COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 600
C
C     SS BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LL                    C
C              OO    OO NNN   NN EE      EE      LL                    C
C              OO    OO NNNN  NN EE      EE      LL                    C
C              OO    OO NN NN NN EEEEEE  EEEEEE  LL                    C
C              OO    OO NN  NNNN EE      EE      LL                    C
C              OO    OO NN   NNN EE      EE      LL                    C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LLLLLLL               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL CONSTRUCTS A FULL SET OF MULTI-CENTRE OVERLAP, KINETIC AND    C
C  NUCLEAR ATTRACTION BASIS FUNCTION MATRIX ELEMENTS.                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
      DIMENSION RN(MBS)
C
      COMPLEX*16 TA1,TA2
      COMPLEX*16 CTMP1,CTMP2,CTMP3,CTMP4
      COMPLEX*16 E11A,E11B,E11C,TRM11,E21A,E21B,E21C,TRM21
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4),
     &           VLL(MBS,MBS,4),VSS(MBS,MBS,4),
     &           TLL(MBS,MBS,4),TLS(MBS,MBS,4),TSL(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            SLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            SSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            TLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            TLS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            TSL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
cC
cC       ATOM-CENTRED SPECIAL CODE
c        IF(ICNTA.EQ.IZ.AND.ICNTB.EQ.IZ) THEN
cC
cC         ANGULAR SYMMETRY SELECTION RULES
c          IF(KA.NE.KB) GOTO 2500
c          IF(MA.NE.MB) GOTO 2500
cC
cC         GAUSSIAN WIDTH PARAMETER
c          GPRM = 1.5D0/(RNUC(IZ)*RNUC(IZ))
cC
cC         FERMI DISTRIBUTION PARAMETER CFMI
c          CFMI = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
c     &         - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
c          CFMI = DSQRT(CFMI)
cC
cC         NORMALISATION CONSTANTS
c          G1 = TWLG-GAMLOG(2*LQN(1)+3)
c          R1 = DFLOAT(LQN(1))+1.5D0
c          DO IBAS=1,NBAS(1)
c            ELOG     = DLOG(2.0D0*EXL(IBAS,1))
c            RN(IBAS) = DEXP(0.5D0*(G1+R1*ELOG))
c          ENDDO
cC
cC         LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
c          DO IBAS=1,NBAS(1)
c            EI = EXL(IBAS,1)
c            DO JBAS=1,NBAS(2)
c              EJ  = EXL(JBAS,2)
c              EIJ = EI+EJ
c              EL1 = EIJ**(LQN(1)+1)
cC
cC             RAW INTEGRAL DEPENDS ON NUCLEAR CHARGE MODEL
c              IF(NMDL(IZ).EQ.'POINT') THEN
c                ULL = 0.5D0*GAMHLF(2*LQN(1)+2)/EL1
c              ELSEIF(NMDL(IZ).EQ.'GAUSS') THEN
c                ULL = ERFINT0(LQN(1),EIJ,GPRM)
c              ELSEIF(NMDL(IZ).EQ.'FERMI') THEN
c                ULL = FMIINT0(LQN(1),EIJ,AFMI(IZ),CFMI)
c              ELSEIF(NMDL(IZ).EQ.'UNIFM') THEN
c                X   = 5.0D0*EIJ*RNUC(IZ)*RNUC(IZ)/3.0D0
c                FAC = 2.0D0*DSQRT(X)*X
c                GL3 = GAMLWR(2*LQN(1)+3,X)
c                GL5 = GAMLWR(2*LQN(1)+5,X)
c                GU2 = GAMUPR(2*LQN(1)+2,X)
c                ULL = 0.5D0*(GU2 + (3.0D0*X*GL3-GL5)/FAC)/EL1
c              ENDIF
cC
cC             TRANSFER INTO NUCLEAR ATTRACTION MATRIX
c              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
c     &                         - ZNUC(IZ)*RN(IBAS)*RN(JBAS)*ULL
c              VLL(IBAS,JBAS,4) = VLL(IBAS,JBAS,4)
c     &                         - ZNUC(IZ)*RN(IBAS)*RN(JBAS)*ULL
cC
c            ENDDO
c          ENDDO
cC
cC       NON-ATOM-CENTRED CODE
c        ELSE
C
C         NUCLEAR COORDINATES
          CX = BXYZ(1,IZ)
          CY = BXYZ(2,IZ)
          CZ = BXYZ(3,IZ)
C
C         GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M   = M+1
              EIJ = EXL(IBAS,1)+EXL(JBAS,2)
              PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
              PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
              PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
              CP(M,1) = CX-PX
              CP(M,2) = CY-PY
              CP(M,3) = CZ-PZ
            ENDDO
          ENDDO
C
          IF(NMDL(IZ).EQ.'POINT') THEN
C         POINT-NUCLEUS APPROXIMATION
C
C           PREPARE ELEMENTS FOR RMAKE
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               POINT-NUCLEUS EFFECTIVE PARAMETERS
                EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
                APH(M) = EIJ
                PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
              ENDDO
            ENDDO
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL SYSTEM_CLOCK(ICL1,RATE)
            CALL RMAKE(RC,CP,APH,MAXAB,LAMLL)
            CALL SYSTEM_CLOCK(ICL2)
            TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
C
C           NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                DO IAB=1,NTUVLL
                  VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                             - PNC(M)*E11(M,IAB)*RC(M,IAB)
                  VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                             - PNC(M)*E21(M,IAB)*RC(M,IAB)
                ENDDO
                VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
                VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
              ENDDO
            ENDDO
C
          ELSE
C         BEST-FIT EXPANSION
C
C           GAUSSIAN NUCLEAR ATTRACTION
            XI = XNUC(IZ,0)
            FC = FNUC(IZ,0)
C
C           PREPARE ELEMENTS FOR RMAKE
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
                EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
                ESM    = EIJ+XI
                APH(M) = EIJ*XI/ESM
                PNC(M) = 2.0D0*PI*ZNUC(IZ)*FC*DSQRT(XI/ESM)/EIJ
C
              ENDDO
            ENDDO
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL SYSTEM_CLOCK(ICL1,RATE)
            CALL RMAKE(RC,CP,APH,MAXAB,LAMLL)
            CALL SYSTEM_CLOCK(ICL2)
            TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
C
C           NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                DO IAB=1,NTUVLL
                  VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                             - PNC(M)*E11(M,IAB)*RC(M,IAB)
                  VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                             - PNC(M)*E21(M,IAB)*RC(M,IAB)
                ENDDO
                VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
                VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
              ENDDO
            ENDDO
C
C           CORRECTION FUNCTIONS FOR DETAILED NUCLEI
            IF(NNUC(IZ).LE.0) GOTO 100
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               EXPONENT COMBINATIONS
                EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C               GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
                PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
                PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
                PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C               COORDINATES OF EVALUATION
                RPX = PX-BXYZ(1,IZ)
                RPY = PY-BXYZ(2,IZ)
                RPZ = PZ-BXYZ(3,IZ)
                RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C               INITIALISE TEMPORARY STORAGE ARRAYS
                TA1 = DCMPLX(0.0D0,0.0D0)
                TA2 = DCMPLX(0.0D0,0.0D0)
C
C               CORRECTION FUNCTIONS FOR DETAILED NUCLEI
                DO IFT=1,NNUC(IZ)
C
C                 GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
                  XI = XNUC(IZ,IFT)
                  FC = FNUC(IZ,IFT)
C
C                 GAUSSIAN COMPONENT OF HGTF
                  ESM = EIJ+XI
                  E12 = PI12/DSQRT(ESM)
                  E32 = E12*E12*E12
                  ECP = EIJ*XI/ESM
                  GSS = DEXP(-ECP*RSQ)
C
C                 LOOP OVER ALL {A,B,C}
                  DO IAB=1,NTUVLL
C
C                   CARTESIAN HERMITE POLYNOMIAL VALUES
                    HALPH = HERMITE(ECP,RPX,IA(IAB))
                    HBETA = HERMITE(ECP,RPY,IB(IAB))
                    HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C                   HGTF IS A PRODUCT OF THESE
                    HABC = HALPH*HBETA*HGAMA*GSS
C
C                   MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                    TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,IAB)*HABC
                    TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,IAB)*HABC
C
                  ENDDO
C
C               END LOOP OVER NUCLEAR BASIS FOR IZ
                ENDDO
C
C               MATRIX ELEMENTS
                VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1) + TA1
                VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3) + TA2
                VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
                VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
C
C             END LOOP OVER BASIS SET PAIR
              ENDDO
            ENDDO
C
100         CONTINUE
C
C         END CONDITIONAL ON POINT/FINITE NUCLEAR TYPE
          ENDIF
cC
cC       END CONDITIONAL ON ATOM-CENTRED OR OTHER
c        ENDIF
C
C       ATOM-CENTRED SELECTION RULE SKIP POINT
2500    CONTINUE
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C     CONSTRUCT NON-RELATIVISTIC KINETIC ENERGY INTEGRALS (IOS 91)
      IF(HMLT.EQ.'NORL') THEN
        RL2 = DFLOAT(2*LQN(2)+3)
        M   = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
C
C           GAUSSIAN PRODUCT THEOREM DETAILS
            EJ  = EXL(JBAS,2)
            EIJ = EXL(IBAS,1) + EXL(JBAS,2)
            ERT = DSQRT(PI/EIJ)**3
            PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C           COORDINATES RELATIVE TO NUCLEAR CENTRE
            PBX = PX-XYZ(1,2)
            PBY = PY-XYZ(2,2)
            PBZ = PZ-XYZ(3,2)
            PB2 = PBX*PBX + PBY*PBY + PBZ*PBZ
C
            E0FC = EJ*RL2 - 2.0D0*EJ*EJ*PB2 - 3.0D0*EJ*EJ/EIJ
            E1FC = 4.0D0*EJ*EJ
C
C           TRUNCATE EXPRESSION DEPENDING ON LAMLL VALUE
C           ALL COMBINATIONS ALLOW FOR THE LAMLL = 0 MANIFOLD
            TRM11 = E0FC*E11(M,IABC(0,0,0))
            TRM21 = E0FC*E21(M,IABC(0,0,0))
C           IF LAMLL > 0 PROVIDE SECOND BUNCH OF TERMS
            IF(LAMLL.GE.1) THEN
              E11A = E11(M,IABC(1,0,0))
              E21A = E21(M,IABC(1,0,0))
              E11B = E11(M,IABC(0,1,0))
              E21B = E21(M,IABC(0,1,0))
              E11C = E11(M,IABC(0,0,1))
              E21C = E21(M,IABC(0,0,1))
              TRM11 = TRM11 - E1FC*(PBX*E11A + PBY*E11B + PBZ*E11C)
              TRM21 = TRM21 - E1FC*(PBX*E21A + PBY*E21B + PBZ*E21C)
            ENDIF
C           IF LAMLL > 1 PROVIDE FINAL BUNCH OF TERMS
            IF(LAMLL.GE.2) THEN
              E11A = E11(M,IABC(2,0,0))
              E21A = E21(M,IABC(2,0,0))
              E11B = E11(M,IABC(0,2,0))
              E21B = E21(M,IABC(0,2,0))
              E11C = E11(M,IABC(0,0,2))
              E21C = E21(M,IABC(0,0,2))
              TRM11 = TRM11 - E1FC*(E11A + E11B + E11C)
              TRM21 = TRM21 - E1FC*(E21A + E21B + E21C)
            ENDIF
            TLL(IBAS,JBAS,1) = ERT*TRM11
            TLL(IBAS,JBAS,3) = ERT*TRM21
            TLL(IBAS,JBAS,2) =-PHS*DCONJG(TLL(IBAS,JBAS,3))
            TLL(IBAS,JBAS,4) = PHS*DCONJG(TLL(IBAS,JBAS,1))
C            
          ENDDO
        ENDDO
C       NON-RELATIVISTIC HAMILTONIAN MATRICES COMPLETE
        GOTO 500
      ENDIF
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
cC
cC       ATOM-CENTRED SPECIAL CODE
c        IF(ICNTA.EQ.IZ.AND.ICNTB.EQ.IZ) THEN
cC
cC         ANGULAR SYMMETRY SELECTION RULES
c          IF(KA.NE.KB) GOTO 2600
c          IF(MA.NE.MB) GOTO 2600
cC
cC         ORBITAL TERM
c          TL = DFLOAT(2*LQN(1)+1)
cC
cC         GAUSSIAN WIDTH PARAMETER
c          GPRM = 1.5D0/(RNUC(IZ)*RNUC(IZ))
cC
cC         FERMI DISTRIBUTION PARAMETER CFMI
c          CFMI = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
c     &         - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
c          CFMI = DSQRT(CFMI)
cC
cC         NORMALISATION CONSTANTS
c          G2 = TWLG-GAMLOG(2*LQN(1)+5)
c          R2 = LQN(1)+0.5D0
c          DO IBAS=1,NBAS(1)
c            ELOG     = DLOG(2.0D0*EXL(IBAS,1))
c            RN(IBAS) = DEXP(0.5D0*(G2+R2*ELOG))
c          ENDDO
cC
cC         LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
c          DO IBAS=1,NBAS(1)
c            EI = EXL(IBAS,1)
c            DO JBAS=1,NBAS(2)
c              EJ  = EXL(JBAS,2)
c              EIJ = EI+EJ
c              EL0 = EIJ**(LQN(1))
c              EL2 = EIJ**(LQN(1)+2)
c              EPR = EI*EJ
cC
cC             FIRST RAW INTEGRAL DEPENDS ON NUCLEAR CHARGE MODEL
c              IF(NMDL(IZ).EQ.'POINT') THEN
c                VSA = 2.0D0*EPR*GAMHLF(2*LQN(1)+4)/EL2
c              ELSEIF(NMDL(IZ).EQ.'GAUSS') THEN
c                VSA = 4.0D0*EPR*ERFINT0(LQN(1)+1,EIJ,GPRM)
c              ELSEIF(NMDL(IZ).EQ.'FERMI') THEN
c                VSA = 4.0D0*EPR*FMIINT0(LQN(1)+1,EIJ,AFMI(IZ),CFMI)
c              ELSEIF(NMDL(IZ).EQ.'UNIFM') THEN
c                X   = 5.0D0*EIJ*RNUC(IZ)*RNUC(IZ)/3.0D0
c                FAC = 2.0D0*DSQRT(X)*X
c                GL5 = GAMLWR(2*LQN(1)+5,X)
c                GL7 = GAMLWR(2*LQN(1)+7,X)
c                GU4 = GAMUPR(2*LQN(1)+4,X)
c                VSA = 2.0D0*EPR*(GU4 + (3.0D0*X*GL5 - GL7)/FAC)/EL2
c              ENDIF
cC
cC             SECOND RAW INTEGRAL DEPENDS ON NUCLEAR CHARGE AND PARITY
c              IF(KQN(1).LT.0) THEN
c                VSN = 0.0D0
c              ELSE
c                IF(NMDL(IZ).EQ.'POINT') THEN
c                  VSN = 0.5D0*GAMHLF(2*LQN(1))*TL/EL0
c                ELSEIF(NMDL(IZ).EQ.'GAUSS') THEN
c                  VSN =-2.0D0*EIJ*TL*ERFINT0(LQN(1)  ,EIJ,GPRM)
c     &                        +TL*TL*ERFINT0(LQN(1)-1,EIJ,GPRM)
c                ELSEIF(NMDL(IZ).EQ.'FERMI') THEN
c                  VSN =-2.0D0*EIJ*TL*FMIINT0(LQN(1)  ,EIJ,AFMI(IZ),CFMI)
c     &                        +TL*TL*FMIINT0(LQN(1)-1,EIJ,AFMI(IZ),CFMI)
c                ELSEIF(NMDL(IZ).EQ.'UNIFM') THEN
c                  X   = 5.0D0*EIJ*RNUC(IZ)*RNUC(IZ)/3.0D0
c                  FAC = 2.0D0*DSQRT(X)*X
c                  GL1 = GAMLWR(2*LQN(1)+1,X)
c                  GL3 = GAMLWR(2*LQN(1)+3,X)
c                  GL5 = GAMLWR(2*LQN(1)+5,X)
c                  GU0 = GAMUPR(2*LQN(1)  ,X)
c                  GU2 = GAMUPR(2*LQN(1)+2,X)
c                  VSN =-GU2 - (3.0D0*X*GL3-GL5)/FAC
c     &                + 0.5D0*TL*(GU0 + (3.0D0*X*GL1 - GL3)/FAC)
c                  VSN = TL*VSN/EL0
c                ENDIF
c              ENDIF
cC
cC             SUM OF RAW INTEGRALS
c              USS = VSA+VSN
cC
cC             TRANSFER INTO NUCLEAR ATTRACTION MATRIX
c              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
c     &                         - ZNUC(IZ)*RN(IBAS)*RN(JBAS)*USS
c              VSS(IBAS,JBAS,4) = VSS(IBAS,JBAS,4)
c     &                         - ZNUC(IZ)*RN(IBAS)*RN(JBAS)*USS
cC
c            ENDDO
c          ENDDO
cC
cC       NON-ATOM-CENTRED CODE
c        ELSE
C
C         NUCLEAR COORDINATES
          CX = BXYZ(1,IZ)
          CY = BXYZ(2,IZ)
          CZ = BXYZ(3,IZ)
C
C         GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M   = M+1
              EIJ = EXL(IBAS,1)+EXL(JBAS,2)
              PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
              PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
              PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
              CP(M,1) = CX-PX
              CP(M,2) = CY-PY
              CP(M,3) = CZ-PZ
            ENDDO
          ENDDO
C
          IF(NMDL(IZ).EQ.'POINT') THEN
C         POINT-NUCLEUS APPROXIMATION
C
C           PREPARE ELEMENTS FOR RMAKE
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               POINT-NUCLEUS EFFECTIVE PARAMETERS
                EIJ = EXL(IBAS,1)+EXL(JBAS,2)
                APH(M) = EIJ
                PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
              ENDDO
            ENDDO
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL SYSTEM_CLOCK(ICL1,RATE)
            CALL RMAKE(RC,CP,APH,MAXAB,LAMSS)
            CALL SYSTEM_CLOCK(ICL2)
            TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
C
C           NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ESS0 AND RC)
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                DO IAB=1,NTUVSS
                  VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                             - PNC(M)*E11(M,IAB)*RC(M,IAB)
                  VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                             - PNC(M)*E21(M,IAB)*RC(M,IAB)
                ENDDO
                VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
                VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
              ENDDO
            ENDDO
C
          ELSE
C         BEST-FIT EXPANSION
C
C           GAUSSIAN NUCLEAR ATTRACTION
            XI = XNUC(IZ,0)
            FC = FNUC(IZ,0)
C
C           PREPARE ELEMENTS FOR RMAKE
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
                EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
                ESM    = EIJ+XI
                APH(M) = EIJ*XI/ESM
                PNC(M) = 2.0D0*PI*ZNUC(IZ)*FC*DSQRT(XI/ESM)/EIJ
C
              ENDDO
            ENDDO
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL SYSTEM_CLOCK(ICL1,RATE)
            CALL RMAKE(RC,CP,APH,MAXAB,LAMSS)
            CALL SYSTEM_CLOCK(ICL2)
            TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
C
C           NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ESS0 AND RC)
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                DO IAB=1,NTUVSS
                  VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                             - PNC(M)*E11(M,IAB)*RC(M,IAB)
                  VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                             - PNC(M)*E21(M,IAB)*RC(M,IAB)
                ENDDO
                VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
                VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
              ENDDO
            ENDDO
C
C           CORRECTION FUNCTIONS FOR DETAILED NUCLEI
            IF(NNUC(IZ).LE.0) GOTO 200
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               EXPONENT COMBINATIONS
                EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C               GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
                PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
                PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
                PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C               COORDINATES OF EVALUATION
                RPX = PX-BXYZ(1,IZ)
                RPY = PY-BXYZ(2,IZ)
                RPZ = PZ-BXYZ(3,IZ)
                RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C               INITIALISE TEMPORARY STORAGE ARRAYS
                TA1 = DCMPLX(0.0D0,0.0D0)
                TA2 = DCMPLX(0.0D0,0.0D0)
C
C               CORRECTION FUNCTIONS FOR DETAILED NUCLEI
                DO IFT=1,NNUC(IZ)
C
C                 GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
                  XI = XNUC(IZ,IFT)
                  FC = FNUC(IZ,IFT)
C
C                 GAUSSIAN COMPONENT OF HGTF
                  ESM = EIJ+XI
                  ECP = EIJ*XI/ESM
                  GSS = DEXP(-ECP*RSQ)
                  E12 = PI12/DSQRT(ESM)
                  E32 = E12*E12*E12
C
C                 LOOP OVER ALL {A,B,C}
                  DO IAB=1,NTUVSS
C
C                   CARTESIAN HERMITE POLYNOMIAL VALUES
                    HALPH = HERMITE(ECP,RPX,IA(IAB))
                    HBETA = HERMITE(ECP,RPY,IB(IAB))
                    HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C                   HGTF IS A PRODUCT OF THESE
                    HABC = HALPH*HBETA*HGAMA*GSS
C
C                   MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                    TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,IAB)*HABC
                    TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,IAB)*HABC
C
                  ENDDO
C
C               END LOOP OVER NUCLEAR BASIS FOR IZ
                ENDDO
C
C               MATRIX ELEMENTS
                VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1) + TA1
                VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3) + TA2
                VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
                VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
C
C             END LOOP OVER BASIS SET PAIR
              ENDDO
            ENDDO
C
200         CONTINUE
C
C         END CONDITIONAL ON POINT/FINITE NUCLEAR TYPE
          ENDIF
cC
cC       END CONDITIONAL ON ATOM-CENTRED OR OTHER
c        ENDIF
C
C       ATOM-CENTRED SELECTION RULE SKIP POINT
2600    CONTINUE
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C     SUBTRACT THE SS OVERLAP MATRIX AND FINISH CONSTRUCTION
      CV2 = 2.0D0*EMSS*CV*CV
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1) - CV2*SSS(IBAS,JBAS,1)
          VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3) - CV2*SSS(IBAS,JBAS,3)
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 3: THE SL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(2)+3))
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ    = EXL(IBAS,1) + EXL(JBAS,2)
          EJRT   = FACT*DSQRT(EXL(JBAS,2))
          EROOT  = DSQRT(PI/EIJ)**3
          TSL(IBAS,JBAS,1) = EJRT*EROOT*E11(M,1)
          TSL(IBAS,JBAS,3) = EJRT*EROOT*E21(M,1)
          TSL(IBAS,JBAS,2) =-PHS*DCONJG(TSL(IBAS,JBAS,3))
          TSL(IBAS,JBAS,4) = PHS*DCONJG(TSL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C
C**********************************************************************C
C     PART 4: THE LS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     TODO: THE INDEX SWAP '2 1' MAKES FILE IMPORT ANNOYING. I'M LAZY.
C             JUST GENERATE THESE EQ'S AS A BATCH (DOESN'T TAKE LONG).
C
C     IF(EQFILE) THEN
C       DO IAB=1,NTUVSS
C         IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
C         M = 0
C         DO IBAS=1,NBAS(1)
C           DO JBAS=1,NBAS(2)
C             M = M+1
C             N = (JBAS-1)*NBAS(2) + IBAS
C             PI^{SL}_{IJ} = PI^{LS}_{JI}* (THE NEXT LINES ARE WRONG)
C             E11(M,IAB) = DCMPLX(E0SSFL(IAD+N,1),-E0SSFL(IAD+N,2))
C             E21(M,IAB) = DCMPLX(E0SSFL(IAD+N,3),-E0SSFL(IAD+N,4))
C           ENDDO
C         ENDDO
C       ENDDO
C     ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,2,1,0)
C     ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(1)+3))
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M+1
          EIJ    = EXL(JBAS,2) + EXL(IBAS,1)
          EIRT   = FACT*DSQRT(EXL(IBAS,1))
          EROOT  = DSQRT(PI/EIJ)**3
          TLS(IBAS,JBAS,1) = EIRT*EROOT*E11(M,1)
          TLS(IBAS,JBAS,3) = EIRT*EROOT*E21(M,1)
          TLS(IBAS,JBAS,2) =-PHS*DCONJG(TLS(IBAS,JBAS,3))
          TLS(IBAS,JBAS,4) = PHS*DCONJG(TLS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     GENERATE LS MATRICES FROM THE ABOVE SL MATRICES
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M + 1
          CTMP1 = DCONJG(TLS(IBAS,JBAS,1))
          CTMP2 = DCONJG(TLS(IBAS,JBAS,2))
          CTMP3 = DCONJG(TLS(IBAS,JBAS,3))
          CTMP4 = DCONJG(TLS(IBAS,JBAS,4))
C
          TLS(IBAS,JBAS,1) = CTMP1
          TLS(IBAS,JBAS,2) = CTMP3
          TLS(IBAS,JBAS,3) = CTMP2
          TLS(IBAS,JBAS,4) = CTMP4
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF HNUC AND HKIN FOR THIS BLOCK.          C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LL NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC HAMILTONIAN HAS A KINETIC MATRIX IN THE LL BLOCK
      IF(HMLT.EQ.'NORL') THEN
C
C       LL KINETIC BLOCKS
        IF(IL1.GT.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=1,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
        IF(IL1.EQ.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=JBAS,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
        GOTO 600
C
      ENDIF
C
C     SS OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SS NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LS BLOCKS
      IF(IL1.GE.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IL1+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,1)
            HKIN(IL1+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,2)
            HKIN(IL2+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,3)
            HKIN(IL2+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,4)
C
            HKIN(JS1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS2+JBAS))
            HKIN(JS1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IS1+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,1)
            HKIN(IS1+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,2)
            HKIN(IS2+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,3)
            HKIN(IS2+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,4)
C
            HKIN(JL1+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL2+JBAS))
            HKIN(JL1+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
C     END LOOPS OVER BASIS PAIRS A,B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ANMLS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               AA    NN    NN MM       MM LL       SSSSSS             C
C              AAAA   NNN   NN MMM     MMM LL      SS    SS            C
C             AA  AA  NNNN  NN MMMM   MMMM LL      SS                  C
C            AA    AA NN NN NN MM MM MM MM LL       SSSSSS             C
C            AAAAAAAA NN  NNNN MM  MMM  MM LL            SS            C
C            AA    AA NN   NNN MM   M   MM LL      SS    SS            C
C            AA    AA NN    NN MM       MM LLLLLLLL SSSSSS             C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANMLS CONSTRUCTS THE MULTI-CENTRE MATRIX ELEMENTS FOR THE ANOMALOUS C
C  ELECTRON MAGNETIC DIPOLE MOMENT COUPLED TO THE NUCLEAR E-FIELD.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      COMPLEX*16 VIJ(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VANM(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     AMPLITUDE FOR ELECTRON ANOMALOUS MAGNETIC MOMENT TERM (B&S 19.3)
      AG1 =-1.0D0/(4.0D0*PI*EMSS*CV*CV)
C
C     LOOP OVER ALL NUCLEAR CENTRES
      DO IZ=1,NCNT
C                                                             ⇀ ⇀
C       LOOP OVER ALL CARTESIAN COMPONENTS OF THE DOT PRODUCT α.E
        DO IX=1,3
C
C         THE LS COMPONENT
          CALL VNCELEC(VIJ,IZ,2,IX,IX,1,2)
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
              VANM(I,J+NSKP) = VANM(I,J+NSKP) + AG1*ZNUC(IZ)*VIJ(I,J)
            ENDDO
          ENDDO
C
C         THE SL COMPONENT
          CALL VNCELEC(VIJ,IZ,3,IX,IX,1,2)
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
              VANM(I+NSKP,J) = VANM(I+NSKP,J) + AG1*ZNUC(IZ)*VIJ(I,J)
            ENDDO
          ENDDO
C
C       END LOOP OVER CARTESIAN COMPONENTS
        ENDDO
C
C     END LOOP OVER NUCLEAR CENTRES
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE SLFINT(ITER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           SSSSSS  LL       FFFFFFFF IIII NN    NN TTTTTTTT           C
C          SS    SS LL       FF        II  NNN   NN    TT              C
C          SS       LL       FF        II  NNNN  NN    TT              C
C           SSSSSS  LL       FFFFFF    II  NN NN NN    TT              C
C                SS LL       FF        II  NN  NNNN    TT              C
C          SS    SS LL       FF        II  NN   NNN    TT              C
C           SSSSSS  LLLLLLLL FF       IIII NN    NN    TT              C
C                                                                      C
C -------------------------------------------------------------------- C
C  SLFINT CONSTRUCTS THE MULTI-CENTRE ELECTRON SELF-INTERACTION        C
C  MATRIX ELEMENTS BASED ON THE LOW-ENERGY QUINEY MODEL 2019.          C
C -------------------------------------------------------------------- C
C ▶ THE `LL' COMPONENT OF THIS CAN BE USED IN THE 'NORL' TREE OPTION,  C
C   BUT THE INPUT DECK ASSUMES THAT 'DHFQ' IMPLIES RELATIVISTIC.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      COMPLEX*16 DOT
      COMPLEX*16 VIJ(MDM,MDM)
      COMPLEX*16 OLSX(MDM,MDM),OLSY(MDM,MDM),OLSZ(MDM,MDM),
     &           OSLX(MDM,MDM),OSLY(MDM,MDM),OSLZ(MDM,MDM)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
      COMPLEX*16 BTHE(MDM,MDM),CNTC(MDM,MDM)
      COMPLEX*16 OPRJ(MDM,MDM),ELWM(MDM)
      COMPLEX*16 PINX(MDM,MDM),PINY(MDM,MDM),PINZ(MDM,MDM)
      COMPLEX*16 PMNX(MDM,MDM),PMNY(MDM,MDM),PMNZ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/OTTI/OLSX,OLSY,OLSZ,OSLX,OSLY,OSLZ
C
      DATA DEPS/0.01D0/
C
C     CUTOFF PARAMETER (Zα)^2*mc < CUTK < mc
C
C     MAXIMUM NUCLEAR CHARGE IN MOLECULE (IMPORTANT FOR OTHER CUTK VALS)
      ZMAX = 0.0D0
      DO IZ=1,NCNT
        IF(ZNUC(IZ).GT.ZMAX) THEN
          ZMAX = ZNUC(IZ)
        ENDIF
      ENDDO
      CUTK = ZMAX*ZMAX/CV
C
C     DFNOTE: HARRY SAYS JUST MAKE THE CUTOFF ENERGY M*CV*CV FOR NOW
      CUTK = CV
C
C     AMPLITUDE FOR FREE-WAVE SELF-INTERACTION TERM (B&S 19.3)
      AG2 = (DLOG(EMSS*CV/CUTK)-TWLG+11.0D0/24.0D0)/(3.0D0*CV*PI)
      AG2 =-AG2/(EMSS*EMSS*CV*CV)
C
C     AMPLITUDE FOR LOW-ENERGY CONTRIBUTION
      ALW =-2.0D0/(3.0D0*PI*CV)
C
C**********************************************************************C
C     LOW-ENERGY BETHE FORMULA E_{<} (IOCC) = <IOCC|Γ|IOCC>.           C
C**********************************************************************C
C
C     GENERATE ALL NECESSARY OVERLAP INTEGRALS
      IF(ITER.EQ.1.OR.ILEV.EQ.4) THEN
        CALL VMOMNT0(OLSX,2,1,1,2)
        CALL VMOMNT0(OLSY,2,2,1,2)
        CALL VMOMNT0(OLSZ,2,3,1,2)
        CALL VMOMNT0(OSLX,3,1,1,2)
        CALL VMOMNT0(OSLY,3,2,1,2)
        CALL VMOMNT0(OSLZ,3,3,1,2)
      ENDIF
C
C     INITIALISE INTERMEDIATE STORAGE ARRAYS
      DO I=1,NDIM
        DO N=1,NDIM
          PINX(I,N) = DCMPLX(0.0D0,0.0D0)
          PINY(I,N) = DCMPLX(0.0D0,0.0D0)
          PINZ(I,N) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CONTRACT ON ALL POSITIVE-ENERGY STATES -> PINX,PINY,PINZ
      DO NPSV=1,NDIM-NSKP
C
C       LOOP OVER BASIS FUNCTIONS I
        DO I=1,NDIM-NSKP
C
C         SMALL-COMPONENT ADDRESS
          K = I+NSKP
C
C         CONTRACT OVER THIS INDEX FOR ALL POSITIVE-ENERGY STATES N
          DO J=1,NDIM-NSKP
C
C           SMALL-COMPONENT ADDRESS
            L = J+NSKP
C
C           COUPLE OLS ELEMENTS WITH SMALL-COMPONENT COEFFICIENTS
            PINX(I,NPSV) = PINX(I,NPSV) + COEF(L,NPSV+NSKP)*OLSX(I,J)
            PINY(I,NPSV) = PINY(I,NPSV) + COEF(L,NPSV+NSKP)*OLSY(I,J)
            PINZ(I,NPSV) = PINZ(I,NPSV) + COEF(L,NPSV+NSKP)*OLSZ(I,J)
C
C           COUPLE OSL ELEMENTS WITH LARGE-COMPONENT COEFFICIENTS
            PINX(K,NPSV) = PINX(K,NPSV) + COEF(J,NPSV+NSKP)*OSLX(I,J)
            PINY(K,NPSV) = PINY(K,NPSV) + COEF(J,NPSV+NSKP)*OSLY(I,J)
            PINZ(K,NPSV) = PINZ(K,NPSV) + COEF(J,NPSV+NSKP)*OSLZ(I,J)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     INITIALISE INTERMEDIATE STORAGE ARRAYS
      DO IOCC=1,NDIM
        DO NPSV=1,NDIM
          PMNX(IOCC,NPSV) = DCMPLX(0.0D0,0.0D0)
          PMNY(IOCC,NPSV) = DCMPLX(0.0D0,0.0D0)
          PMNZ(IOCC,NPSV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CONTRACT ON ALL OCCUPIED-ENERGY STATES -> PMNX,PMNY,PMNZ
      DO IOCC=1,NOCC
C
C       LOOP OVER ENTIRE POSITIVE-ENERGY SPECTRUM
        DO NPSV=1,NDIM-NSKP
C
C         CONTRACT OVER THIS INDEX FOR ALL POSITIVE-ENERGY STATES N
          DO I=1,NDIM
            PMNX(IOCC,NPSV) = PMNX(IOCC,NPSV)
     &                      + DCONJG(COEF(I,IOCC+NSKP))*PINX(I,NPSV)
            PMNY(IOCC,NPSV) = PMNY(IOCC,NPSV)
     &                      + DCONJG(COEF(I,IOCC+NSKP))*PINY(I,NPSV)
            PMNZ(IOCC,NPSV) = PMNZ(IOCC,NPSV)
     &                      + DCONJG(COEF(I,IOCC+NSKP))*PINZ(I,NPSV)
          ENDDO
C
        ENDDO
      ENDDO
C
C     INITIALISE STORAGE ARRAY FOR SELF-ENERGY BY OCCUPIED ORBITAL
      DO IOCC=1,NDIM
        ELWM(IOCC) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     CONSTRUCT FINISHED MATRIX ELMENTS FOR EACH OCCUPIED M
      DO IOCC=1,NOCC
C
C       INITIALISE THE FINAL COUNTER
        ELWM(IOCC) = DCMPLX(0.0D0,0.0D0)
C
C       STATE ENERGY FOR M
        EI = EIGN(IOCC+NSKP)
C
C       LOOP OVER POSITIVE-ENERGY STATES N
        DO NPSV=1,NDIM-NSKP
C
C         STATE ENERGY FOR N
          EN = EIGN(NPSV+NSKP)
C
C         ENERGY DIFFERENCE
          DEIN = EI-EN
C
C         MANUALLY SKIP CASES OF DEGENERATE ENERGY LEVELS
          IF(DABS(DEIN).GT.DEPS) THEN
C
C           LOGARITHMIC ENERGY TERM
            DTRM = (CV*CUTK-DEIN)/DABS(DEIN)
            DTRM = DEIN*DLOG(DTRM)
C
C           VECTOR DOT PRODUCT OF TRANSITION CURRENTS
            DOT = PMNX(IOCC,NPSV)*DCONJG(PMNX(IOCC,NPSV))
     &          + PMNY(IOCC,NPSV)*DCONJG(PMNY(IOCC,NPSV))
     &          + PMNZ(IOCC,NPSV)*DCONJG(PMNZ(IOCC,NPSV))
C
C           MATRIX ELEMENT
            ELWM(IOCC) = ELWM(IOCC) + ALW*DOT*DTRM
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     APPLY PROJECTION OPERATOR TO GENERATE VSLF (MEAN-FIELD)          C
C**********************************************************************C
C
C     NEW SET OF PROJECTED OVERLAP MATRICES
      DO I=1,NDIM
        DO IOCC=1,NOCC
          OPRJ(I,IOCC) = DCMPLX(0.0D0,0.0D0)
          DO J=1,NDIM
            OPRJ(I,IOCC) = OPRJ(I,IOCC) + COEF(J,IOCC+NSKP)*OVLP(I,J)
          ENDDO
        ENDDO
      ENDDO
C
C     COUPLE THE LOW-ENERGY <IOCC|Γ|IOCC>
      DO I=1,NDIM
        DO J=1,NDIM
          BTHE(I,J) = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NOCC
            BTHE(I,J) = BTHE(I,J)
     &                + DCONJG(OPRJ(I,IOCC))*ELWM(IOCC)*OPRJ(J,IOCC)
          ENDDO
        ENDDO
      ENDDO
C
201   CONTINUE
C
C**********************************************************************C
C     HIGH-ENERGY (NUCLEAR CONTACT) CONTRIBUTION                       C
C**********************************************************************C
C
      IF(ITER.NE.1.AND.ILEV.LT.4) GOTO 301
C
C     INITIALISE HIGH-ENERGY SELF-INTERACTION MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          CNTC(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER ALL NUCLEAR CENTRES
      DO IZ=1,NCNT
C
C       LARGE-LARGE CONTRIBUTION (FACTOR -4π FROM POISSON'S EQUATION)
        CALL VNCOLAP(VIJ,IZ,1,0,1,2)
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            CNTC(I,J) = CNTC(I,J) - AG2*4.0D0*PI*ZNUC(IZ)*VIJ(I,J)
          ENDDO
        ENDDO
C
C       SMALL-SMALL CONTRIBUTION (FACTOR -4π FROM POISSON'S EQUATION)
        CALL VNCOLAP(VIJ,IZ,4,0,1,2)
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            K = I+NSKP
            L = J+NSKP
            CNTC(K,L) = CNTC(K,L) - AG2*4.0D0*PI*ZNUC(IZ)*VIJ(I,J)
          ENDDO
        ENDDO
C
C     END LOOP OVER NUCLEAR CENTRES
      ENDDO
C
301   CONTINUE
C
C**********************************************************************C
C     TOTAL MATRIX VSLF                                                C
C**********************************************************************C
C
      DO I=1,NDIM
        DO J=1,NDIM
          VSLF(I,J) = BTHE(I,J)+CNTC(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE UEHNUC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        UU    UU EEEEEEEE HH    HH NN    NN UU    UU  CCCCCC          C
C        UU    UU EE       HH    HH NNN   NN UU    UU CC    CC         C
C        UU    UU EE       HH    HH NNNN  NN UU    UU CC               C
C        UU    UU EEEEEE   HHHHHHHH NN NN NN UU    UU CC               C
C        UU    UU EE       HH    HH NN  NNNN UU    UU CC               C
C        UU    UU EE       HH    HH NN   NNN UU    UU CC    CC         C
C         UUUUUU  EEEEEEEE HH    HH NN    NN  UUUUUU   CCCCCC          C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHNUC CONSTRUCTS A FULL SET OF MULTI-CENTRE VACUUM POLARISATION    C
C  MATRIX ELEMENTS BASED ON POLARISATION OF NUCLEI AND THE UEHLING     C
C  INTERACTION TO FIRST ORDER.                                         C
C -------------------------------------------------------------------- C
C ▶ THE `LL' COMPONENT OF THIS CAN BE USED IN THE 'NORL' TREE OPTION,  C
C   BUT THE INPUT DECK ASSUMES THAT 'DHFQ' IMPLIES RELATIVISTIC.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BUEH/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMLL VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A UEHLING POTENTIAL
          DO IZ=1,NCNT
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE UEHLING POTENTIAL EXPANSION FOR IZ
            DO IFT=1,NUEH(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XUEH(IZ,IFT)
              FC = FUEH(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUVLL
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,IAB)*HABC
                TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,IAB)*HABC
C
              ENDDO
C
C
C           END LOOP OVER UEHLING EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VLL(IBAS,JBAS,1) = TA1
          VLL(IBAS,JBAS,3) = TA2
          VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
          VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMSS VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A UEHLING POTENTIAL
          DO IZ=1,NCNT
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE UEHLING POTENTIAL EXPANSION FOR IZ
            DO IFT=1,NUEH(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XUEH(IZ,IFT)
              FC = FUEH(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUVSS
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,IAB)*HABC
                TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,IAB)*HABC
C
              ENDDO
C
C
C           END LOOP OVER UEHLING EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VSS(IBAS,JBAS,1) = TA1
          VSS(IBAS,JBAS,3) = TA2
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF VUEH FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
C
C     SS UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     END LOOPS OVER BASIS PAIRS A,B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE WKRNUC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      WW        WW KK    KK RRRRRRR  NN    NN UU    UU  CCCCCC        C
C      WW        WW KK   KK  RR    RR NNN   NN UU    UU CC    CC       C
C      WW   WW   WW KK  KK   RR    RR NNNN  NN UU    UU CC             C
C      WW  WWWW  WW KKKKK    RR    RR NN NN NN UU    UU CC             C
C      WW WW  WW WW KK  KK   RRRRRRR  NN  NNNN UU    UU CC             C
C      WWWW    WWWW KK   KK  RR    RR NN   NNN UU    UU CC    CC       C
C      WW        WW KK    KK RR    RR NN    NN  UUUUUU   CCCCCC        C
C                                                                      C
C -------------------------------------------------------------------- C
C  WKRNUC CONSTRUCTS A FULL SET OF MULTI-CENTRE VACUUM POLARISATION    C
C  MATRIX ELEMENTS BASED ON POLARISATION OF NUCLEI AND THE             C
C  WICHMANN-KROLL INTERACTION TO FIRST ORDER.                          C
C -------------------------------------------------------------------- C
C ▶ THE `LL' COMPONENT OF THIS CAN BE USED IN THE 'NORL' TREE OPTION,  C
C   BUT THE INPUT DECK ASSUMES THAT 'DHFQ' IMPLIES RELATIVISTIC.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BWKR/RWKR(MCT,3),FWKR(MCT,MFT),XWKR(MCT,MFT),NWKR(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VWKR(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMLL VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A WICHMANN-KROLL POTENTIAL
          DO IZ=1,NCNT
C
C           NUCLEAR CHARGE FACTOR
            Z3 = ZNUC(IZ)*ZNUC(IZ)*ZNUC(IZ)
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE WICHMANN-KROLL EXPANSION FOR IZ
            DO IFT=1,NWKR(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XWKR(IZ,IFT)
              FC = FWKR(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUVLL
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + Z3*FC*E32*E11(M,IAB)*HABC
                TA2 = TA2 + Z3*FC*E32*E21(M,IAB)*HABC
C
              ENDDO
C
C
C           END LOOP OVER WICHMANN-KROLL EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VLL(IBAS,JBAS,1) = TA1
          VLL(IBAS,JBAS,3) = TA2
          VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
          VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMSS VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A WICHMANN-KROLL POTENTIAL
          DO IZ=1,NCNT
C
C           NUCLEAR CHARGE FACTOR
            Z3 = ZNUC(IZ)*ZNUC(IZ)*ZNUC(IZ)
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE WICHMANN-KROLL EXPANSION FOR IZ
            DO IFT=1,NWKR(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XWKR(IZ,IFT)
              FC = FWKR(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUVSS
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + Z3*FC*E32*E11(M,IAB)*HABC
                TA2 = TA2 + Z3*FC*E32*E21(M,IAB)*HABC
C
              ENDDO
C
C
C           END LOOP OVER WICHMANN-KROLL EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VSS(IBAS,JBAS,1) = TA1
          VSS(IBAS,JBAS,3) = TA2
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF VWKR FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL WICHMANN-KROLL INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VWKR(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VWKR(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VWKR(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VWKR(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VWKR(JL1+JBAS,IL1+IBAS) = DCONJG(VWKR(IL1+IBAS,JL1+JBAS))
            VWKR(JL2+JBAS,IL1+IBAS) = DCONJG(VWKR(IL1+IBAS,JL2+JBAS))
            VWKR(JL1+JBAS,IL2+IBAS) = DCONJG(VWKR(IL2+IBAS,JL1+JBAS))
            VWKR(JL2+JBAS,IL2+IBAS) = DCONJG(VWKR(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VWKR(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VWKR(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VWKR(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VWKR(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VWKR(JL1+JBAS,IL1+IBAS) = DCONJG(VWKR(IL1+IBAS,JL1+JBAS))
            VWKR(JL2+JBAS,IL1+IBAS) = DCONJG(VWKR(IL1+IBAS,JL2+JBAS))
            VWKR(JL1+JBAS,IL2+IBAS) = DCONJG(VWKR(IL2+IBAS,JL1+JBAS))
            VWKR(JL2+JBAS,IL2+IBAS) = DCONJG(VWKR(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
C
C     SS WICHMANN-KROLL INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VWKR(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VWKR(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VWKR(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VWKR(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VWKR(JS1+JBAS,IS1+IBAS) = DCONJG(VWKR(IS1+IBAS,JS1+JBAS))
            VWKR(JS2+JBAS,IS1+IBAS) = DCONJG(VWKR(IS1+IBAS,JS2+JBAS))
            VWKR(JS1+JBAS,IS2+IBAS) = DCONJG(VWKR(IS2+IBAS,JS1+JBAS))
            VWKR(JS2+JBAS,IS2+IBAS) = DCONJG(VWKR(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VWKR(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VWKR(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VWKR(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VWKR(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VWKR(JS1+JBAS,IS1+IBAS) = DCONJG(VWKR(IS1+IBAS,JS1+JBAS))
            VWKR(JS2+JBAS,IS1+IBAS) = DCONJG(VWKR(IS1+IBAS,JS2+JBAS))
            VWKR(JS1+JBAS,IS2+IBAS) = DCONJG(VWKR(IS2+IBAS,JS1+JBAS))
            VWKR(JS2+JBAS,IS2+IBAS) = DCONJG(VWKR(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     END LOOPS OVER BASIS PAIRS A,B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE KSBNUC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         KK    KK SSSSSS  BBBBBBB  NN    NN UU    UU  CCCCCC          C
C         KK   KK SS    SS BB    BB NNN   NN UU    UU CC    CC         C
C         KK  KK  SS       BB    BB NNNN  NN UU    UU CC               C
C         KKKKK    SSSSSS  BBBBBBB  NN NN NN UU    UU CC               C
C         KK  KK        SS BB    BB NN  NNNN UU    UU CC               C
C         KK   KK SS    SS BB    BB NN   NNN UU    UU CC    CC         C
C         KK    KK SSSSSS  BBBBBBB  NN    NN  UUUUUU   CCCCCC          C
C                                                                      C
C -------------------------------------------------------------------- C
C  KSBNUC CONSTRUCTS A FULL SET OF MULTI-CENTRE VACUUM POLARISATION    C
C  MATRIX ELEMENTS BASED ON POLARISATION OF NUCLEI AND THE             C
C  KÄLLÉN-SABRY INTERACTION TO FIRST ORDER.                            C
C -------------------------------------------------------------------- C
C ▶ THE `LL' COMPONENT OF THIS CAN BE USED IN THE 'NORL' TREE OPTION,  C
C   BUT THE INPUT DECK ASSUMES THAT 'DHFQ' IMPLIES RELATIVISTIC.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BKSB/RKSB(MCT,3),FKSB(MCT,MFT),XKSB(MCT,MFT),NKSB(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VKSB(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMLL VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A KÄLLÉN-SABRY POTENTIAL
          DO IZ=1,NCNT
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE KÄLLÉN-SABRY EXPANSION FOR IZ
            DO IFT=1,NKSB(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XKSB(IZ,IFT)
              FC = FKSB(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUVLL
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,IAB)*HABC
                TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,IAB)*HABC
C
              ENDDO
C
C
C           END LOOP OVER KÄLLÉN-SABRY EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VLL(IBAS,JBAS,1) = TA1
          VLL(IBAS,JBAS,3) = TA2
          VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
          VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMSS VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A KÄLLÉN-SABRY POTENTIAL
          DO IZ=1,NCNT
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE KÄLLÉN-SABRY EXPANSION FOR IZ
            DO IFT=1,NKSB(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XKSB(IZ,IFT)
              FC = FKSB(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUVSS
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,IAB)*HABC
                TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,IAB)*HABC
C
              ENDDO
C
C
C           END LOOP OVER KÄLLÉN-SABRY EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VSS(IBAS,JBAS,1) = TA1
          VSS(IBAS,JBAS,3) = TA2
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF VKSB FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL KÄLLÉN-SABRY INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VKSB(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VKSB(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VKSB(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VKSB(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VKSB(JL1+JBAS,IL1+IBAS) = DCONJG(VKSB(IL1+IBAS,JL1+JBAS))
            VKSB(JL2+JBAS,IL1+IBAS) = DCONJG(VKSB(IL1+IBAS,JL2+JBAS))
            VKSB(JL1+JBAS,IL2+IBAS) = DCONJG(VKSB(IL2+IBAS,JL1+JBAS))
            VKSB(JL2+JBAS,IL2+IBAS) = DCONJG(VKSB(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VKSB(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VKSB(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VKSB(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VKSB(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VKSB(JL1+JBAS,IL1+IBAS) = DCONJG(VKSB(IL1+IBAS,JL1+JBAS))
            VKSB(JL2+JBAS,IL1+IBAS) = DCONJG(VKSB(IL1+IBAS,JL2+JBAS))
            VKSB(JL1+JBAS,IL2+IBAS) = DCONJG(VKSB(IL2+IBAS,JL1+JBAS))
            VKSB(JL2+JBAS,IL2+IBAS) = DCONJG(VKSB(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
C
C     SS KÄLLÉN-SABRY INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VKSB(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VKSB(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VKSB(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VKSB(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VKSB(JS1+JBAS,IS1+IBAS) = DCONJG(VKSB(IS1+IBAS,JS1+JBAS))
            VKSB(JS2+JBAS,IS1+IBAS) = DCONJG(VKSB(IS1+IBAS,JS2+JBAS))
            VKSB(JS1+JBAS,IS2+IBAS) = DCONJG(VKSB(IS2+IBAS,JS1+JBAS))
            VKSB(JS2+JBAS,IS2+IBAS) = DCONJG(VKSB(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VKSB(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VKSB(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VKSB(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VKSB(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VKSB(JS1+JBAS,IS1+IBAS) = DCONJG(VKSB(IS1+IBAS,JS1+JBAS))
            VKSB(JS2+JBAS,IS1+IBAS) = DCONJG(VKSB(IS1+IBAS,JS2+JBAS))
            VKSB(JS1+JBAS,IS2+IBAS) = DCONJG(VKSB(IS2+IBAS,JS1+JBAS))
            VKSB(JS2+JBAS,IS2+IBAS) = DCONJG(VKSB(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     END LOOPS OVER BASIS PAIRS A,B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB     C
C   CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB     C
C   CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB    C
C   CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB    C
C    CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB     C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB GENERATES ALL MANY-CENTRE ELECTRON REPULSION INTEGRALS IN   C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL COULOMB MATRIX.  C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  TODO: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C     INCLUDE 'omp_lib.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),JQN(4)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ICNT(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     INTEGRAL SCREENING SENSITIVITY PARAMETER
      DATA SENS/1.0D-12/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL ATOMIC CENTRES (USE INDEX 1000)                    C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1003 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1004 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS (DEFER TO RACAH ALGEBRA ROUTINE)
      IF(MCNT.EQ.1.AND.RACAH1) THEN
        GOTO 1100
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL LQN ORBITAL TYPES (USE INDEX 2000)                 C
C**********************************************************************C
C
C     LOOP OVER LQN(A) VALUES
      DO 2001 LA=0,(NKAP(ICNTA)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK A
        LQN(1) = LA
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER LQN(B) VALUES
      DO 2002 LB=0,(NKAP(ICNTB)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK B
        LQN(2) = LB
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER LQN(C) VALUES
      DO 2003 LC=0,(NKAP(ICNTC)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK C
        LQN(3) = LC
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER LQN(D) VALUES
      DO 2004 LD=0,(NKAP(ICNTD)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK D
        LQN(4) = LD
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON LQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 2100
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES FOR THESE LQNS (USE INDEX 3000) C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 3001 NA=KRONECK(LA,0),1
        KA = 2*LA+NA
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        JQN(1) = 2*IABS(KQN(1))-1
C
C     LOOP OVER KQN(B) VALUES
      DO 3002 NB=KRONECK(LB,0),1
        KB = 2*LB+NB
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        JQN(2) = 2*IABS(KQN(2))-1
C
C     LOOP OVER KQN(C) VALUES
      DO 3003 NC=KRONECK(LC,0),1
        KC = 2*LC+NC
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        JQN(3) = 2*IABS(KQN(3))-1
C
C     LOOP OVER KQN(D) VALUES
      DO 3004 ND=KRONECK(LD,0),1
        KD = 2*LD+ND
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        JQN(4) = 2*IABS(KQN(4))-1
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 3100
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 3100
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 4000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 4001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 4002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 4003 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 4004 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 4101
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 4101
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 4101
        GOTO 4100
      ENDIF
4101  CONTINUE
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO MMA=1,2
          DO MMB=1,2
            DO MMC=1,2
              DO MMD=1,2
                MMJA = MQN(1)*((-1)**MMA)
                MMJB = MQN(2)*((-1)**MMB)
                MMJC = MQN(3)*((-1)**MMC)
                MMJD = MQN(4)*((-1)**MMD)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 4100
      ENDIF
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     CALCULATE BLOCK INDICES FOR {ABCD} COMBINATIONS
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(INTSYM.AND.IQ1.LT.IQ2) GOTO 4100
      IF(INTSYM.AND.IQ3.LT.IQ4) GOTO 4100
      IF(INTSYM.AND.IQL.LT.IQR) GOTO 4100
C
      IF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 1
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL = IQR
        ITSCF = 2
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 3
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 4
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 5
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL = IQR
        ITSCF = 6
      ELSE
C       ALL OTHER CASES GENERATED BY THE ABOVE, SO SKIP
        GOTO 4100
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO IS=1,11
        IFLG(IS) = ISCF(IS,ITSCF)
      ENDDO
C
C     INCLUDE SPECIAL CASES FOR MATCHING BLOCKS
      IF(IQ2.EQ.IQ3) THEN
C       THE CASE WHERE IQ2 = IQ3
        IF(ITSCF.EQ.1.OR.ITSCF.EQ.3.OR.ITSCF.EQ.4) THEN
          IFLG( 9) = 1
        ENDIF
      ENDIF
C
      IF(ITSCF.EQ.1) THEN
        IF(IQ1.EQ.IQ3) THEN
C         THE CASE WHERE IQ1 = IQ3
          IFLG(10) = 1
        ELSEIF(IQ2.EQ.IQ4) THEN
C         THE CASE WHERE IQ2 = IQ4
          IFLG(11) = 1
        ENDIF
      ENDIF
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 5000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LL (1) or SS (4)
      DO 5001 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
        NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
        NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
        NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LL (1) or SS (4)
      DO 5002 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
        NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
        ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
        ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = MAPTTTT(IT1,IT2)
C
C     STAGE 1: INCLUDE ONLY (LL|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.1.AND.ITT.GT.1) THEN
        GOTO 5100
      ENDIF
C
C     STAGE 2: INCLUDE ONLY (LL|SS) AND (SS|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.2.AND.ITT.GT.3) THEN
        GOTO 5100
      ENDIF
C
C     STAGE 3: INCLUDE ONLY TWO-CENTRE (SS|SS) REPULSION INTEGRALS
      IF(ILEV.EQ.3.AND.ITT.EQ.4) THEN
C
        IF(SSSSI3.AND.MCNT.EQ.3) THEN
          GOTO 5100
        ENDIF
        IF(SSSSI4.AND.MCNT.EQ.4) THEN
          GOTO 5100
        ENDIF
C
C        OPTIONS FOR VISSCHER SMALL COMPONENT APPROXIMATION
C
c        IF(MCNT.EQ.2) THEN
cC         DIRECT CHOICE
c          IF(ICNTA.EQ.ICNTB.AND.ICNTC.EQ.ICNTD) THEN
c            GOTO 4102
cC         EXCHANGE CHOICE
c          ELSEIF(ICNTA.EQ.ICNTD.AND.ICNTB.EQ.ICNTC) THEN
c            GOTO 4102
c          ENDIF
c          GOTO 5100
cC         TODO: THIS IS WHERE I WOULD EVALUATE THE POINT-COULOMB RESULTS
c4002      CONTINUE
C        ENDIF
C
      ENDIF
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT GMAT/QMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     START OF PARALLEL REGION
C!$OMP PARALLEL DO COLLAPSE(2)
C!$OMP&  PRIVATE(RR,IBCH,IFLG)
C!$OMP&  SHARED(XYZ,KQN,MQN,EXL,NBAS,ITN)
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(SCHWRZ.AND.ITT.GT.1) THEN
            ITOG = 1
          ELSE
            ITOG = 0
          ENDIF
C
          CALL SYSTEM_CLOCK(ICL3)
          CALL SCHWARZ(GDSC,SENS)
          CALL SYSTEM_CLOCK(ICL4)
          TC2S = TC2S + DFLOAT(ICL4-ICL3)/RATE
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
            CALL ERI(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
            CALL SYSTEM_CLOCK(ICL5)
            IF(ISYM.EQ.0) THEN
              CALL CLMMTG(RR,IFLG)
            ELSE
              CALL CLMMTZ(RR,IFLG)
            ENDIF
            CALL SYSTEM_CLOCK(ICL6)
            TCMC = TCMC + DFLOAT(ICL6-ICL5)/RATE
C
          ENDIF
C
        ENDDO
      ENDDO
C     END OF PARALLEL REGION
C!$OMP END PARALLEL DO
C
C     RECORD TIME AT END OF BATCH
      CALL SYSTEM_CLOCK(ICL2)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + DFLOAT(ICL2-ICL1)/RATE
C
5100  CONTINUE
5002  CONTINUE
5001  CONTINUE
4100  CONTINUE
4004  CONTINUE
4003  CONTINUE
4002  CONTINUE
4001  CONTINUE
3100  CONTINUE
3004  CONTINUE
3003  CONTINUE
3002  CONTINUE
3001  CONTINUE
2100  CONTINUE
2004  CONTINUE
2003  CONTINUE
2002  CONTINUE
2001  CONTINUE
1100  CONTINUE
1004  CONTINUE
1003  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL MATRICES BY CONJUGATION.            C
C**********************************************************************C
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      CALL SYSTEM_CLOCK(ICL1,RATE)
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 400
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 400
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 400
          GOTO 401
400       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          GDIR(I,J) = GDIR(I,J) + DCONJG(GDIR(J,I))
          GDIR(J,I) =             DCONJG(GDIR(I,J))
          GXCH(I,J) = GXCH(I,J) + DCONJG(GXCH(J,I))
          GXCH(J,I) =             DCONJG(GXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 401
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          GDIR(K,L) = GDIR(K,L) + DCONJG(GDIR(L,K))
          GDIR(L,K) =             DCONJG(GDIR(K,L))
          GXCH(K,L) = GXCH(K,L) + DCONJG(GXCH(L,K))
          GXCH(L,K) =             DCONJG(GXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          GXCH(I,L) = GXCH(I,L) + DCONJG(GXCH(L,I))
          GXCH(L,I) =             DCONJG(GXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          GXCH(K,J) = GXCH(K,J) + DCONJG(GXCH(J,K))
          GXCH(J,K) =             DCONJG(GXCH(K,J))
C
401       CONTINUE
        ENDDO
      ENDDO
C
C     OPEN-SHELL SPECIAL CASE
      IF(NOPN.EQ.0) GOTO 450
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 410
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 410
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 410
          GOTO 402
410       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          QDIR(I,J) = QDIR(I,J) + DCONJG(QDIR(J,I))
          QDIR(J,I) =             DCONJG(QDIR(I,J))
          QXCH(I,J) = QXCH(I,J) + DCONJG(QXCH(J,I))
          QXCH(J,I) =             DCONJG(QXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 402
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          QDIR(K,L) = QDIR(K,L) + DCONJG(QDIR(L,K))
          QDIR(L,K) =             DCONJG(QDIR(K,L))
          QXCH(K,L) = QXCH(K,L) + DCONJG(QXCH(L,K))
          QXCH(L,K) =             DCONJG(QXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          QXCH(I,L) = QXCH(I,L) + DCONJG(QXCH(L,I))
          QXCH(L,I) =             DCONJG(QXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          QXCH(K,J) = QXCH(K,J) + DCONJG(QXCH(J,K))
          QXCH(J,K) =             DCONJG(QXCH(K,J))
C
402       CONTINUE
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS
      DO J=1,NDIM
        DO I=1,NDIM
          QDIR(I,J) = ACFF*QDIR(I,J)
          QXCH(I,J) = BCFF*QXCH(I,J)
        ENDDO
      ENDDO
C
C     CLOSED-SHELL SKIP POINT
450   CONTINUE
C
      CALL SYSTEM_CLOCK(ICL2)
      TCMC = TCMC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE ERI(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                        EEEEEEEE RRRRRRR  IIII                        C
C                        EE       RR    RR  II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEE   RR    RR  II                         C
C                        EE       RRRRRRR   II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEEEE RR    RR IIII                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ  - FULL SET OF CARTESIAN BASIS CENTRES.                       C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ KQN  - FULL SET OF RELATIVISTIC LABELS.                           C
C  ▶ MQN  - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).          C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  ▶ EXL  - FULL LISTS OF EXPONENTS IN THE BLOCK.                      C
C  ▶ IBAS - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ JBAS - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ ITN  - COMPONENT OVERLAP (T,T') FOR CD. ITN(I) = {LL,LS,SL,SS}.   C
C  OUTPUT:                                                             C
C  ▶ RR   - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL L0CASE
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MB2,MEQ),IABI11(MB2,MEQ),
     &          IABR21(MB2,MEQ),IABI21(MB2,MEQ)
      DIMENSION ICDR11(MEQ),ICDR21(MEQ),ICDI11(MEQ),ICDI21(MEQ)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ),ECD11(MB2,MEQ),
     &           EAB21(MB2,MEQ),ECD21(MB2,MEQ)
C
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA SENS/1.0D-16/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.1.AND.ITN(IT).NE.4) THEN
          WRITE(6, *) 'In ERI: illegal component overlaps in ITN.'
          WRITE(7, *) 'In ERI: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      DO N=1,4
        LQN(N) = LVAL(KQN(N))
      ENDDO
C
C     SPECIAL CASE FOR S-TYPE OVERLAPS (ONLY EVER NEEDED ONCE)
      IF(LQN(1)+LQN(2)+LQN(3)+LQN(4).EQ.0) THEN
        L0CASE = .TRUE.
      ELSE
        L0CASE = .FALSE.
      ENDIF
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTORS FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     MCMURCHIE-DAVIDSON MAXINUM ORDER FOR EQ(AB)-COEFFICIENTS
      IF(ITN(1).EQ.1) THEN
        LAMAB = LQN(1)+LQN(2)
      ELSEIF(ITN(1).EQ.4) THEN
        LAMAB = LQN(1)+LQN(2)+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(CD)-COEFFICIENTS
      IF(ITN(2).EQ.1) THEN
        LAMCD = LQN(3)+LQN(4)
      ELSEIF(ITN(2).EQ.4) THEN
        LAMCD = LQN(3)+LQN(4)+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD
C
C     MAXIMUM LAMBDA ORDER FOR RCTTFL SAVED LIST (ONLY IF MCNT.GT.2)
      IF(.NOT.RCFILE.OR.HMLT.EQ.'NORL') THEN
        LAMABCDFL = LAMABCD
      ELSEIF(RCFILE.AND.HMLT.NE.'NORL') THEN
        IF(ILEV.EQ.1) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
        ELSEIF(ILEV.EQ.2) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+2
        ELSEIF(ILEV.EQ.3) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
        ENDIF
      ENDIF
C
C     UTILISE EXPANSION SUBSET (WHEN RCFILE.EQ.FALSE)
      IF((ITN(1)+ITN(2))/3.EQ.ILEV) THEN
        ISKIP = 0
      ELSE
        ISKIP = 1
      ENDIF
C
C     PAIR AND GROUP EQ-COEFFICIENT LIST AND R-INTEGRAL BATCH LENGTHS
      NTUVAB     = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD     = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD   = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
      NTUVABCDFL = (LAMABCDFL+1)*(LAMABCDFL+2)*(LAMABCDFL+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
      IF(EQFILE) THEN
C
C       OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
        IF(ITN(1).EQ.1) THEN
          DO IAB=1,NTUVAB
            IAD = IABLL + (IAB-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              EAB21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.4) THEN
          DO IAB=1,NTUVAB
            IAD = IABSS + (IAB-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              EAB21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
C
      ELSE
C
C       OPTION 2: CALCULATE FROM SCRATCH
        IF(ITN(1).EQ.1) THEN
          CALL EQLLMK(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ELSEIF(ITN(1).EQ.4) THEN
          CALL EQSSMK(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ENDIF
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL4)
      IF(ITN(1).EQ.1) THEN
        TELL = TELL + DFLOAT(ICL4-ICL3)/RATE
      ELSEIF(ITN(1).EQ.4) THEN
        TESS = TESS + DFLOAT(ICL4-ICL3)/RATE
      ENDIF
C
C     SCREENING: TEST E(AB| -) COLUMNS OF CARTESIAN INDEX (T ,U ,V )
      DO IAB=1,NTUVAB
C
C       Re{E(AB|--)} COEFFICIENTS
        DO M=1,MAXAB
          ERAB11 = DREAL(EAB11(M,IAB))
          IF(DABS(ERAB11).GT.SENS) THEN
            IABR11(M,IAB) = 1
          ELSE
            IABR11(M,IAB) = 0
          ENDIF
        ENDDO
C
C       Im{E(AB|--)} COEFFICIENTS
        DO M=1,MAXAB
          EIAB11 = DIMAG(EAB11(M,IAB))
          IF(DABS(EIAB11).GT.SENS) THEN
            IABI11(M,IAB) = 1
          ELSE
            IABI11(M,IAB) = 0
          ENDIF
        ENDDO
C
C       Re{E(AB|+-)} COEFFICIENTS
        DO M=1,MAXAB
          ERAB21 = DREAL(EAB21(M,IAB))
          IF(DABS(ERAB21).GT.SENS) THEN
            IABR21(M,IAB) = 1
          ELSE
            IABR21(M,IAB) = 0
          ENDIF
        ENDDO
C
C       Im{E(AB|+-)} COEFFICIENTS
        DO M=1,MAXAB
          EIAB21 = DIMAG(EAB21(M,IAB))
          IF(DABS(EIAB21).GT.SENS) THEN
            IABI21(M,IAB) = 1
          ELSE
            IABI21(M,IAB) = 0
          ENDIF
        ENDDO
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(2).EQ.1) THEN
          DO ICD=1,NTUVCD
            IAD = ICDLL + (ICD-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ICD)))
            DO M=1,MAXCD
              ECD11(M,ICD) = Z*DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              ECD21(M,ICD) = Z*DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.4) THEN
          DO ICD=1,NTUVCD
            IAD = ICDSS + (ICD-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ICD)))
            DO M=1,MAXCD
              ECD11(M,ICD) = Z*DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              ECD21(M,ICD) = Z*DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(2).EQ.1) THEN
          CALL EQLLMK(ECD11,ECD21,EXL,XY Z,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ELSEIF(ITN(2).EQ.4) THEN
          CALL EQSSMK(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL4)
      IF(ITN(2).EQ.1) THEN
        TELL = TELL + DFLOAT(ICL4-ICL3)/RATE
      ELSEIF(ITN(2).EQ.4) THEN
        TESS = TESS + DFLOAT(ICL4-ICL3)/RATE
      ENDIF
C
C     SCREENING: TEST E(CD| -) COLUMNS OF CARTESIAN INDEX (T',U',V')
      DO ICD=1,NTUVCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD11 = DREAL(ECD11(M,ICD))
          SUM = SUM + DABS(ERCD11)
          IF(SUM.GT.SENS) THEN
            ICDR11(ICD) = 1
            GOTO 201
          ENDIF
        ENDDO
        ICDR11(ICD) = 0
201     CONTINUE
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD11 = DIMAG(ECD11(M,ICD))
          SUM = SUM + DABS(EICD11)
          IF(SUM.GT.SENS) THEN
            ICDI11(ICD) = 1
            GOTO 202
          ENDIF
        ENDDO
        ICDI11(ICD) = 0
202     CONTINUE
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD21 = DREAL(ECD21(M,ICD))
          SUM = SUM + DABS(ERCD21)
          IF(SUM.GT.SENS) THEN
            ICDR21(ICD) = 1
            GOTO 203
          ENDIF
        ENDDO
        ICDR21(ICD) = 0
203     CONTINUE
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD21 = DIMAG(ECD21(M,ICD))
          SUM = SUM + DABS(EICD21)
          IF(SUM.GT.SENS) THEN
            ICDI21(ICD) = 1
            GOTO 204
          ENDIF
        ENDDO
        ICDI21(ICD) = 0
204     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL SYSTEM_CLOCK(ICL2)
      TCEC = TCEC + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) INTEGRALS IF PROMPTED            C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     SKIP IF A HIGHER LEVEL OF THIS BATCH EXISTS IN RC
      IF(.NOT.RCFILE.AND.ISKIP.EQ.0) GOTO 300
C
C     SKIP IF A HIGHER LEVEL OF THIS BATCH EXISTS IN RC
      IF(L0CASE.AND.ISKIP.EQ.0) GOTO 300
C
C     SKIP IF INTEGRAL BATCH EXISTS IN FILE
      IF(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0) GOTO 300
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(RCFILE.AND.L0CASE.AND.ISCR(M).EQ.0) GOTO 301
          IF(.NOT.RCFILE.AND.ISCR(M).EQ.0) GOTO 301
          N   = N+1
          EKL = EXL(KBAS,3)+EXL(LBAS,4)
          QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
          QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
          QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
          PQ(N,1) = QX-PX
          PQ(N,2) = QY-PY
          PQ(N,3) = QZ-PZ
          APH(N)  = EIJ*EKL/(EIJ+EKL)
301       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH SIZE AND EXPANSION LENGTH DEPENDS ON MODE
      IF(RCFILE.AND..NOT.L0CASE) THEN
        MBCH = MAXCD
        MLAM = LAMABCDFL
        MNTV = NTUVABCDFL
      ELSE
        MBCH = MAXN
        MLAM = LAMABCD
        MNTV = NTUVABCD
      ENDIF
C
C     GENERATE R-INTEGRALS
      CALL RMAKE(RC,PQ,APH,MBCH,MLAM)
C
C     SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
      DO INTV=1,MNTV
C
C       SUM OF RC(AB|CD) MAGNITUDES
        SUM = 0.0D0
        DO N=1,MBCH
          SUM = SUM + DABS(RC(N,INTV))
          IF(SUM.GT.SENS) THEN
            IRC(INTV) = 1
            GOTO 302
          ENDIF
        ENDDO
        IRC(INTV) = 0
302     CONTINUE
C
      ENDDO
      CALL SYSTEM_CLOCK(ICL4)
      TCRM = TCRM + DFLOAT(ICL4-ICL3)/RATE
C
C     CONTINUE ONLY IF INTEGRALS ARE TO BE SAVED TO LARGE FILE
      IF(L0CASE) GOTO 300
      IF(.NOT.RCFILE) GOTO 300
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
      IF(20*MFL.LT.IJ*MAXCD*NTUVABCDFL) THEN
C       OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
        WRITE(6, *) 'In ERI: RCTT words exceed allocated limit.'
        WRITE(7, *) 'In ERI: RCTT words exceed allocated limit.'
        STOP
        GOTO 300
      ELSE
C       DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
        IRIJ(IBAS,JBAS) = 0
      ENDIF
C
C     STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
      IADRTT = (IJ-1)*MAXCD*NTUVABCDFL
C
C     COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
      DO IABCDFL=1,NTUVABCDFL
        IAD = IADRTT + MAXCD*(IABCDFL-1)
        DO M=1,MAXCD
          RCTTFL(IAD+M) = RC(M,IABCDFL)
        ENDDO
      ENDDO
C
C     STARTING ADDRESS FOR THIS BATCH OF SCREENING FLAGS
      IADSCR = (IJ-1)*NTUVABCDFL
C
C     COPY SCREENING MARKERS TO A SAVED LIST
      DO IABCDFL=1,NTUVABCDFL
        IRCTTFL(IADSCR+IABCDFL) = IRC(IABCDFL)
      ENDDO
C
      CALL SYSTEM_CLOCK(ICL4)
      TCRW = TCRW + DFLOAT(ICL4-ICL3)/RATE
C
300   CONTINUE
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL SYSTEM_CLOCK(ICL2)
      IF(ITN(1).EQ.1.AND.ITN(2).EQ.1) THEN
        TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
      ELSEIF(ITN(1).EQ.4.AND.ITN(2).EQ.4) THEN
        TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
      ELSE
        TRLS = TRLS + DFLOAT(ICL2-ICL1)/RATE
      ENDIF
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     TIME AT START OF FIRST CONTRACTION
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) FAILS SCREENING CONDITION
        IABALL = IABR11(IJ,IAB) + IABI11(IJ,IAB)
     &         + IABR21(IJ,IAB) + IABI21(IJ,IAB)
        IF(IABALL.EQ.0) GOTO 401
C
C       CALCULATE DIRECTLY FROM SMALL RC(AB|CD) LOCAL ARRAY
        IF(.NOT.RCFILE.OR.L0CASE) THEN
C
C         LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
          DO ICD=1,NTUVCD
C
C           SKIP THIS STEP IF THE E(CD) FAILS SCREENING CONDITION
            ICDALL = ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD)
            IF(ICDALL.EQ.0) GOTO 402
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),
     &                                    IC(IAB)+IC(ICD))
C
C           SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
            IF(IRC(IRABCD).EQ.0) GOTO 402
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(IABR11(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 411
            IF(ICDR11(ICD).EQ.0) GOTO 411
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                         + DREAL(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
411         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(IABI11(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 412
            IF(ICDI11(ICD).EQ.0) GOTO 412
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                         + DIMAG(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
412         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(IABR21(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 413
            IF(ICDR21(ICD).EQ.0) GOTO 413
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                         + DREAL(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
413         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(IABI21(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 414
            IF(ICDI21(ICD).EQ.0) GOTO 414
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                         + DIMAG(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
414         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) SCREENING
402         CONTINUE
C
C         END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
          ENDDO
C
C       CALCULATE DIRECTLY FROM LARGE RC(AB|CD) SCRATCH ARRAY
        ELSE
C
C         LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
          DO ICD=1,NTUVCD
C
C           SKIP THIS STEP IF THE E(CD) FAILS SCREENING CONDITION
            ICDALL = ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD)
            IF(ICDALL.EQ.0) GOTO 432
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),
     &                                    IC(IAB)+IC(ICD))
C
C           STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
            IAD = (IJ-1)*MAXCD*NTUVABCDFL + MAXCD*(IRABCD-1)
C
C           SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
            IF(IRCTTFL((IJ-1)*NTUVABCDFL+IRABCD).EQ.0) GOTO 432
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(IABR11(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 421
            IF(ICDR11(ICD).EQ.0) GOTO 421
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                  + DREAL(ECD11(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
            ENDDO
421         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(IABI11(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 422
            IF(ICDI11(ICD).EQ.0) GOTO 422
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                  + DIMAG(ECD11(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
            ENDDO
422         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(IABR21(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 423
            IF(ICDR21(ICD).EQ.0) GOTO 423
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                  + DREAL(ECD21(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
            ENDDO
423         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(IABI21(IJ,IAB).EQ.0.AND.ISYM.GT.1) GOTO 424
            IF(ICDI21(ICD).EQ.0) GOTO 424
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                  + DIMAG(ECD21(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
            ENDDO
424         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) SCREENING
432         CONTINUE
C
C         END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
          ENDDO
C
        ENDIF
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION
      CALL SYSTEM_CLOCK(ICL2)
      TCC1 = TCC1 + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1)
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB = ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD = ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     SPECIAL CASE: LINEAR MOLECULE OR ATOM
      IF(ISYM.NE.1.AND.ISYM.NE.2) GOTO 501
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QR2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     DCMPLX(QR1(N)+QR2(N),0.0D0)
        RR(N, 4) = PCD*DCMPLX(QR1(N)-QR2(N),0.0D0)
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N,13) = PABCD*DCONJG(RR(N, 4))
      ENDDO
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QR2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     DCMPLX(QR1(N)+QR2(N),0.0D0)
        RR(N,10) =-PCD*DCMPLX(QR1(N)-QR2(N),0.0D0)
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N, 7) = PABCD*DCONJG(RR(N,10))
      ENDDO
C
      GOTO 502
C
C     GENERAL CASE
501   CONTINUE
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 4) = PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N,13) = PABCD*DCONJG(RR(N, 4))
      ENDDO
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 3) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 2) =-PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,14) =-PABCD*DCONJG(RR(N, 3))
        RR(N,15) =-PABCD*DCONJG(RR(N, 2))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 9) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 8) =-PABCD*DCONJG(RR(N, 9))
        RR(N, 5) =-PABCD*DCONJG(RR(N,12))
      ENDDO
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IJ,IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) =-PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N, 7) = PABCD*DCONJG(RR(N,10))
      ENDDO
C
502   CONTINUE
C
C     TIME AT END OF SECOND CONTRACTION
      CALL SYSTEM_CLOCK(ICL2)
      TCC2 = TCC2 + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     COULOMB INTEGRAL BATCH NOW FULLY CONSTRUCTED                     C
C**********************************************************************C
C
C     CALCULATE THE R-INTEGRAL NORMALISATION FACTOR
      CALL SYSTEM_CLOCK(ICL1,RATE)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.1) THEN
            EKL = EXL(KBAS,3)+EXL(LBAS,4)
            EMX = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(M) = 2.0D0*PI52/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     INCLUDE THE R-INTEGRAL NORMALISATION FACTOR
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) = PRE(IMAP(N))*RR(N,ITG)
        ENDDO
      ENDDO
      CALL SYSTEM_CLOCK(ICL2)
      TCAX = TCAX + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE CLMFAST
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC  LL       MM       MM FFFFFFFF   AA     SSSSSS TTTTTTTT    C
C   CC    CC LL       MMM     MMM FF        AAAA   SS    SS   TT       C
C   CC       LL       MMMM   MMMM FF       AA  AA  SS         TT       C
C   CC       LL       MM MM MM MM FFFFFF  AA    AA  SSSSSS    TT       C
C   CC       LL       MM  MMM  MM FF      AAAAAAAA       SS   TT       C
C   CC    CC LL       MM   M   MM FF      AA    AA SS    SS   TT       C
C    CCCCCC  LLLLLLLL MM       MM FF      AA    AA  SSSSSS    TT       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMFAST GENERATES ALL MANY-CENTRE ELECTRON REPULSION INTEGRALS IN   C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL COULOMB MATRIX.  C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  THIS IS A SPECIAL VERSION OF THE USUAL COULOMB ROUTINE, DESIGNED TO C
C  RECYCLE THE INTERMEDIATE INTEGRALS G(  |CD) BY REARRANGING THE LOOP C
C  ORDER WITHIN A GIVEN SET OF LQN'S. LOOP OVER (AB) BASIS FUNCTIONS   C
C  FIRST, AND THEN USE THE SAME INTERMEDIATE INTEGRALS FOR ALL (CD)    C
C  BASIS FUNCTIONS. THE SWAP OF CONTRACTION ORDER IS DONE IN ERIFAST.  C
C -------------------------------------------------------------------- C
C  TODO: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C     INCLUDE 'omp_lib.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),LQN(4),KQN(4),JQN(4),MQN(4),NBAS(4)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     INTEGRAL SCREENING SENSITIVITY PARAMETER
      DATA SENS/1.0D-12/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL ATOMIC CENTRES (USE INDEX 1000)                    C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1003 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1004 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS (DEFER TO RACAH ALGEBRA ROUTINE)
      IF(MCNT.EQ.1.AND.RACAH1) THEN
        GOTO 1100
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL LQN ORBITAL TYPES (USE INDEX 2000)                 C
C**********************************************************************C
C
C     LOOP OVER LQN(A) VALUES
      DO 2001 LA=0,(NKAP(ICNTA)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK A
        LQN(1) = LA
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER LQN(B) VALUES
      DO 2002 LB=0,(NKAP(ICNTB)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK B
        LQN(2) = LB
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER LQN(C) VALUES
      DO 2003 LC=0,(NKAP(ICNTC)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK C
        LQN(3) = LC
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER LQN(D) VALUES
      DO 2004 LD=0,(NKAP(ICNTD)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK D
        LQN(4) = LD
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C     EVALUATE SPARSITY LISTS FOR UPCOMING EQ(CD) BATCH
      CALL SYSTEM_CLOCK(ICL1,RATE)
      CALL E0LLCD0(ICNT,LQN,NBAS)
      IF(HMLT.NE.'NORL'.AND.ILEV.NE.1) THEN
        CALL E0SSCD0(ICNT,LQN,NBAS)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TC2S = TC2S + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON LQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 2100
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES FOR THESE LQNS (USE INDEX 3000) C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 3001 NA=KRONECK(LA,0),1
        KA = 2*LA+NA
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        JQN(1) = 2*IABS(KQN(1))-1
C
C     LOOP OVER KQN(B) VALUES
      DO 3002 NB=KRONECK(LB,0),1
        KB = 2*LB+NB
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        JQN(2) = 2*IABS(KQN(2))-1
C
C**********************************************************************C
C     LOOP OVER ALL |MQN|(AB) SYMMETRY TYPES (USE INDEX 4000)          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 4001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 4002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C**********************************************************************C
C     LOOP OVER ALL (AB) COMPONENT OVERLAP OPTIONS T1 (USE INDEX 5000) C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LL (1) or SS (4)
      DO 5001 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSEIF(IT1.EQ.4) THEN
          NADDAB = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
        NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
        NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
        NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C**********************************************************************C
C     LOOP OVER ALL (AB) BASIS FUNCTIONS (IBAS,JBAS) (USE INDEX 6000)  C
C**********************************************************************C
C
      DO 6001 IBAS=1,NBAS(1)
      DO 6002 JBAS=1,NBAS(2)
C
C     PERFORM FIRST CONTRACTION AGAIN
      IGAB = 1
C
C**********************************************************************C
C     LOOP OVER ALL KQN(CD) SYMMETRY TYPES (USE INDEX 7000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(C) VALUES
      DO 7001 NC=KRONECK(LC,0),1
        KC = 2*LC+NC
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        JQN(3) = 2*IABS(KQN(3))-1
C
C     LOOP OVER KQN(D) VALUES
      DO 7002 ND=KRONECK(LD,0),1
        KD = 2*LD+ND
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        JQN(4) = 2*IABS(KQN(4))-1
C
C     UNIQUE INDEX FOR THIS PAIR OF KAPPAS
      NCD = 2*NC+ND+1
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 7100
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 7100
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL |MQN|(CD) PROJECTIONS (INDEX 8000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(C)| VALUES
      DO 8001 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 8002 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      IECD  = 1
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 8101
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 8101
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 8101
        GOTO 8100
      ENDIF
8101  CONTINUE
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO MMA=1,2
          DO MMB=1,2
            DO MMC=1,2
              DO MMD=1,2
                MMJA = MQN(1)*((-1)**MMA)
                MMJB = MQN(2)*((-1)**MMB)
                MMJC = MQN(3)*((-1)**MMC)
                MMJD = MQN(4)*((-1)**MMD)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 8100
      ENDIF
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     CALCULATE BLOCK INDICES FOR {ABCD} COMBINATIONS
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(INTSYM.AND.IQ1.LT.IQ2) GOTO 8100
      IF(INTSYM.AND.IQ3.LT.IQ4) GOTO 8100
      IF(INTSYM.AND.IQL.LT.IQR) GOTO 8100
C
      IF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 1
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL = IQR
        ITSCF = 2
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 3
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 4
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 5
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL = IQR
        ITSCF = 6
      ELSE
C       ALL OTHER CASES GENERATED BY THE ABOVE, SO SKIP
        GOTO 8100
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO IS=1,11
        IFLG(IS) = ISCF(IS,ITSCF)
      ENDDO
C
C     INCLUDE SPECIAL CASES FOR MATCHING BLOCKS
      IF(IQ2.EQ.IQ3) THEN
C       THE CASE WHERE IQ2 = IQ3
        IF(ITSCF.EQ.1.OR.ITSCF.EQ.3.OR.ITSCF.EQ.4) THEN
          IFLG( 9) = 1
        ENDIF
      ENDIF
C
      IF(ITSCF.EQ.1) THEN
        IF(IQ1.EQ.IQ3) THEN
C         THE CASE WHERE IQ1 = IQ3
          IFLG(10) = 1
        ELSEIF(IQ2.EQ.IQ4) THEN
C         THE CASE WHERE IQ2 = IQ4
          IFLG(11) = 1
        ENDIF
      ENDIF
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER ALL (CD) COMPONENT OVERLAP OPTIONS T2 (USE INDEX 9000) C
C**********************************************************************C
C                                              _
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LL (1) or SS (4)
      DO 9001 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       RECORD TIME
        CALL SYSTEM_CLOCK(ICL3,RATE)
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSEIF(IT2.EQ.4) THEN
          NADDCD = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
        NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
        ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
        ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C       COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
        ITT = MAPTTTT(IT1,IT2)
C
C       STAGE 1: INCLUDE ONLY (LL|LL) REPULSION INTEGRALS
        IF(ILEV.EQ.1.AND.ITT.GT.1) THEN
          IF(MCNT.NE.1) THEN
            GOTO 9100
          ENDIF
        ENDIF
C
C       STAGE 2: INCLUDE ONLY (LL|SS) AND (SS|LL) REPULSION INTEGRALS
        IF(ILEV.EQ.2.AND.ITT.GT.3) THEN
          IF(MCNT.NE.1) THEN
            GOTO 9100
          ENDIF
        ENDIF
C
C       STAGE 3: INCLUDE ONLY TWO-CENTRE (SS|SS) REPULSION INTEGRALS
        IF(ILEV.EQ.3.AND.ITT.EQ.4) THEN
C
          IF(SSSSI3.AND.MCNT.EQ.3) THEN
            GOTO 9100
          ENDIF
          IF(SSSSI4.AND.MCNT.EQ.4) THEN
            GOTO 9100
          ENDIF
C
C          OPTIONS FOR VISSCHER SMALL COMPONENT APPROXIMATION
C
c          IF(MCNT.EQ.2) THEN
cC           DIRECT CHOICE
c            IF(ICNTA.EQ.ICNTB.AND.ICNTC.EQ.ICNTD) THEN
c              GOTO 9101
cC           EXCHANGE CHOICE
c            ELSEIF(ICNTA.EQ.ICNTD.AND.ICNTB.EQ.ICNTC) THEN
c              GOTO 9101
c            ENDIF
c            GOTO 9100
cC           TODO: THIS IS WHERE I WOULD EVALUATE THE POINT-COULOMB RESULTS
c9101        CONTINUE
C          ENDIF
C
        ENDIF
C
C       UPDATE COUNTER FOR NUMBER OF BLOCKS CALCULATED
        IF(IBAS.EQ.1.AND.JBAS.EQ.1) THEN
          N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
        ENDIF
C
C**********************************************************************C
C     CONSTRUCTION OF GMAT/QMAT CONTRIBUTIONS FOR THIS BATCH           C
C**********************************************************************C
C
C     SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
      IF(SCHWRZ.AND.ITT.GT.1) THEN
        ITOG = 1
      ELSE
        ITOG = 0
      ENDIF
C
      CALL SYSTEM_CLOCK(ICL5,RATE)
      CALL SCHWARZ(GDSC,SENS)
      CALL SYSTEM_CLOCK(ICL6)
      TC2S = TC2S + DFLOAT(ICL6-ICL5)/RATE
C
C     UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
      N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
      N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C     CONDITIONAL TO SKIP THIS BATCH
      IF(IBCH.EQ.1) THEN
C
C       GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
        CALL ERIFAST(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C       MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
        CALL SYSTEM_CLOCK(ICL5,RATE)
        IF(ISYM.EQ.0) THEN
          CALL CLMMTG(RR,IFLG)
        ELSE
          CALL CLMMTZ(RR,IFLG)
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        TCMC = TCMC + DFLOAT(ICL6-ICL5)/RATE
C
      ENDIF
C
9100  CONTINUE
C     RECORD TIME AT END OF BATCH
      CALL SYSTEM_CLOCK(ICL4)
      IF(MCNT.EQ.1.OR.ITT.LT.2*ILEV) THEN
        T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + DFLOAT(ICL4-ICL3)/RATE
      ENDIF
9001  CONTINUE
8100  CONTINUE
8002  CONTINUE
8001  CONTINUE
7100  CONTINUE
7002  CONTINUE
7001  CONTINUE
6002  CONTINUE
6001  CONTINUE
5001  CONTINUE
4002  CONTINUE
4001  CONTINUE
3002  CONTINUE
3001  CONTINUE
2100  CONTINUE
2004  CONTINUE
2003  CONTINUE
2002  CONTINUE
2001  CONTINUE
1100  CONTINUE
1004  CONTINUE
1003  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL MATRICES BY CONJUGATION.            C
C**********************************************************************C
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      CALL SYSTEM_CLOCK(ICL1)
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 400
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 400
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 400
          GOTO 401
400       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          GDIR(I,J) = GDIR(I,J) + DCONJG(GDIR(J,I))
          GDIR(J,I) =             DCONJG(GDIR(I,J))
          GXCH(I,J) = GXCH(I,J) + DCONJG(GXCH(J,I))
          GXCH(J,I) =             DCONJG(GXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 401
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          GDIR(K,L) = GDIR(K,L) + DCONJG(GDIR(L,K))
          GDIR(L,K) =             DCONJG(GDIR(K,L))
          GXCH(K,L) = GXCH(K,L) + DCONJG(GXCH(L,K))
          GXCH(L,K) =             DCONJG(GXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          GXCH(I,L) = GXCH(I,L) + DCONJG(GXCH(L,I))
          GXCH(L,I) =             DCONJG(GXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          GXCH(K,J) = GXCH(K,J) + DCONJG(GXCH(J,K))
          GXCH(J,K) =             DCONJG(GXCH(K,J))
C
401       CONTINUE
        ENDDO
      ENDDO
C
C     OPEN-SHELL SPECIAL CASE
      IF(NOPN.EQ.0) GOTO 450
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 410
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 410
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 410
          GOTO 402
410       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          QDIR(I,J) = QDIR(I,J) + DCONJG(QDIR(J,I))
          QDIR(J,I) =             DCONJG(QDIR(I,J))
          QXCH(I,J) = QXCH(I,J) + DCONJG(QXCH(J,I))
          QXCH(J,I) =             DCONJG(QXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 402
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          QDIR(K,L) = QDIR(K,L) + DCONJG(QDIR(L,K))
          QDIR(L,K) =             DCONJG(QDIR(K,L))
          QXCH(K,L) = QXCH(K,L) + DCONJG(QXCH(L,K))
          QXCH(L,K) =             DCONJG(QXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          QXCH(I,L) = QXCH(I,L) + DCONJG(QXCH(L,I))
          QXCH(L,I) =             DCONJG(QXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          QXCH(K,J) = QXCH(K,J) + DCONJG(QXCH(J,K))
          QXCH(J,K) =             DCONJG(QXCH(K,J))
C
402       CONTINUE
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS
      DO J=1,NDIM
        DO I=1,NDIM
          QDIR(I,J) = ACFF*QDIR(I,J)
          QXCH(I,J) = BCFF*QXCH(I,J)
        ENDDO
      ENDDO
C
C     CLOSED-SHELL SKIP POINT
450   CONTINUE
      CALL SYSTEM_CLOCK(ICL2)
      TCMC = TCMC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE ERIFAST(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       EEEEEEEE RRRRRRR  IIII FFFFFFFF   AA     SSSSSS TTTTTTTT       C
C       EE       RR    RR  II  FF        AAAA   SS    SS   TT          C
C       EE       RR    RR  II  FF       AA  AA  SS         TT          C
C       EEEEEE   RR    RR  II  FFFFFF  AA    AA  SSSSSS    TT          C
C       EE       RRRRRRR   II  FF      AAAAAAAA       SS   TT          C
C       EE       RR    RR  II  FF      AA    AA SS    SS   TT          C
C       EEEEEEEE RR    RR IIII FF      AA    AA  SSSSSS    TT          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  THIS IS A SPECIAL VERSION OF ERI, WHICH CONTRACTS OVER THE (AB)     C
C  PAIRS BEFORE (CD), AND RECYCLES THE FIRST CONTRACTION OVER (CD).    C
C  NOT TO BE USED IF EOTT OR R(AB|CD) BATCHES EXCEED MAX SPACE.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ  - FULL SET OF CARTESIAN BASIS CENTRES.                       C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ KQN  - FULL SET OF RELATIVISTIC LABELS.                           C
C  ▶ MQN  - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).          C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  ▶ EXL  - FULL LISTS OF EXPONENTS IN THE BLOCK.                      C
C  ▶ IBAS - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ JBAS - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ ITN  - COMPONENT OVERLAP (T,T') FOR CD. ITN(I) = {LL,LS,SL,SS}.   C
C  OUTPUT:                                                             C
C  ▶ RR   - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MB2,MEQ,4),IABI11(MB2,MEQ,4),
     &          IABR21(MB2,MEQ,4),IABI21(MB2,MEQ,4)
      DIMENSION ICDR11(MEQ,4),ICDI11(MEQ,4),
     &          ICDR21(MEQ,4),ICDI21(MEQ,4)
      DIMENSION ICDR11KM(4,MKP,MKP,MEQ,4),ICDI11KM(4,MKP,MKP,MEQ,4),
     &          ICDR21KM(4,MKP,MKP,MEQ,4),ICDI21KM(4,MKP,MKP,MEQ,4)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GCDR11(MB2,MEQ),GCDI11(MB2,MEQ),
     &          GCDR21(MB2,MEQ),GCDI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ),EAB21(MB2,MEQ),
     &           ECD11(MB2,MEQ),ECD21(MB2,MEQ)
C
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICDC/ICDR11KM,ICDR11,ICDI11KM,ICDI11,
     &            ICDR21KM,ICDR21,ICDI21KM,ICDI21
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA EPSAB,EPSRR/1.0D-16,1.0D-10/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.1.AND.ITN(IT).NE.4) THEN
          WRITE(6, *) 'In ERIFAST: illegal component overlaps in ITN.'
          WRITE(7, *) 'In ERIFAST: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      DO N=1,4
        LQN(N) = LVAL(KQN(N))
      ENDDO
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNT(1),ICNT(2),ICNT(3),ICNT(4))
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     LIST ADDRESSES DEPEND ON COMPONENT OVERLAP
      IF(ITN(1).EQ.1) THEN
        IABTT = IABLL
      ELSEIF(ITN(1).EQ.4) THEN
        IABTT = IABSS
      ENDIF
      IF(ITN(2).EQ.1) THEN
        ICDTT = ICDLL
      ELSEIF(ITN(2).EQ.4) THEN
        ICDTT = ICDSS
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTORS FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     MCMURCHIE-DAVIDSON MAXINUM ORDER FOR EQ(AB)-COEFFICIENTS
      IF(ITN(1).EQ.1) THEN
        LAMAB = LQN(1)+LQN(2)
      ELSEIF(ITN(1).EQ.4) THEN
        LAMAB = LQN(1)+LQN(2)+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(CD)-COEFFICIENTS
      IF(ITN(2).EQ.1) THEN
        LAMCD = LQN(3)+LQN(4)
      ELSEIF(ITN(2).EQ.4) THEN
        LAMCD = LQN(3)+LQN(4)+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD
C
      IF(HMLT.EQ.'NORL') THEN
        LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
      ELSEIF(MCNT.EQ.1) THEN
        LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
      ELSE
        IF(ILEV.EQ.1) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
        ELSEIF(ILEV.EQ.2) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+2
        ELSEIF(ILEV.EQ.3) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
        ENDIF
      ENDIF
      NTUVABCDFL = (LAMABCDFL+1)*(LAMABCDFL+2)*(LAMABCDFL+3)/6
C
C     PAIR AND GROUP EQ-COEFFICIENT LIST AND R-INTEGRAL BATCH LENGTHS
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
      CALL SYSTEM_CLOCK(ICL2)
      TCAX = TCAX + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(IEAB.EQ.0) GOTO 100
C
C     SCREENING: TEST E(AB| -) COLUMNS OF CARTESIAN INDEX (T ,U ,V )
      IF(ITN(1).EQ.1) THEN
C
        DO IAB=1,NTUVAB
C
C         RELATIVE EQ(AB) LIST STARTING ADDRESS
          MAB = IABTT + (IAB-1)*MAXAB
C
C         Re{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0LLFL(MAB+M,1)).GT.EPSAB) THEN
              IABR11(M,IAB,ITN(1)) = 1
            ELSE
              IABR11(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0LLFL(MAB+M,2)).GT.EPSAB) THEN
              IABI11(M,IAB,ITN(1)) = 1
            ELSE
              IABI11(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
C         Re{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0LLFL(MAB+M,3)).GT.EPSAB) THEN
              IABR21(M,IAB,ITN(1)) = 1
            ELSE
              IABR21(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0LLFL(MAB+M,4)).GT.EPSAB) THEN
              IABI21(M,IAB,ITN(1)) = 1
            ELSE
              IABI21(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
        ENDDO
C
      ELSEIF(ITN(1).EQ.4) THEN
C
        DO IAB=1,NTUVAB
C
C         RELATIVE EQ(AB) LIST STARTING ADDRESS
          MAB = IABTT + (IAB-1)*MAXAB
C
C         Re{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0SSFL(MAB+M,1)).GT.EPSAB) THEN
              IABR11(M,IAB,ITN(1)) = 1
            ELSE
              IABR11(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0SSFL(MAB+M,2)).GT.EPSAB) THEN
              IABI11(M,IAB,ITN(1)) = 1
            ELSE
              IABI11(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
C         Re{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0SSFL(MAB+M,3)).GT.EPSAB) THEN
              IABR21(M,IAB,ITN(1)) = 1
            ELSE
              IABR21(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(E0SSFL(MAB+M,4)).GT.EPSAB) THEN
              IABI21(M,IAB,ITN(1)) = 1
            ELSE
              IABI21(M,IAB,ITN(1)) = 0
            ENDIF
          ENDDO
C
        ENDDO
C
      ENDIF
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
      CALL SYSTEM_CLOCK(ICL2)
      TCEC = TCEC + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C -------------------------------------------------------------------- C
C     IN THIS ALGORITHM WE DEFER TO E0LLCD0 AND E0SSCD0 (EXTERNALLLY)  C
C**********************************************************************C
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) INTEGRALS IF PROMPTED            C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     SKIP IF INTEGRAL BATCH EXISTS IN FILE
      IF(IRIJ(IBAS,JBAS).EQ.0) GOTO 300
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M   = M+1
          EKL = EXL(KBAS,3)+EXL(LBAS,4)
          QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
          QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
          QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
          PQ(M,1) = QX-PX
          PQ(M,2) = QY-PY
          PQ(M,3) = QZ-PZ
          APH(M)  = EIJ*EKL/(EIJ+EKL)
          EMX     = DSQRT(EIJ+EKL)*EIJ*EKL
          PRE(M)  = 2.0D0*PI52/EMX
        ENDDO
      ENDDO
C
      MBCH = MAXCD
      MLAM = LAMABCDFL
      MNTV = NTUVABCDFL

C     GENERATE R-INTEGRALS
      CALL RMAKE(RC,PQ,APH,MBCH,MLAM)
C
C     SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
      DO IABCD=1,MNTV
C
C       SUM OF RC(AB|CD) MAGNITUDES
        SUM = 0.0D0
        DO N=1,MBCH
          SUM = SUM + DABS(RC(N,IABCD))
          IF(SUM.GT.EPSRR) THEN
            IRC(IABCD) = 1
            GOTO 302
          ENDIF
        ENDDO
        IRC(IABCD) = 0
302     CONTINUE
C
      ENDDO
      CALL SYSTEM_CLOCK(ICL4)
      TCRM = TCRM + DFLOAT(ICL4-ICL3)/RATE
C
C     CONTINUE ONLY IF INTEGRALS ARE TO BE SAVED TO LARGE FILE
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
      IF(20*MFL.LT.IJ*MAXCD*NTUVABCDFL) THEN
C       OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
        WRITE(6, *) 'In ERIFAST: RCTT words exceed allocated limit.'
        WRITE(7, *) 'In ERIFAST: RCTT words exceed allocated limit.'
        STOP
        GOTO 300
      ELSE
C       DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
        IRIJ(IBAS,JBAS) = 0
      ENDIF
C
C     STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
      IADRTT = (IJ-1)*MAXCD*NTUVABCDFL
C
C     COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
      DO IABCDFL=1,NTUVABCDFL
        IAD = IADRTT + MAXCD*(IABCDFL-1)
        DO M=1,MAXCD
          RCTTFL(IAD+M) = PRE(M)*RC(M,IABCDFL)
        ENDDO
      ENDDO
C
C     STARTING ADDRESS FOR THIS BATCH OF SCREENING FLAGS
      IADSCR = (IJ-1)*NTUVABCDFL
C
C     COPY SCREENING MARKERS TO A SAVED LIST
      DO IABCDFL=1,NTUVABCDFL
        IRCTTFL(IADSCR+IABCDFL) = IRC(IABCDFL)
      ENDDO
C
      CALL SYSTEM_CLOCK(ICL4)
      TCRW = TCRW + DFLOAT(ICL4-ICL3)/RATE
C
300   CONTINUE
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL SYSTEM_CLOCK(ICL2)
      IF(ITN(1).EQ.1.AND.ITN(2).EQ.1) THEN
        TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
      ELSEIF(ITN(1).EQ.4.AND.ITN(2).EQ.4) THEN
        TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
      ELSE
        TRLS = TRLS + DFLOAT(ICL2-ICL1)/RATE
      ENDIF
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     TIME AT START OF FIRST CONTRACTION
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
      IF(IGAB.EQ.0) GOTO 400
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO ICD=1,NTUVCD
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GCDR11(N,ICD) = 0.0D0
          GCDI11(N,ICD) = 0.0D0
          GCDR21(N,ICD) = 0.0D0
          GCDI21(N,ICD) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) FAILS SCREENING CONDITION
        ICDALL = ICDR11(ICD,ITN(2)) + ICDI11(ICD,ITN(2))
     &         + ICDR21(ICD,ITN(2)) + ICDI21(ICD,ITN(2))
        IF(ICDALL.EQ.0) GOTO 401
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO IAB=1,NTUVAB
C
C         RELATIVE EQ(AB) LIST STARTING ADDRESS
          MAB = IABTT + (IAB-1)*MAXAB
C
C         SKIP THIS STEP IF THE E(CD) FAILS SCREENING CONDITION
          IABALL = IABR11(IJ,IAB,ITN(1)) + IABI11(IJ,IAB,ITN(1))
     &           + IABR21(IJ,IAB,ITN(1)) + IABI21(IJ,IAB,ITN(1))
C
          IF(IABALL.EQ.0) GOTO 432
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),IC(IAB)+IC(ICD))
C
C         RELATIVE RC(AB|CD) LIST STARTING ADDRESS
          MABCD = (IJ-1)*MAXCD*NTUVABCDFL + MAXCD*(IRABCD-1)
C
C         SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
          IF(IRCTTFL((IJ-1)*NTUVABCDFL+IRABCD).EQ.0) GOTO 432
C
C         CONTRIBUTIONS TO Re{G(CD|--)} FROM EACH Re{E(AB|--)} ADDRESS
          IF(ICDR11(ICD,ITN(2)).EQ.0.AND.ISYM.GT.1) GOTO 421
          IF(IABR11(IJ,IAB,ITN(1)).EQ.0) GOTO 421
          IF(ITN(1).EQ.1) THEN
            DO N=1,MAXN
              GCDR11(N,ICD) = GCDR11(N,ICD)
     &                         + E0LLFL(MAB+IJ,1)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ELSEIF(ITN(1).EQ.4) THEN
            DO N=1,MAXN
              GCDR11(N,ICD) = GCDR11(N,ICD)
     &                         + E0SSFL(MAB+IJ,1)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ENDIF
421       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(CD|--)} FROM EACH Im{E(AB|--)} ADDRESS
          IF(ICDI11(ICD,ITN(2)).EQ.0.AND.ISYM.GT.1) GOTO 422
          IF(IABI11(IJ,IAB,ITN(1)).EQ.0) GOTO 422
          IF(ITN(1).EQ.1) THEN
            DO N=1,MAXN
              GCDI11(N,ICD) = GCDI11(N,ICD)
     &                         + E0LLFL(MAB+IJ,2)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ELSEIF(ITN(1).EQ.4) THEN
            DO N=1,MAXN
              GCDI11(N,ICD) = GCDI11(N,ICD)
     &                         + E0SSFL(MAB+IJ,2)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ENDIF
422       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(CD|+-)} FROM EACH Re{E(AB|+-)} ADDRESS
          IF(ICDR21(ICD,ITN(2)).EQ.0.AND.ISYM.GT.1) GOTO 423
          IF(IABR21(IJ,IAB,ITN(1)).EQ.0) GOTO 423
          IF(ITN(1).EQ.1) THEN
            DO N=1,MAXN
              GCDR21(N,ICD) = GCDR21(N,ICD)
     &                         + E0LLFL(MAB+IJ,3)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ELSEIF(ITN(1).EQ.4) THEN
            DO N=1,MAXN
              GCDR21(N,ICD) = GCDR21(N,ICD)
     &                         + E0SSFL(MAB+IJ,3)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ENDIF
423       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(CD|+-)} FROM EACH Im{E(AB|+-)} ADDRESS
          IF(ICDI21(ICD,ITN(2)).EQ.0.AND.ISYM.GT.1) GOTO 424
          IF(IABI21(IJ,IAB,ITN(1)).EQ.0) GOTO 424
          IF(ITN(1).EQ.1) THEN
            DO N=1,MAXN
              GCDI21(N,ICD) = GCDI21(N,ICD)
     &                         + E0LLFL(MAB+IJ,4)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ELSEIF(ITN(1).EQ.4) THEN
            DO N=1,MAXN
              GCDI21(N,ICD) = GCDI21(N,ICD)
     &                         + E0SSFL(MAB+IJ,4)*RCTTFL(MABCD+IMAP(N))
            ENDDO
          ENDIF
424       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) SCREENING
432       CONTINUE
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     FIRST CONTRACTION DOES NOT NEED TO BE RECALCULATED
      IGAB = 0
400   CONTINUE
C
C     TIME AT END OF FIRST CONTRACTION
      CALL SYSTEM_CLOCK(ICL2)
      TCC1 = TCC1 + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     TIME AT START OF SECOND CONTRACTION
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB = ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD = ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     SHORTHAND FOR MQN VALUES IN (CD) BLOCK
      MC = (MQN(3)+1)/2
      MD = (MQN(4)+1)/2
C
C     SPECIAL CASE: LINEAR MOLECULE OR ATOM
      IF(ISYM.NE.1.AND.ISYM.NE.2) GOTO 501
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QR2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(CD|--)*(Re{G(CD|--)} + i*Im{G(CD|--)})
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        Z   = DFLOAT((-1)**(ILAM(ICD)))
        IF(ICDR11KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0LLFL(MCD+IMAP(N),1)*GCDR11(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0SSFL(MCD+IMAP(N),1)*GCDR11(N,ICD)
            ENDDO
          ENDIF
        ENDIF
        IF(ICDI11KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR2(N) = QR2(N) - Z*E0LLFL(MCD+IMAP(N),2)*GCDI11(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR2(N) = QR2(N) - Z*E0SSFL(MCD+IMAP(N),2)*GCDI11(N,ICD)
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     DCMPLX(QR1(N)+QR2(N),0.0D0)
        RR(N,13) = PAB*DCMPLX(QR1(N)-QR2(N),0.0D0)
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N, 4) = PABCD*DCONJG(RR(N,13))
      ENDDO
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QR2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(CD|+-)*(Re{G(CD|+-)} + i*Im{G(CD|+-)})
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        Z   = DFLOAT((-1)**(ILAM(ICD)))
        IF(ICDR21KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0LLFL(MCD+IMAP(N),3)*GCDR21(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0SSFL(MCD+IMAP(N),3)*GCDR21(N,ICD)
            ENDDO
          ENDIF
        ENDIF
        IF(ICDI21KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR2(N) = QR2(N) - Z*E0LLFL(MCD+IMAP(N),4)*GCDI21(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR2(N) = QR2(N) - Z*E0SSFL(MCD+IMAP(N),4)*GCDI21(N,ICD)
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     DCMPLX(QR1(N)+QR2(N),0.0D0)
        RR(N, 7) =-PAB*DCMPLX(QR1(N)-QR2(N),0.0D0)
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N,10) = PABCD*DCONJG(RR(N, 7))
      ENDDO
C
      GOTO 502
C
C     GENERAL CASE
501   CONTINUE
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(CD|--)*(Re{G(CD|--)} + i*Im{G(CD|--)})
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        Z   = DFLOAT((-1)**(ILAM(ICD)))
        IF(ICDR11KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0LLFL(MCD+IMAP(N),1)*GCDR11(N,ICD)
              QI2(N) = QI2(N) + Z*E0LLFL(MCD+IMAP(N),1)*GCDI11(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0SSFL(MCD+IMAP(N),1)*GCDR11(N,ICD)
              QI2(N) = QI2(N) + Z*E0SSFL(MCD+IMAP(N),1)*GCDI11(N,ICD)
            ENDDO
          ENDIF
        ENDIF
        IF(ICDI11KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0LLFL(MCD+IMAP(N),2)*GCDR11(N,ICD)
              QR2(N) = QR2(N) - Z*E0LLFL(MCD+IMAP(N),2)*GCDI11(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0SSFL(MCD+IMAP(N),2)*GCDR11(N,ICD)
              QR2(N) = QR2(N) - Z*E0SSFL(MCD+IMAP(N),2)*GCDI11(N,ICD)
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,13) = PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N, 4) = PABCD*DCONJG(RR(N,13))
      ENDDO
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(CD|--)*(Re{G(CD|+-)} + i*Im{G(CD|+-)})
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        Z   = DFLOAT((-1)**(ILAM(ICD)))
        IF(ICDR21KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0LLFL(MCD+IMAP(N),3)*GCDR11(N,ICD)
              QI2(N) = QI2(N) + Z*E0LLFL(MCD+IMAP(N),3)*GCDI11(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0SSFL(MCD+IMAP(N),3)*GCDR11(N,ICD)
              QI2(N) = QI2(N) + Z*E0SSFL(MCD+IMAP(N),3)*GCDI11(N,ICD)
            ENDDO
          ENDIF
        ENDIF
        IF(ICDI21KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0LLFL(MCD+IMAP(N),4)*GCDR11(N,ICD)
              QR2(N) = QR2(N) - Z*E0LLFL(MCD+IMAP(N),4)*GCDI11(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0SSFL(MCD+IMAP(N),4)*GCDR11(N,ICD)
              QR2(N) = QR2(N) - Z*E0SSFL(MCD+IMAP(N),4)*GCDI11(N,ICD)
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 3) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,15) = PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,14) =-PABCD*DCONJG(RR(N, 3))
        RR(N, 2) =-PABCD*DCONJG(RR(N,15))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(CD|+-)*(Re{G(CD|--)} + i*Im{G(CD|--)})
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        Z   = DFLOAT((-1)**(ILAM(ICD)))
        IF(ICDR11KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0LLFL(MCD+IMAP(N),1)*GCDR21(N,ICD)
              QI2(N) = QI2(N) + Z*E0LLFL(MCD+IMAP(N),1)*GCDI21(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0SSFL(MCD+IMAP(N),1)*GCDR21(N,ICD)
              QI2(N) = QI2(N) + Z*E0SSFL(MCD+IMAP(N),1)*GCDI21(N,ICD)
            ENDDO
          ENDIF
        ENDIF
        IF(ICDI11KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0LLFL(MCD+IMAP(N),2)*GCDR21(N,ICD)
              QR2(N) = QR2(N) - Z*E0LLFL(MCD+IMAP(N),2)*GCDI21(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0SSFL(MCD+IMAP(N),2)*GCDR21(N,ICD)
              QR2(N) = QR2(N) - Z*E0SSFL(MCD+IMAP(N),2)*GCDI21(N,ICD)
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 9) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 5) =-PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 8) =-PABCD*DCONJG(RR(N, 9))
        RR(N,12) =-PABCD*DCONJG(RR(N, 5))
      ENDDO
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(CD|+-)*(Re{G(CD|+-)} + i*Im{G(CD|+-)})
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        Z   = DFLOAT((-1)**(ILAM(ICD)))
        IF(ICDR21KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0LLFL(MCD+IMAP(N),3)*GCDR21(N,ICD)
              QI2(N) = QI2(N) + Z*E0LLFL(MCD+IMAP(N),3)*GCDI21(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N) + Z*E0SSFL(MCD+IMAP(N),3)*GCDR21(N,ICD)
              QI2(N) = QI2(N) + Z*E0SSFL(MCD+IMAP(N),3)*GCDI21(N,ICD)
            ENDDO
          ENDIF
        ENDIF
        IF(ICDI21KM(NCD,MC,MD,ICD,ITN(2)).EQ.1) THEN
          IF(ITN(2).EQ.1) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0LLFL(MCD+IMAP(N),4)*GCDR21(N,ICD)
              QR2(N) = QR2(N) - Z*E0LLFL(MCD+IMAP(N),4)*GCDI21(N,ICD)
            ENDDO
          ELSEIF(ITN(2).EQ.4) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N) + Z*E0SSFL(MCD+IMAP(N),4)*GCDR21(N,ICD)
              QR2(N) = QR2(N) - Z*E0SSFL(MCD+IMAP(N),4)*GCDI21(N,ICD)
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 7) =-PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N,10) = PABCD*DCONJG(RR(N, 7))
      ENDDO
C
502   CONTINUE
C
C     TIME AT END OF SECOND CONTRACTION
      CALL SYSTEM_CLOCK(ICL2)
      TCC2 = TCC2 + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     COULOMB INTEGRAL BATCH NOW FULLY CONSTRUCTED                     C
C**********************************************************************C
C
      RETURN
      END
C
C
      SUBROUTINE CLMMTZ(RR,IFLG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      CCCCCC  LL       MM       MM MM       MM TTTTTTTT ZZZZZZZZ      C
C     CC    CC LL       MMM     MMM MMM     MMM    TT         ZZ       C
C     CC       LL       MMMM   MMMM MMMM   MMMM    TT        ZZ        C
C     CC       LL       MM MM MM MM MM MM MM MM    TT       ZZ         C
C     CC       LL       MM  MMM  MM MM  MMM  MM    TT      ZZ          C
C     CC    CC LL       MM   M   MM MM   M   MM    TT     ZZ           C
C      CCCCCC  LLLLLLLL MM       MM MM       MM    TT    ZZZZZZZZ      C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMTZ MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF COULOMB MATRICES.     C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  THIS IS A SPECIAL CASE OF COULOMB MATRIX ASSEMBLER CLMMTG, WHICH    C
C  MAY ONLY BE USED WHEN THE FOCK MATRIX IS REAL-VALUED -- EXAMPLES    C
C  ARE ATOMS, DIATOMICS, LINEAR OR PLANAR MOLECULES.                   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C  ▶ NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C  ▶ IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C -------------------------------------------------------------------- C
C * TRY SELECTION RULES BASED ON MQN SIGNS                             C
C * MAKE SURE THAT BLOCK ARE ON UPPER/LOWER DIAGONAL WITH CONDITIONALS C
C * TRACE THROUGH IQ1<IQ2 ARGUMENTS AND SO FORTH                       C
C * IDENTIFY WHICH TRIANGULAR MATRIX IS ACTUALLY WANTED                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION IFLG(11),NBAS(4),MQN(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.EQ.0) THEN
        WRITE(6,*) 'In CLMMTZ: you probably should be using CLMMTG.'
        WRITE(7,*) 'In CLMMTZ: you probably should be using CLMMTG.'
      ENDIF
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(1).NE.1) GOTO 151
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(3).NE.MQN(4))) GOTO 151
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 101
          N = N+1
          IF(IMTX(M,1).EQ.0) GOTO 101
C
          GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENT(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(N, 4))*DREAL(DENT(NC2+KBAS,ND2+LBAS))
C
          GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &       +           DREAL(RR(N,13))*DREAL(DENT(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENT(NC2+KBAS,ND2+LBAS))
C
101       CONTINUE
        ENDDO
      ENDDO
151   CONTINUE
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 180
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(2).NE.1) GOTO 152
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(4).NE.MQN(3))) GOTO 152
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 102
          N = N+1
          IF(IMTX(M,2).EQ.0) GOTO 102
C
          GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(N, 4))*DREAL(DENT(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(N, 1))*DREAL(DENT(ND2+LBAS,NC2+KBAS))
C
          GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &       +      PCD1*DREAL(RR(N,16))*DREAL(DENT(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(N,13))*DREAL(DENT(ND2+LBAS,NC2+KBAS))
C
102       CONTINUE
        ENDDO
      ENDDO
152   CONTINUE
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}
      IF(IFLG(3).NE.1) GOTO 153
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(1).NE.MQN(2))) GOTO 153
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 103
          N = N+1
          IF(IMTX(M,3).EQ.0) GOTO 103
C
          GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENT(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(N,13))*DREAL(DENT(NA2+IBAS,NB2+JBAS))
C
          GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &       +           DREAL(RR(N, 4))*DREAL(DENT(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENT(NA2+IBAS,NB2+JBAS))
C
103       CONTINUE
        ENDDO
      ENDDO
153   CONTINUE
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).NE.1) GOTO 154
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(2).NE.MQN(1))) GOTO 154
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 104
          N = N+1
          IF(IMTX(M,4).EQ.0) GOTO 104
C
          GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(N,13))*DREAL(DENT(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(N, 1))*DREAL(DENT(NB2+JBAS,NA2+IBAS))
C
          GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &       + PAB1*     DREAL(RR(N,16))*DREAL(DENT(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(N, 4))*DREAL(DENT(NB2+JBAS,NA2+IBAS))
C
104       CONTINUE
        ENDDO
      ENDDO
154   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
180   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}
      IF(IFLG(5).NE.1) GOTO 155
      IF(MQNSLC.AND.(MQN(1).NE.MQN(4).OR.MQN(3).NE.MQN(2))) GOTO 155
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 105
          N = N+1
          IF(IMTX(M,5).EQ.0) GOTO 105
C
          GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENT(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(N, 7))*DREAL(DENT(NC2+KBAS,NB2+JBAS))
C
          GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &       +           DREAL(RR(N,10))*DREAL(DENT(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENT(NC2+KBAS,NB2+JBAS))
C
105       CONTINUE
        ENDDO
      ENDDO
155   CONTINUE
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 190
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).NE.1) GOTO 156
      IF(MQNSLC.AND.(MQN(1).NE.MQN(3).OR.MQN(4).NE.MQN(2))) GOTO 156
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 106
          N = N+1
          IF(IMTX(M,6).EQ.0) GOTO 106
C
          GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &       +      PCD1*DREAL(RR(N, 4))*DREAL(DENT(ND1+LBAS,NB1+JBAS))
     &       +      PCD2*DREAL(RR(N, 7))*DREAL(DENT(ND2+LBAS,NB2+JBAS))
C
          GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &       +      PCD2*DREAL(RR(N,10))*DREAL(DENT(ND1+LBAS,NB1+JBAS))
     &       +      PCD1*DREAL(RR(N,13))*DREAL(DENT(ND2+LBAS,NB2+JBAS))
C
106       CONTINUE
        ENDDO
      ENDDO
156   CONTINUE
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).NE.1) GOTO 157
      IF(MQNSLC.AND.(MQN(2).NE.MQN(4).OR.MQN(3).NE.MQN(1))) GOTO 157
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 107
          N = N+1
          IF(IMTX(M,7).EQ.0) GOTO 107
C
          GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(N,13))*DREAL(DENT(NC1+KBAS,NA1+IBAS))
     &       + PAB2*     DREAL(RR(N, 7))*DREAL(DENT(NC2+KBAS,NA2+IBAS))
C
          GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &       + PAB2*     DREAL(RR(N,10))*DREAL(DENT(NC1+KBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(N, 4))*DREAL(DENT(NC2+KBAS,NA2+IBAS))
C
107       CONTINUE
        ENDDO
      ENDDO
157   CONTINUE
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).NE.1) GOTO 158
      IF(MQNSLC.AND.(MQN(2).NE.MQN(3).OR.MQN(4).NE.MQN(1))) GOTO 158
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 108
          N = N+1
          IF(IMTX(M,8).EQ.0) GOTO 108
C
          GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &       + PAB1*PCD1*DREAL(RR(N,16))*DREAL(DENT(ND1+LBAS,NA1+IBAS))
     &       + PAB2*PCD2*DREAL(RR(N, 7))*DREAL(DENT(ND2+LBAS,NA2+IBAS))
C
          GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &       + PAB2*PCD2*DREAL(RR(N,10))*DREAL(DENT(ND1+LBAS,NA1+IBAS))
     &       + PAB1*PCD1*DREAL(RR(N, 1))*DREAL(DENT(ND2+LBAS,NA2+IBAS))
C
108       CONTINUE
        ENDDO
      ENDDO
158   CONTINUE
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}
      IF(IFLG(9).NE.1) GOTO 159
      IF(MQNSLC.AND.(MQN(3).NE.MQN(2).OR.MQN(1).NE.MQN(4))) GOTO 159
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 109
          N = N+1
          IF(IMTX(M,9).EQ.0) GOTO 109
C
          GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENT(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(N,10))*DREAL(DENT(NA2+IBAS,ND2+LBAS))
C
          GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &       +           DREAL(RR(N, 7))*DREAL(DENT(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENT(NA2+IBAS,ND2+LBAS))
C
109       CONTINUE
        ENDDO
      ENDDO
159   CONTINUE
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).NE.1) GOTO 160
      IF(MQNSLC.AND.(MQN(3).NE.MQN(1).OR.MQN(2).NE.MQN(4))) GOTO 160
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 110
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 110
C
          GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &       + PAB1*     DREAL(RR(N,13))*DREAL(DENT(NB1+JBAS,ND1+LBAS))
     &       + PAB2*     DREAL(RR(N,10))*DREAL(DENT(NB2+JBAS,ND2+LBAS))
C
          GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &       + PAB2*     DREAL(RR(N, 7))*DREAL(DENT(NB1+JBAS,ND1+LBAS))
     &       + PAB1*     DREAL(RR(N, 4))*DREAL(DENT(NB2+JBAS,ND2+LBAS))
C
110       CONTINUE
        ENDDO
      ENDDO
160   CONTINUE
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).NE.1) GOTO 161
      IF(MQNSLC.AND.(MQN(4).NE.MQN(2).OR.MQN(1).NE.MQN(3))) GOTO 161
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 111
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 111
C
          GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(N, 4))*DREAL(DENT(NA1+IBAS,NC1+KBAS))
     &       +      PCD2*DREAL(RR(N,10))*DREAL(DENT(NA2+IBAS,NC2+KBAS))
C
          GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &       +      PCD2*DREAL(RR(N, 7))*DREAL(DENT(NA1+IBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(N,13))*DREAL(DENT(NA2+IBAS,NC2+KBAS))
111       CONTINUE
        ENDDO
      ENDDO
161   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
190   CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5000
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(1).NE.1) GOTO 151
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(3).NE.MQN(4))) GOTO 151
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 301
          N = N+1
          IF(IMTX(M,1).EQ.0) GOTO 301
C
          QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENO(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(N, 4))*DREAL(DENO(NC2+KBAS,ND2+LBAS))
C
          QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &       +           DREAL(RR(N,13))*DREAL(DENO(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENO(NC2+KBAS,ND2+LBAS))
C
301       CONTINUE
        ENDDO
      ENDDO
351   CONTINUE
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 380
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(2).NE.1) GOTO 152
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(4).NE.MQN(3))) GOTO 152
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 302
          N = N+1
          IF(IMTX(M,2).EQ.0) GOTO 302
C
          QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(N, 4))*DREAL(DENO(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(N, 1))*DREAL(DENO(ND2+LBAS,NC2+KBAS))
C
          QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &       +      PCD1*DREAL(RR(N,16))*DREAL(DENO(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(N,13))*DREAL(DENO(ND2+LBAS,NC2+KBAS))
C
302       CONTINUE
        ENDDO
      ENDDO
352   CONTINUE
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}
      IF(IFLG(3).NE.1) GOTO 153
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(1).NE.MQN(2))) GOTO 153
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 303
          N = N+1
          IF(IMTX(M,3).EQ.0) GOTO 303
C
          QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENO(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(N,13))*DREAL(DENO(NA2+IBAS,NB2+JBAS))
C
          QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &       +           DREAL(RR(N, 4))*DREAL(DENO(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENO(NA2+IBAS,NB2+JBAS))
C
303       CONTINUE
        ENDDO
      ENDDO
353   CONTINUE
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).NE.1) GOTO 154
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(2).NE.MQN(1))) GOTO 154
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 304
          N = N+1
          IF(IMTX(M,4).EQ.0) GOTO 304
C
          QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(N,13))*DREAL(DENO(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(N, 1))*DREAL(DENO(NB2+JBAS,NA2+IBAS))
C
          QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &       + PAB1*     DREAL(RR(N,16))*DREAL(DENO(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(N, 4))*DREAL(DENO(NB2+JBAS,NA2+IBAS))
C
304       CONTINUE
        ENDDO
      ENDDO
354   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
380   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}
      IF(IFLG(5).NE.1) GOTO 155
      IF(MQNSLC.AND.(MQN(1).NE.MQN(4).OR.MQN(3).NE.MQN(2))) GOTO 155
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 305
          N = N+1
          IF(IMTX(M,5).EQ.0) GOTO 305
C
          QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENO(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(N, 7))*DREAL(DENO(NC2+KBAS,NB2+JBAS))
C
          QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &       +           DREAL(RR(N,10))*DREAL(DENO(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENO(NC2+KBAS,NB2+JBAS))
C
305       CONTINUE
        ENDDO
      ENDDO
355   CONTINUE
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 390
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).NE.1) GOTO 156
      IF(MQNSLC.AND.(MQN(1).NE.MQN(3).OR.MQN(4).NE.MQN(2))) GOTO 156
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 306
          N = N+1
          IF(IMTX(M,6).EQ.0) GOTO 306
C
          QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &       +      PCD1*DREAL(RR(N, 4))*DREAL(DENO(ND1+LBAS,NB1+JBAS))
     &       +      PCD2*DREAL(RR(N, 7))*DREAL(DENO(ND2+LBAS,NB2+JBAS))
C
          QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &       +      PCD2*DREAL(RR(N,10))*DREAL(DENO(ND1+LBAS,NB1+JBAS))
     &       +      PCD1*DREAL(RR(N,13))*DREAL(DENO(ND2+LBAS,NB2+JBAS))
C
306       CONTINUE
        ENDDO
      ENDDO
356   CONTINUE
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).NE.1) GOTO 157
      IF(MQNSLC.AND.(MQN(2).NE.MQN(4).OR.MQN(3).NE.MQN(1))) GOTO 157
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 307
          N = N+1
          IF(IMTX(M,7).EQ.0) GOTO 307
C
          QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(N,13))*DREAL(DENO(NC1+KBAS,NA1+IBAS))
     &       + PAB2*     DREAL(RR(N, 7))*DREAL(DENO(NC2+KBAS,NA2+IBAS))
C
          QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &       + PAB2*     DREAL(RR(N,10))*DREAL(DENO(NC1+KBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(N, 4))*DREAL(DENO(NC2+KBAS,NA2+IBAS))
C
307       CONTINUE
        ENDDO
      ENDDO
357   CONTINUE
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).NE.1) GOTO 158
      IF(MQNSLC.AND.(MQN(2).NE.MQN(3).OR.MQN(4).NE.MQN(1))) GOTO 158
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 308
          N = N+1
          IF(IMTX(M,8).EQ.0) GOTO 308
C
          QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &       + PAB1*PCD1*DREAL(RR(N,16))*DREAL(DENO(ND1+LBAS,NA1+IBAS))
     &       + PAB2*PCD2*DREAL(RR(N, 7))*DREAL(DENO(ND2+LBAS,NA2+IBAS))
C
          QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &       + PAB2*PCD2*DREAL(RR(N,10))*DREAL(DENO(ND1+LBAS,NA1+IBAS))
     &       + PAB1*PCD1*DREAL(RR(N, 1))*DREAL(DENO(ND2+LBAS,NA2+IBAS))
C
308       CONTINUE
        ENDDO
      ENDDO
358   CONTINUE
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}
      IF(IFLG(9).NE.1) GOTO 159
      IF(MQNSLC.AND.(MQN(3).NE.MQN(2).OR.MQN(1).NE.MQN(4))) GOTO 159
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 309
          N = N+1
          IF(IMTX(M,9).EQ.0) GOTO 309
C
          QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &       +           DREAL(RR(N, 1))*DREAL(DENO(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(N,10))*DREAL(DENO(NA2+IBAS,ND2+LBAS))
C
          QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &       +           DREAL(RR(N, 7))*DREAL(DENO(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(N,16))*DREAL(DENO(NA2+IBAS,ND2+LBAS))
C
309       CONTINUE
        ENDDO
      ENDDO
359   CONTINUE
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).NE.1) GOTO 160
      IF(MQNSLC.AND.(MQN(3).NE.MQN(1).OR.MQN(2).NE.MQN(4))) GOTO 160
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 310
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 310
C
          QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &       + PAB1*     DREAL(RR(N,13))*DREAL(DENO(NB1+JBAS,ND1+LBAS))
     &       + PAB2*     DREAL(RR(N,10))*DREAL(DENO(NB2+JBAS,ND2+LBAS))
C
          QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &       + PAB2*     DREAL(RR(N, 7))*DREAL(DENO(NB1+JBAS,ND1+LBAS))
     &       + PAB1*     DREAL(RR(N, 4))*DREAL(DENO(NB2+JBAS,ND2+LBAS))
C
310       CONTINUE
        ENDDO
      ENDDO
360   CONTINUE
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).NE.1) GOTO 161
      IF(MQNSLC.AND.(MQN(4).NE.MQN(2).OR.MQN(1).EQ.MQN(3))) GOTO 161
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 311
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 311
C
          QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(N, 4))*DREAL(DENO(NA1+IBAS,NC1+KBAS))
     &       +      PCD2*DREAL(RR(N,10))*DREAL(DENO(NA2+IBAS,NC2+KBAS))
C
          QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &       +      PCD2*DREAL(RR(N, 7))*DREAL(DENO(NA1+IBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(N,13))*DREAL(DENO(NA2+IBAS,NC2+KBAS))
C
311       CONTINUE
        ENDDO
      ENDDO
361   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
390   CONTINUE
C
C     SKIP POINT FOR CLOSED SYSTEMS
5000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE CLMMTG(RR,IFLG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       CCCCCC  LL       MM       MM MM       MM TTTTTTTT GGGGGG       C
C      CC    CC LL       MMM     MMM MMM     MMM    TT   GG    GG      C
C      CC       LL       MMMM   MMMM MMMM   MMMM    TT   GG            C
C      CC       LL       MM MM MM MM MM MM MM MM    TT   GG            C
C      CC       LL       MM  MMM  MM MM  MMM  MM    TT   GG   GGG      C
C      CC    CC LL       MM   M   MM MM   M   MM    TT   GG    GG      C
C       CCCCCC  LLLLLLLL MM       MM MM       MM    TT    GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMTG MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF COULOMB MATRICES.     C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C  ▶ NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C  ▶ IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION IFLG(11),NBAS(4),MQN(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.NE.0) THEN
        WRITE(6,*) 'In CLMMTG: you probably should be using CLMMTZ.'
        WRITE(7,*) 'In CLMMTG: you probably should be using CLMMTZ.'
      ENDIF
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(1).NE.1) GOTO 151
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 101
          N = N+1
          IF(IMTX(M,1).EQ.0) GOTO 101
C
          GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 2)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENT(NC2+KBAS,ND2+LBAS)
C
          GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENT(NC2+KBAS,ND2+LBAS)
C
          GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENT(NC2+KBAS,ND2+LBAS)
C
          GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENT(NC2+KBAS,ND2+LBAS)
C
101       CONTINUE
        ENDDO
      ENDDO
151   CONTINUE
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 180
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(2).NE.1) GOTO 152
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 102
          N = N+1
          IF(IMTX(M,2).EQ.0) GOTO 102
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 2)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENT(ND2+LBAS,NC2+KBAS)
C
            GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENT(ND2+LBAS,NC2+KBAS)
C
            GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENT(ND2+LBAS,NC2+KBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENT(ND2+LBAS,NC2+KBAS)
C
102       CONTINUE
        ENDDO
      ENDDO
152   CONTINUE
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}
      IF(IFLG(3).NE.1) GOTO 153
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 103
          N = N+1
          IF(IMTX(M,3).EQ.0) GOTO 103
C
          GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 5)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENT(NA2+IBAS,NB2+JBAS)
C
          GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENT(NA2+IBAS,NB2+JBAS)
C
          GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENT(NA2+IBAS,NB2+JBAS)
C
          GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENT(NA2+IBAS,NB2+JBAS)
C
103       CONTINUE
        ENDDO
      ENDDO
153   CONTINUE
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).NE.1) GOTO 154
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 104
          N = N+1
          IF(IMTX(M,4).EQ.0) GOTO 104
C
          GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 5)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENT(NB2+JBAS,NA2+IBAS)
C
          GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENT(NB2+JBAS,NA2+IBAS)
C
          GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENT(NB2+JBAS,NA2+IBAS)
C
          GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENT(NB2+JBAS,NA2+IBAS)
C
104       CONTINUE
        ENDDO
      ENDDO
154   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
180   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}
      IF(IFLG(5).NE.1) GOTO 155
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 105
          N = N+1
          IF(IMTX(M,5).EQ.0) GOTO 105
C
          GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 5)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENT(NC2+KBAS,NB2+JBAS)
C
          GXCH(NA1+IBAS,ND2+LBAS) = GXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENT(NC2+KBAS,NB2+JBAS)
C
          GXCH(NA2+IBAS,ND1+LBAS) = GXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENT(NC2+KBAS,NB2+JBAS)
C
          GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENT(NC2+KBAS,NB2+JBAS)
C
105       CONTINUE
        ENDDO
      ENDDO
155   CONTINUE
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 190
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).NE.1) GOTO 156
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 106
          N = N+1
          IF(IMTX(M,6).EQ.0) GOTO 106
C
          GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 8)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENT(ND2+LBAS,NB2+JBAS)
C
          GXCH(NA1+IBAS,NC2+KBAS) = GXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENT(ND2+LBAS,NB2+JBAS)
C
          GXCH(NA2+IBAS,NC1+KBAS) = GXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENT(ND2+LBAS,NB2+JBAS)
C
          GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,14)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENT(ND2+LBAS,NB2+JBAS)
C
106       CONTINUE
        ENDDO
      ENDDO
156   CONTINUE
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).NE.1) GOTO 157
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 107
          N = N+1
          IF(IMTX(M,7).EQ.0) GOTO 107
C
          GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 5)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENT(NC2+KBAS,NA2+IBAS)
C
          GXCH(NB1+JBAS,ND2+LBAS) = GXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENT(NC2+KBAS,NA2+IBAS)
C
          GXCH(NB2+JBAS,ND1+LBAS) = GXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENT(NC2+KBAS,NA2+IBAS)
C
          GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENT(NC2+KBAS,NA2+IBAS)
C
107       CONTINUE
        ENDDO
      ENDDO
157   CONTINUE
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).NE.1) GOTO 158
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 108
          N = N+1
          IF(IMTX(M,8).EQ.0) GOTO 108
C
          GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENT(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENT(ND2+LBAS,NA2+IBAS)
C
          GXCH(NB1+JBAS,NC2+KBAS) = GXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENT(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENT(ND2+LBAS,NA2+IBAS)
C
          GXCH(NB2+JBAS,NC1+KBAS) = GXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENT(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENT(ND2+LBAS,NA2+IBAS)
C
          GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENT(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENT(ND2+LBAS,NA2+IBAS)
C
108       CONTINUE
        ENDDO
      ENDDO
158   CONTINUE
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}
      IF(IFLG(9).NE.1) GOTO 159
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 109
          N = N+1
          IF(IMTX(M,9).EQ.0) GOTO 109
C
          GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 2)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENT(NA2+IBAS,ND2+LBAS)
C
          GXCH(NC1+KBAS,NB2+JBAS) = GXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENT(NA2+IBAS,ND2+LBAS)
C
          GXCH(NC2+KBAS,NB1+JBAS) = GXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENT(NA2+IBAS,ND2+LBAS)
C
          GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENT(NA2+IBAS,ND2+LBAS)
C
109       CONTINUE
        ENDDO
      ENDDO
159   CONTINUE
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).NE.1) GOTO 160
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 110
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 110
C
          GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,14)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENT(NB2+JBAS,ND2+LBAS)
C
          GXCH(NC1+KBAS,NA2+IBAS) = GXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENT(NB2+JBAS,ND2+LBAS)
C
          GXCH(NC2+KBAS,NA1+IBAS) = GXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENT(NB2+JBAS,ND2+LBAS)
C
          GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 8)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENT(NB2+JBAS,ND2+LBAS)
C
110       CONTINUE
        ENDDO
      ENDDO
160   CONTINUE
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).NE.1) GOTO 161
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 111
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 111
C
          GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 2)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENT(NA2+IBAS,NC2+KBAS)
C
          GXCH(ND1+LBAS,NB2+JBAS) = GXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENT(NA2+IBAS,NC2+KBAS)
C
          GXCH(ND2+LBAS,NB1+JBAS) = GXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENT(NA2+IBAS,NC2+KBAS)
C
          GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENT(NA2+IBAS,NC2+KBAS)
111       CONTINUE
        ENDDO
      ENDDO
161   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
190   CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5000
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(1).NE.1) GOTO 351
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 301
          N = N+1
          IF(IMTX(M,1).EQ.0) GOTO 301
C
          QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
          QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
          QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,ND2+LBAS)
C
          QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301       CONTINUE
        ENDDO
      ENDDO
351   CONTINUE
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 380
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(2).NE.1) GOTO 352
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 302
          N = N+1
          IF(IMTX(M,2).EQ.0) GOTO 302
C
          QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
          QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
          QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
          QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302       CONTINUE
        ENDDO
      ENDDO
352   CONTINUE
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}
      IF(IFLG(3).NE.1) GOTO 353
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 303
          N = N+1
          IF(IMTX(M,3).EQ.0) GOTO 303
C
          QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,NB2+JBAS)
C
          QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,NB2+JBAS)
C
          QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,NB2+JBAS)
C
          QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303       CONTINUE
        ENDDO
      ENDDO
353   CONTINUE
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).NE.1) GOTO 354
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 304
          N = N+1
          IF(IMTX(M,4).EQ.0) GOTO 304
C
          QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
          QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
          QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
          QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304       CONTINUE
        ENDDO
      ENDDO
354   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
380   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}
      IF(IFLG(5).NE.1) GOTO 355
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 305
          N = N+1
          IF(IMTX(M,5).EQ.0) GOTO 305
C
          QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
          QXCH(NA1+IBAS,ND2+LBAS) = QXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
          QXCH(NA2+IBAS,ND1+LBAS) = QXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,NB2+JBAS)
C
          QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305       CONTINUE
        ENDDO
      ENDDO
355   CONTINUE
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 390
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).NE.1) GOTO 356
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 306
          N = N+1
          IF(IMTX(M,6).EQ.0) GOTO 306
C
          QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
          QXCH(NA1+IBAS,NC2+KBAS) = QXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
          QXCH(NA2+IBAS,NC1+KBAS) = QXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NB2+JBAS)
C
          QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306       CONTINUE
        ENDDO
      ENDDO
356   CONTINUE
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).NE.1) GOTO 357
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 307
          N = N+1
          IF(IMTX(M,7).EQ.0) GOTO 307
C
          QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
          QXCH(NB1+JBAS,ND2+LBAS) = QXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
          QXCH(NB2+JBAS,ND1+LBAS) = QXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
          QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307       CONTINUE
        ENDDO
      ENDDO
357   CONTINUE
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).NE.1) GOTO 358
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 308
          N = N+1
          IF(IMTX(M,8).EQ.0) GOTO 308
C
          QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENO(ND2+LBAS,NA2+IBAS)
C
          QXCH(NB1+JBAS,NC2+KBAS) = QXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENO(ND2+LBAS,NA2+IBAS)
C
          QXCH(NB2+JBAS,NC1+KBAS) = QXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENO(ND2+LBAS,NA2+IBAS)
C
          QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENO(ND2+LBAS,NA2+IBAS)
C
308       CONTINUE
        ENDDO
      ENDDO
358   CONTINUE
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}
      IF(IFLG(9).NE.1) GOTO 359
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 309
          N = N+1
          IF(IMTX(M,9).EQ.0) GOTO 309
C
          QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,ND2+LBAS)
C
          QXCH(NC1+KBAS,NB2+JBAS) = QXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,ND2+LBAS)
C
          QXCH(NC2+KBAS,NB1+JBAS) = QXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,ND2+LBAS)
C
          QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309       CONTINUE
        ENDDO
      ENDDO
359   CONTINUE
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).NE.1) GOTO 360
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 310
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 310
C
          QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,ND2+LBAS)
C
          QXCH(NC1+KBAS,NA2+IBAS) = QXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
          QXCH(NC2+KBAS,NA1+IBAS) = QXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,ND2+LBAS)
C
          QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310       CONTINUE
        ENDDO
      ENDDO
360   CONTINUE
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).NE.1) GOTO 361
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 311
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 311
C
          QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(NA2+IBAS,NC2+KBAS)
C
          QXCH(ND1+LBAS,NB2+JBAS) = QXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(NA2+IBAS,NC2+KBAS)
C
          QXCH(ND2+LBAS,NB1+JBAS) = QXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
          QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311       CONTINUE
        ENDDO
      ENDDO
361   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
390   CONTINUE
C
C     SKIP POINT FOR CLOSED SYSTEMS
5000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VISSCHR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       VV    VV IIII SSSSSS   SSSSSS   CCCCCC  HH    HH RRRRRRR       C
C       VV    VV  II SS    SS SS    SS CC    CC HH    HH RR    RR      C
C       VV    VV  II SS       SS       CC       HH    HH RR    RR      C
C       VV    VV  II  SSSSSS   SSSSSS  CC       HHHHHHHH RR    RR      C
C        VV  VV   II       SS       SS CC       HH    HH RRRRRRR       C
C         VVVV    II SS    SS SS    SS CC    CC HH    HH RR    RR      C
C          VV    IIII SSSSSS   SSSSSS   CCCCCC  HH    HH RR    RR      C
C                                                                      C
C -------------------------------------------------------------------- C
C  VISSCHR EVALUATES ALL MULTI-CENTRE ELEMENTS OF THE COULOMB MATRIX   C
C  WHICH INVOLVE A SMALL-SMALL DENSITY FRAGMENT ON ONE NUCLEAR CENTRE. C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION SLL(MBS,MBS),SSS(MBS,MBS),RN(MBS*MBS,4),EXL0(MBS)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2)
C
      COMPLEX*16 PNC(MB2),QLL(MCT),QSS(MCT)
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     REASONS TO SKIP THIS ROUTINE
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'NORL') THEN
        RETURN
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ATOM-CENTRED CHARGES BY COMPONENT TYPE                           C
C**********************************************************************C
C
C     EVALUATE EFFECTIVE SMALL-COMPONENT CHARGES, QSS
      DO IZ=1,NCNT
C
C       INITIALISE THE COUNTERS
        QLL(IZ) = DCMPLX(0.0D0,0.0D0)
        QSS(IZ) = DCMPLX(0.0D0,0.0D0)
C
C       LOOP OVER ALL SYMMETRY TYPES ON CENTRE IZ
        DO K0=1,NKAP(IZ)
C
C         QUANTUM NUMBERS FOR THIS BLOCK
          KQN0 = KAPA(K0,IZ)
          LQN0 = LVAL(KQN0)
          RL0 = DFLOAT(LQN0)
C
C         BASIS EXPONENTS FOR THIS BLOCK
          NBAS0 = NFNC(LQN0,IZ)
          DO IBAS=1,NBAS0
            EXL0(IBAS) = BEXL(IBAS,LQN0,IZ)
            EXL0(IBAS) = BEXL(IBAS,LQN0,IZ)
          ENDDO
C
C         GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
          CALL RNORM0(RN,EXL0,NBAS0,LQN0)
C
C         LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
          M = 0
          DO IBAS=1,NBAS0
            EI = EXL0(IBAS)
            DO JBAS=1,NBAS0
              M   = M+1
              EJ  = EXL0(JBAS)
              EIJ = EI+EJ
              EPR = EI*EJ
              T32 = RL0+1.5D0
              T52 = RL0+2.5D0
              E32 = EIJ**T32
              E52 = EIJ**T52
              SLL(IBAS,JBAS) = 0.5D0*RN(M,1)*GAMHLF(2*LQN0+3)/E32
              SSS(IBAS,JBAS) = 2.0D0*RN(M,4)*GAMHLF(2*LQN0+5)*EPR/E52
            ENDDO
          ENDDO
C
C         LOOP OVER ALL MQN TYPES FOR THIS KQN
          DO M0=1,IABS(KQN0)
C
C           2*MQN0 VALUE
            MQN0 = 2*M0-1
C
C           RELEVANT COMPONENT OFFSETS
            IL1 = LRGE(IZ,K0,MQN0  )
            IL2 = LRGE(IZ,K0,MQN0+1)
C
            IS1 = IL1+NSKP
            IS2 = IL2+NSKP
C
C           ADD TO COUNTERS
            DO IBAS=1,NBAS0
              DO JBAS=1,NBAS0
C
                QLL(IZ) = QLL(IZ)
     &                  + DENT(IL1+IBAS,IL1+JBAS)*SLL(IBAS,JBAS)
     &                  + DENT(IL2+IBAS,IL2+JBAS)*SLL(IBAS,JBAS)
C
                QSS(IZ) = QSS(IZ)
     &                  + DENT(IS1+IBAS,IS1+JBAS)*SSS(IBAS,JBAS)
     &                  + DENT(IS2+IBAS,IS2+JBAS)*SSS(IBAS,JBAS)
C
              ENDDO
            ENDDO
C
C         END LOOP OVER MQN TYPES
          ENDDO
C
C       END LOOP OVER SYMMETRY TYPES
        ENDDO
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
      IF(ICNTA.NE.ICNTB) GOTO 1100
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
c
      goto 567
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NO ATOM-CENTRED CONTRIBUTIONS
        IF(ICNTA.EQ.IZ.AND.ICNTB.EQ.IZ) GOTO 3101
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
CC       GAUSSIAN CHARGE OPTIONS
C        XI = BEXL(1,0,IZ)
C        FC = 1.0D0
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
C
C           OPTIONS FOR POINT CHARGE
            ESM    = EIJ+XI
            APH(M) = EIJ
            PNC(M) = 2.0D0*QSS(IZ)*PI/EIJ
CC
CC           OPTIONS FOR GAUSSIAN CHARGE
C            ESM    = EIJ+XI
C            APH(M) = EIJ*XI/ESM
C            PNC(M) = 2.0D0*PI*QSS(IZ)*FC*DSQRT(XI/ESM)/EIJ
CC
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL RMAKE(RC,CP,APH,MAXAB,LAMLL)
        CALL SYSTEM_CLOCK(ICL2)
        TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
C
C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO IAB=1,NTUVLL
              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,IAB)*RC(M,IAB)
              VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,IAB)*RC(M,IAB)
            ENDDO
            VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
            VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
C
3101    CONTINUE
C
C     END LOOP OVER CENTRES IZ
      ENDDO

567   continue
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(EQFILE) THEN
        DO IAB=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (IAB-1)*MAXAB
          DO M=1,MAXAB
            E11(M,IAB) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,IAB) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NO ATOM-CENTRED CONTRIBUTIONS
        IF(ICNTA.EQ.IZ.AND.ICNTB.EQ.IZ) GOTO 3201
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
CC       GAUSSIAN CHARGE OPTIONS
        XI = BEXL(1,0,IZ)
        FC = 1.0D0
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
C
C           OPTIONS FOR POINT CHARGE
c            ESM    = EIJ+XI
c            APH(M) = EIJ
c            PNC(M) = 2.0D0*QSS(IZ)*PI/EIJ
CC
CC           OPTIONS FOR GAUSSIAN CHARGE
            ESM    = EIJ+XI
            APH(M) = EIJ*XI/ESM
            PNC(M) = 2.0D0*PI*QSS(IZ)*FC*DSQRT(XI/ESM)/EIJ
CC
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL RMAKE(RC,CP,APH,MAXAB,LAMSS)
        CALL SYSTEM_CLOCK(ICL2)
        TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
C
C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ESS0 AND RC)
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO IAB=1,NTUVSS
              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,IAB)*RC(M,IAB)
              VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,IAB)*RC(M,IAB)
            ENDDO
            VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
            VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
          ENDDO
        ENDDO
C
3201    CONTINUE
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF GDIR FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
      GOTO 568
C
C     LL NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            GDIR(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            GDIR(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            GDIR(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            GDIR(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            GDIR(JL1+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL2+JBAS))
            GDIR(JL1+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            GDIR(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            GDIR(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            GDIR(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            GDIR(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            GDIR(JL1+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL2+JBAS))
            GDIR(JL1+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF

568   CONTINUE
C
C     SS NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            GDIR(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            GDIR(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            GDIR(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            GDIR(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            GDIR(JS1+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS2+JBAS))
            GDIR(JS1+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            GDIR(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            GDIR(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            GDIR(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            GDIR(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            GDIR(JS1+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS2+JBAS))
            GDIR(JS1+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     END LOOPS OVER BASIS PAIRS A,B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1100  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BREIT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT               C
C               BB    BB RR    RR EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEE    II     TT                  C
C               BB    BB RRRRRRR  EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEEEE IIII    TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT GENERATES ALL MANY-CENTRE BREIT INTERACTION INTEGRALS IN      C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL BREIT MATRIX.    C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  TODO: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*80 TITLE
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),LQN(4),JQN(4),MQN(4),NBAS(4)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     INTEGRAL SCREENING SENSITIVITY PARAMETER
      DATA SENS/1.0D-12/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER (INTEGRAL SYMMETRY MATTERS)
      IF(INTSYM) THEN
        ITSTRT = 2
        ITSTOP = 2
        ITSKIP = 1
      ELSE
        ITSTRT = 2
        ITSTOP = 3
        ITSKIP = 1
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
            LENIQ               = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL NUCLEAR CENTRES (USE INDEX 1000)                   C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1003 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1004 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS (DEFER TO RACAH ALGEBRA ROUTINE)
      IF(MCNT.EQ.1.AND.RACAH1) THEN
        GOTO 1100
      ENDIF
C
C     SKIP MULTI-CENTRE CONTRIBUTIONS IN STAGE 1
      IF(MCNT.NE.1.AND.ILEV.LE.2) GOTO 1100
C
cC     SKIP INTEGRALS UNLESS THEY COME FROM TWO 1-CENTRE DENSITIES
c      IF(VSDNSB) THEN
c        IF(ICNTA.NE.ICNTB.OR.ICNTC.NE.ICNTD) GOTO 1100
c      ENDIF
      
c     IF(ICNTA.EQ.ICNTB.AND.ICNTC.EQ.ICNTD) GOTO 1101
C     IF(ICNTA.EQ.ICNTC.AND.ICNTB.EQ.ICNTD) GOTO 1101
C     IF(ICNTA.EQ.ICNTD.AND.ICNTC.EQ.ICNTB) GOTO 1101
C     IF(ICNTA.EQ.ICNTB.AND.ICNTA.EQ.ICNTC) GOTO 1101
C     IF(ICNTA.EQ.ICNTB.AND.ICNTA.EQ.ICNTD) GOTO 1101
C     IF(ICNTA.EQ.ICNTC.AND.ICNTC.EQ.ICNTD) GOTO 1101
c     IF(ICNTB.EQ.ICNTC.AND.ICNTC.EQ.ICNTD) GOTO 1101
C     GOTO 1100
C1101  CONTINUE
C
C     REPLACE BREIT INTERACTION WITH GAUNT ONLY
      IF(GAUNT2) THEN
        BGAUNT = .TRUE.
      ELSE
        BGAUNT = .FALSE.
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL LQN ORBITAL TYPES (USE INDEX 2000)                 C
C**********************************************************************C
C
C     LOOP OVER LQN(A) VALUES
      DO 2001 LA=0,(NKAP(ICNTA)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK A
        LQN(1) = LA
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER LQN(B) VALUES
      DO 2002 LB=0,(NKAP(ICNTB)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK B
        LQN(2) = LB
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER LQN(C) VALUES
      DO 2003 LC=0,(NKAP(ICNTC)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK C
        LQN(3) = LC
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER LQN(D) VALUES
      DO 2004 LD=0,(NKAP(ICNTD)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK D
        LQN(4) = LD
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 2100
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES FOR THESE LQNS (USE INDEX 3000) C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 3001 NA=KRONECK(LA,0),1
        KA = 2*LA+NA
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        JQN(1) = 2*IABS(KQN(1))-1
C
C     LOOP OVER KQN(B) VALUES
      DO 3002 NB=KRONECK(LB,0),1
        KB = 2*LB+NB
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        JQN(2) = 2*IABS(KQN(2))-1
C
C     LOOP OVER KQN(C) VALUES
      DO 3003 NC=KRONECK(LC,0),1
        KC = 2*LC+NC
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        JQN(3) = 2*IABS(KQN(3))-1
C
C     LOOP OVER KQN(D) VALUES
      DO 3004 ND=KRONECK(LD,0),1
        KD = 2*LD+ND
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        JQN(4) = 2*IABS(KQN(4))-1
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 3100
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         CASE 1: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH ODD (UNLESS NU=0)
          IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) ISELK = 1
C
C         CASE 2: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 3100
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 4001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 4002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IEAB  = 1
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSL = IADISL(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 4003 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 4004 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      IECD  = 1
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSL = IADISL(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        ISELM = 0
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4).AND.NOPN.EQ.0) ISELM=1
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) ISELM=1
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) ISELM=1
        IF(ISELM.EQ.0) GOTO 4100
      ENDIF
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO MMA=1,2
          DO MMB=1,2
            DO MMC=1,2
              DO MMD=1,2
                MMJA = MQN(1)*((-1)**MMA)
                MMJB = MQN(2)*((-1)**MMB)
                MMJC = MQN(3)*((-1)**MMC)
                MMJD = MQN(4)*((-1)**MMD)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 4100
      ENDIF
C
C**********************************************************************C
C     IDENTIFICATION OF BII SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     STARTING INDEX VALUES
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C      IQL = (IQ1-1)*LENIQ + IQ2
C      IQR = (IQ3-1)*LENIQ + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(INTSYM.AND.IQL.LT.IQR) GOTO 4100
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
C     NB! OPPOSITE PHASE AS IN THE LL/SS CASE SEEN IN COULOMB
      PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LS (2) or SL (3)
      DO 5001 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR BII ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.2) THEN
          NADDA = 0
          NADDB = NSKP
        ELSEIF(IT1.EQ.3) THEN
          NADDA = NSKP
          NADDB = 0
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDA
        NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDA
        NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDB
        NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDB
C
C       FLAG READ-IN OF EI(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C                                              _
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LS (2) or SL (3)
      DO 5002 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.2) THEN
          NADDC = 0
          NADDD = NSKP
        ELSEIF(IT2.EQ.3) THEN
          NADDC = NSKP
          NADDD = 0
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDC
        NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDC
        ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDD
        ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C       COMPONENT OVERLAP INDEX {(LS|LS)=5,(LS|SL)=6,(SL|LS)=7,(SL|SL)=8}
        ITT = MAPTTTT(IT1,IT2)
C
C       UPDATE COUNTER FOR NUMBER OF BLOCKS
        N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT WDIR/WMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(SCHWRZ) THEN
            ITOG = 1
          ELSE
            ITOG = 0
          ENDIF
C
C         CALL THE SCREENING ROUTINE
          CALL SYSTEM_CLOCK(ICL3)
          CALL SCHWARZ(BDSC,SENS)
          CALL SYSTEM_CLOCK(ICL4)
          TB2S = TB2S + DFLOAT(ICL4-ICL3)/RATE
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT) + NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT) + NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE A BATCH OF BREIT INTERACTION INTEGRALS
            CALL BII(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO WDIR/WMAT
            CALL SYSTEM_CLOCK(ICL5)
            IF(ISYM.EQ.0) THEN
              CALL BRTMTG(RR)
            ELSE
              CALL BRTMTZ(RR)
            ENDIF
            CALL SYSTEM_CLOCK(ICL6)
            TBMC = TBMC + DFLOAT(ICL6-ICL5)/RATE
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT END OF BATCH
      CALL SYSTEM_CLOCK(ICL2)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + DFLOAT(ICL2-ICL1)/RATE
C
5002  CONTINUE
5001  CONTINUE
4100  CONTINUE
4004  CONTINUE
4003  CONTINUE
4002  CONTINUE
4001  CONTINUE
3100  CONTINUE
3004  CONTINUE
3003  CONTINUE
3002  CONTINUE
3001  CONTINUE
2100  CONTINUE
2004  CONTINUE
2003  CONTINUE
2002  CONTINUE
2001  CONTINUE
1100  CONTINUE
1004  CONTINUE
1003  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF BREIT MATRIX BY MATRIX CONJUGATION.     C
C**********************************************************************C
C
      DO I=1,NDIM-NSKP
        DO J=NSKP+1,NDIM
          BDIR(J,I) = DCONJG(BDIR(I,J))
          BXCH(J,I) = DCONJG(BXCH(I,J))
          WDIR(J,I) = DCONJG(WDIR(I,J))
          WXCH(J,I) = DCONJG(WXCH(I,J))
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS (LIFTED FROM COULOMB)
      IF(NOPN.GT.0) THEN
        DO J=1,NDIM
          DO I=1,NDIM
            WDIR(I,J) = ACFF*WDIR(I,J)
            WXCH(I,J) = BCFF*WXCH(I,J)
          ENDDO
        ENDDO
      ENDIF
CC
C      TITLE = 'BREIT-FORWARD'
C      CALL ZGNUMAP(BXCH,TITLE,NDIM)
C
      RETURN
      END
C
C
      SUBROUTINE BII(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          BBBBBBB IIII IIII                           C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB  II   II                            C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB IIII IIII                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  BII GENERATES A BATCH OF MOLECULAR BREIT INTERACTION INTEGRALS BY   C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ    - FULL SET OF CARTESIAN BASIS CENTRES.                     C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ KQN    - FULL SET OF RELATIVISTIC LABELS.                         C
C  ▶ MQN    - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).        C
C  ▶ NBAS   - FULL SET OF EXPONENT LIST LENGTHS.                       C
C  ▶ EXL    - FULL LISTS OF EXPONENTS IN THE BLOCK.                    C
C  ▶ IBAS   - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).       C
C  ▶ JBAS   - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).       C
C  ▶ ITN    - COMPONENT OVERLAP COMBINATION.                           C
C  OUTPUT:                                                             C
C  ▶ RR     - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL L0CASE
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),LQN(4),MQN(4),NBAS(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),T(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MB2,MEQ,3),IABI11(MB2,MEQ,3),
     &          IABR21(MB2,MEQ,3),IABI21(MB2,MEQ,3)
      DIMENSION ICDR11(MEQ,3),ICDI11(MEQ,3),ICDR21(MEQ,3),ICDI21(MEQ,3)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
      DIMENSION IDX(3),JDX(3)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ,3),EAB21(MB2,MEQ,3),
     &           ECD11(MB2,MEQ,3),ECD21(MB2,MEQ,3)
C
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA SENS/1.0D-16/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.2.AND.ITN(IT).NE.3) THEN
          WRITE(6, *) 'In BII: illegal component overlaps in ITN.'
          WRITE(7, *) 'In BII: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      DO N=1,4
        LQN(N) = LVAL(KQN(N))
      ENDDO
C
C     SPECIAL CASE FOR S-TYPE OVERLAPS (ONLY EVER NEEDED ONCE)
      IF(LQN(1)+LQN(2)+LQN(3)+LQN(4).EQ.0) THEN
        L0CASE = .TRUE.
      ELSE
        L0CASE = .FALSE.
      ENDIF
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTOR FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ-COEFFICIENTS
      LAMAB = LQN(1)+LQN(2)+1
      LAMCD = LQN(3)+LQN(4)+1
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR CONTRACTED R-INTEGRAL BATCH
      IF(BGAUNT) THEN
C       GAUNT INTEGRALS ONLY
        LAMABCD = LAMAB+LAMCD
      ELSE
C       FULL BREIT INTERACTION
        LAMABCD = LAMAB+LAMCD+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
      CALL SYSTEM_CLOCK(ICL2)
      TBAX = TBAX + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
      IF(EQFILE) THEN
C
C       OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
        IF(ITN(1).EQ.2) THEN
          DO IAB=1,NTUVAB
            IAD = IABLS + (IAB-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,IAB,1) = DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
              EAB21(M,IAB,1) = DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
              EAB11(M,IAB,2) = DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
              EAB21(M,IAB,2) = DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
              EAB11(M,IAB,3) = DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
              EAB21(M,IAB,3) = DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.3) THEN
          DO IAB=1,NTUVAB
            IAD = IABSL + (IAB-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,IAB,1) = DCMPLX(EISLFL(IAD+M, 1),EISLFL(IAD+M, 2))
              EAB21(M,IAB,1) = DCMPLX(EISLFL(IAD+M, 3),EISLFL(IAD+M, 4))
              EAB11(M,IAB,2) = DCMPLX(EISLFL(IAD+M, 5),EISLFL(IAD+M, 6))
              EAB21(M,IAB,2) = DCMPLX(EISLFL(IAD+M, 7),EISLFL(IAD+M, 8))
              EAB11(M,IAB,3) = DCMPLX(EISLFL(IAD+M, 9),EISLFL(IAD+M,10))
              EAB21(M,IAB,3) = DCMPLX(EISLFL(IAD+M,11),EISLFL(IAD+M,12))
            ENDDO
          ENDDO
        ENDIF
C
      ELSE
C
C       OPTION 2: CALCULATE FROM SCRATCH
        IF(ITN(1).EQ.2) THEN
          CALL EILSB3(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
        ELSEIF(ITN(1).EQ.3) THEN
          CALL EISLB3(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
        ENDIF
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL4)
      IF(ITN(1).EQ.2) THEN
        TELS = TELS + DFLOAT(ICL4-ICL3)/RATE
      ELSEIF(ITN(1).EQ.3) THEN
        TESL = TESL + DFLOAT(ICL4-ICL3)/RATE
      ENDIF
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH IAB
      CALL SYSTEM_CLOCK(ICL3,RATE)
      DO ICMP=1,3
        DO IAB=1,NTUVAB
C
C         Re{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(DREAL(EAB11(M,IAB,ICMP))).GT.SENS) THEN
              IABR11(M,IAB,ICMP) = 1
            ELSE
              IABR11(M,IAB,ICMP) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(DIMAG(EAB11(M,IAB,ICMP))).GT.SENS) THEN
              IABI11(M,IAB,ICMP) = 1
            ELSE
              IABI11(M,IAB,ICMP) = 0
            ENDIF
          ENDDO
C
C         Re{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(DREAL(EAB21(M,IAB,ICMP))).GT.SENS) THEN
              IABR21(M,IAB,ICMP) = 1
            ELSE
              IABR21(M,IAB,ICMP) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(DIMAG(EAB21(M,IAB,ICMP))).GT.SENS) THEN
              IABI21(M,IAB,ICMP) = 1
            ELSE
              IABI21(M,IAB,ICMP) = 0
            ENDIF
          ENDDO
C
        ENDDO
      ENDDO
      CALL SYSTEM_CLOCK(ICL4)
      TB2S = TB2S + DFLOAT(ICL4-ICL3)/RATE
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(2).EQ.2) THEN
          DO ICD=1,NTUVCD
            IAD = ICDLS + (ICD-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ICD)))
            DO M=1,MAXCD
            ECD11(M,ICD,1)=Z*DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            ECD21(M,ICD,1)=Z*DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            ECD11(M,ICD,2)=Z*DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            ECD21(M,ICD,2)=Z*DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            ECD11(M,ICD,3)=Z*DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            ECD21(M,ICD,3)=Z*DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.3) THEN
          DO ICD=1,NTUVCD
            IAD = ICDSL + (ICD-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ICD)))
            DO M=1,MAXCD
            ECD11(M,ICD,1)=Z*DCMPLX(EISLFL(IAD+M, 1),EISLFL(IAD+M, 2))
            ECD21(M,ICD,1)=Z*DCMPLX(EISLFL(IAD+M, 3),EISLFL(IAD+M, 4))
            ECD11(M,ICD,2)=Z*DCMPLX(EISLFL(IAD+M, 5),EISLFL(IAD+M, 6))
            ECD21(M,ICD,2)=Z*DCMPLX(EISLFL(IAD+M, 7),EISLFL(IAD+M, 8))
            ECD11(M,ICD,3)=Z*DCMPLX(EISLFL(IAD+M, 9),EISLFL(IAD+M,10))
            ECD21(M,ICD,3)=Z*DCMPLX(EISLFL(IAD+M,11),EISLFL(IAD+M,12))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(2).EQ.2) THEN
          CALL EILSB3(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
        ELSEIF(ITN(2).EQ.3) THEN
          CALL EISLB3(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL4)
      IF(ITN(2).EQ.2) THEN
        TELS = TELS + DFLOAT(ICL4-ICL3)/RATE
      ELSEIF(ITN(2).EQ.3) THEN
        TESL = TESL + DFLOAT(ICL4-ICL3)/RATE
      ENDIF
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO JCMP=1,3
        DO ICD=1,NTUVCD
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR11(ICD,JCMP) = 1
              GOTO 201
            ENDIF
          ENDDO
          ICDR11(ICD,JCMP) = 0
201       CONTINUE
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI11(ICD,JCMP) = 1
              GOTO 202
            ENDIF
          ENDDO
          ICDI11(ICD,JCMP) = 0
202       CONTINUE
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR21(ICD,JCMP) = 1
              GOTO 203
            ENDIF
          ENDDO
          ICDR21(ICD,JCMP) = 0
203       CONTINUE
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI21(ICD,JCMP) = 1
              GOTO 204
            ENDIF
          ENDDO
          ICDI21(ICD,JCMP) = 0
204       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL ASKED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL SYSTEM_CLOCK(ICL2)
      TBEC = TBEC + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) INTEGRALS IF PROMPTED            C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M   = M+1
          EKL = EXL(KBAS,3)+EXL(LBAS,4)
          QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
          QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
          QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
          PQ(M,1) = QX-PX
          PQ(M,2) = QY-PY
          PQ(M,3) = QZ-PZ
          APH(M)  = EIJ*EKL/(EIJ+EKL)
        ENDDO
      ENDDO
C
C     SKIP IF INTEGRAL BATCH EXISTS IN FILE
      IF(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0) GOTO 300
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     BATCH SIZE AND EXPANSION LENGTH DEPENDS ON MODE
      IF(RCFILE.AND..NOT.L0CASE) THEN
        MBCH = MAXCD
      ELSE
        MBCH = MAXN
      ENDIF
C
C     SHORTEN RMAKE DATA IF POSSIBLE
      IF(ITOG.NE.0) THEN
        IF(.NOT.RCFILE.OR.L0CASE) THEN
          DO N=1,MAXN
            PQ(N,1) = PQ(IMAP(N),1)
            PQ(N,2) = PQ(IMAP(N),2)
            PQ(N,3) = PQ(IMAP(N),3)
            APH(N)  = APH(IMAP(N))
          ENDDO
        ENDIF
      ENDIF
C
C     GENERATE R-INTEGRALS
      CALL RMAKE(RC,PQ,APH,MBCH,LAMABCD)
C
C     SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
      DO IABCD=1,NTUVABCD
C
C       SUM OF RC(AB|CD) MAGNITUDES
        SUM = 0.0D0
        DO N=1,MBCH
          SUM = SUM + DABS(RC(N,IABCD))
          IF(SUM.GT.SENS) THEN
            IRC(IABCD) = 1
            GOTO 301
          ENDIF
        ENDDO
        IRC(IABCD) = 0
301     CONTINUE
C
      ENDDO
C
      CALL SYSTEM_CLOCK(ICL4)
      TBRM = TBRM + DFLOAT(ICL4-ICL3)/RATE
C
C     CONTINUE ONLY IF INTEGRALS ARE TO BE SAVED TO LARGE FILE
      IF(.NOT.RCFILE.OR.L0CASE) GOTO 300
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
      IF(20*MFL.LT.IJ*MAXCD*NTUVABCD) THEN
C       OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
        WRITE(6, *) 'In BII: RCTT words exceed allocated limit.'
        WRITE(7, *) 'In BII: RCTT words exceed allocated limit.'
        STOP
        GOTO 300
      ELSE
C       DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
        IRIJ(IBAS,JBAS) = 0
      ENDIF
C
C     STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
      IADRTT = (IJ-1)*MAXCD*NTUVABCD
C
C     COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
      DO IABCD=1,NTUVABCD
        IAD = IADRTT + MAXCD*(IABCD-1)
        DO M=1,MAXCD
          RCTTFL(IAD+M) = RC(M,IABCD)
        ENDDO
      ENDDO
C
C     STARTING ADDRESS FOR SCREENING FLAGS
      IADSCR = (IJ-1)*NTUVABCD
C
C     COPY SCREENING MARKERS TO A SAVED LIST
      DO IABCD=1,NTUVABCD
        IRCTTFL(IADSCR+IABCD) = IRC(IABCD)
      ENDDO
C
      CALL SYSTEM_CLOCK(ICL4)
      TBRW = TBRW + DFLOAT(ICL4-ICL3)/RATE
C
300   CONTINUE
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL SYSTEM_CLOCK(ICL2)
      TRBR = TRBR + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     LOOP OVER CARTESIAN INDEX ICMP FOR CENTRE AB (USE INDEX 6000)
      DO 6000 ICMP=1,3
C
C     TIME AT START OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     CARTESIAN INDEX ICMP AS A VECTOR, IDX
      CALL NCART(IDX,ICMP)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) FAILS SCREENING CONDITION
        IABALL = IABR11(IJ,IAB,ICMP) + IABI11(IJ,IAB,ICMP)
     &         + IABR21(IJ,IAB,ICMP) + IABI21(IJ,IAB,ICMP)
        IF(IABALL.EQ.0) GOTO 401
C
C >>>>> GAUNT INTERACTION
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),IC(IAB)+IC(ICD))
C
C         CALCULATE DIRECTLY FROM RC(AB|CD) LOCAL ARRAY
          IF(.NOT.RCFILE.OR.L0CASE) THEN
C
C           SKIP THIS STEP IF THE E(CD) FAILS SCREENING CONDITION
            ICDALL = ICDR11(ICD,ICMP) + ICDI11(ICD,ICMP)
     &             + ICDR21(ICD,ICMP) + ICDI21(ICD,ICMP)
            IF(ICDALL.EQ.0) GOTO 402
C
C           SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
            IF(IRC(IRABCD).EQ.0) GOTO 402
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(IABR11(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 411
            IF(ICDR11(ICD,ICMP).EQ.0) GOTO 411
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                  + DREAL(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
411         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(IABI11(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 412
            IF(ICDI11(ICD,ICMP).EQ.0) GOTO 412
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                  + DIMAG(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
412         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(IABR21(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 413
            IF(ICDR21(ICD,ICMP).EQ.0) GOTO 413
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                  + DREAL(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
413         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(IABI21(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 414
            IF(ICDI21(ICD,ICMP).EQ.0) GOTO 414
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                  + DIMAG(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
414         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
402         CONTINUE
C
          ELSE
C
C           SKIP THIS STEP IF THE E(CD) FAILS SCREENING CONDITION
            ICDALL = ICDR11(ICD,ICMP)+ICDI11(ICD,ICMP)+ICDR21(ICD,ICMP)
     &                                                +ICDI21(ICD,ICMP)
            IF(ICDALL.EQ.0) GOTO 462
C
C           STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
            IAD = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IRABCD-1)
C
C           SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
            IF(IRCTTFL((IJ-1)*NTUVABCD+IRABCD).EQ.0) GOTO 462
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(IABR11(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 451
            IF(ICDR11(ICD,ICMP).EQ.0) GOTO 451
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &           + DREAL(ECD11(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
            ENDDO
451         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(IABI11(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 452
            IF(ICDI11(ICD,ICMP).EQ.0) GOTO 452
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &           + DIMAG(ECD11(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
            ENDDO
452         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(IABR21(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 453
            IF(ICDR21(ICD,ICMP).EQ.0) GOTO 453
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &           + DREAL(ECD21(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
            ENDDO
453         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(IABI21(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 454
            IF(ICDI21(ICD,ICMP).EQ.0) GOTO 454
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &           + DIMAG(ECD21(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
            ENDDO
454         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
462         CONTINUE
C
          ENDIF
C
C >>>>>   GAUGE TERM (REQUIRES ADDITIONAL CARTESIAN SUM Q')
          IF(BGAUNT) GOTO 480
C
C         LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
          DO JCMP=1,3
C
C           SKIP THIS STEP IF THE E(CD) FAILS SCREENING CONDITION
            IF(ICDR11(ICD,JCMP)+ICDI11(ICD,JCMP)
     &                    +ICDR21(ICD,JCMP)+ICDI21(ICD,JCMP).EQ.0) THEN
              GOTO 403
            ENDIF
C
C           CARTESIAN INDEX JCMP AS A VECTOR, JDX
            CALL NCART(JDX,JCMP)
C
C           NEW ADDRESS DEPENDING ON JCMP CARTESIAN INDEX
            IF(JCMP.EQ.1) THEN
              RTP = DFLOAT(IA(IAB)+IA(ICD))
            ELSEIF(JCMP.EQ.2) THEN
              RTP = DFLOAT(IB(IAB)+IB(ICD))
            ELSEIF(JCMP.EQ.3) THEN
              RTP = DFLOAT(IC(IAB)+IC(ICD))
            ENDIF
C
C           FIRST CONTRIBUTION ADDRESS
            I1 = IA(IAB)+IA(ICD)+IDX(1)+JDX(1)
            J1 = IB(IAB)+IB(ICD)+IDX(2)+JDX(2)
            K1 = IC(IAB)+IC(ICD)+IDX(3)+JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR1 = IABC(I1,J1,K1)
C
C           SECOND CONTRIBUTION ADDRESS
            I2 = IA(IAB)+IA(ICD)+IDX(1)
            J2 = IB(IAB)+IB(ICD)+IDX(2)
            K2 = IC(IAB)+IC(ICD)+IDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR2 = IABC(I2,J2,K2)
C
C           THIRD CONTRIBUTION ADDRESS
            I3 = IA(IAB)+IA(ICD)+IDX(1)-JDX(1)
            J3 = IB(IAB)+IB(ICD)+IDX(2)-JDX(2)
            K3 = IC(IAB)+IC(ICD)+IDX(3)-JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
              IADR3 = IABC(I3,J3,K3)
            ELSE
              IADR3 = 0
            ENDIF
C
C           CALCULATE DIRECTLY FROM RC(AB|CD) LOCAL ARRAY
            IF(.NOT.RCFILE.OR.L0CASE) THEN
C
C             SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
              IF(IADR3.NE.0) THEN
                IF(IRC(IADR1)+IRC(IADR2)+IRC(IADR3).EQ.0) GOTO 403
              ELSE
                IF(IRC(IADR1)+IRC(IADR2).EQ.0) GOTO 403
              ENDIF
C
C             PRE-FACTORS FOR THE UPCOMING CONTRACTION
              DO N=1,MAXN
                T1 = RC(N,IADR1)*0.5D0/APH(N)
                T2 = RC(N,IADR2)*PQ(N,JCMP)
                IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                  T3 = RC(N,IADR3)*RTP
                ELSE
                  T3 = 0.0D0
                ENDIF
                T(N) = T1-T2+T3
              ENDDO
C
            ELSE
C
C             SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
              IA1 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR1-1)
              IA2 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR2-1)
              IA3 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR3-1)
              IF(IADR3.NE.0) THEN
                IF(IA1+IA2+IA3.EQ.0) GOTO 403
              ELSE
                IF(IA1+IA2.EQ.0) GOTO 403
              ENDIF
C
C             PRE-FACTORS FOR THE UPCOMING CONTRACTION
              DO N=1,MAXN
                T1 = RCTTFL(IA1+IMAP(N))*0.5D0/APH(IMAP(N))
                T2 = RCTTFL(IA2+IMAP(N))*PQ(IMAP(N),JCMP)
                IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                  T3 = RCTTFL(IA3+IMAP(N))*RTP
                ELSE
                  T3 = 0.0D0
                ENDIF
                T(N) = T1-T2+T3
              ENDDO
C
            ENDIF
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(IABR11(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 415
            IF(ICDR11(ICD,JCMP).EQ.0) GOTO 415
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                          - DREAL(ECD11(IMAP(N),ICD,JCMP))*T(N)
            ENDDO
415         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(IABI11(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 416
            IF(ICDI11(ICD,JCMP).EQ.0) GOTO 416
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                          - DIMAG(ECD11(IMAP(N),ICD,JCMP))*T(N)
            ENDDO
416         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(IABR21(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 417
            IF(ICDR21(ICD,JCMP).EQ.0) GOTO 417
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                          - DREAL(ECD21(IMAP(N),ICD,JCMP))*T(N)
            ENDDO
417         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(IABI21(IJ,IAB,ICMP).EQ.0.AND.ISYM.GE.1) GOTO 418
            IF(ICDI21(ICD,JCMP).EQ.0) GOTO 418
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                          - DIMAG(ECD21(IMAP(N),ICD,JCMP))*T(N)
            ENDDO
418         CONTINUE
C
C           SKIP POINT FOR E(CD) SCREENING
403         CONTINUE
C
C           END LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
            ENDDO
C
C           SKIP POINT FOR GAUNT INTERACTION ONLY
480         CONTINUE
C
C         END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
          ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL SYSTEM_CLOCK(ICL2)
      TBC1 = TBC1 + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     TIME AT START OF SECOND CONTRACTION FOR THIS ICMP INDEX
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD =-ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     SPECIAL CASE: LINEAR MOLECULE OR ATOM
      IF(ISYM.NE.1.AND.ISYM.NE.2) GOTO 501
C
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QR2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),0.0D0)
        RR(N,4 ) = RR(N,4 ) + PCD*DCMPLX(QR1(N)-QR2(N),0.0D0)
      ENDDO
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QR2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),0.0D0)
        RR(N,10) = RR(N,10) - PCD*DCMPLX(QR1(N)-QR2(N),0.0D0)
      ENDDO
C
      GOTO 502
C
C     GENERAL CASE
501   CONTINUE
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,4 ) = RR(N,4 ) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,3 ) = RR(N,3 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,2 ) = RR(N,2 ) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,9 ) = RR(N,9 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = RR(N,12) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IJ,IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) = RR(N,10) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
502   CONTINUE
C
C     TIME AT END OF SECOND CONTRACTION FOR THIS ICMP INDEX
      CALL SYSTEM_CLOCK(ICL2)
      TBC2 = TBC2 + DFLOAT(ICL2-ICL1)/RATE
C
C     END LOOP OVER CARTESIAN INDICES {IX,IY,IZ}
6000  CONTINUE
C
C     HALF OF THE RR ARRAY CAN BE GENERATED WITH PHASE RELATIONS
      DO N=1,MAXN
        RR(N,16) = PABCD*DCONJG(RR(N,1 ))
        RR(N,13) = PABCD*DCONJG(RR(N,4 ))
        RR(N,14) =-PABCD*DCONJG(RR(N,3 ))
        RR(N,15) =-PABCD*DCONJG(RR(N,2 ))
        RR(N,8 ) =-PABCD*DCONJG(RR(N,9 ))
        RR(N,5 ) =-PABCD*DCONJG(RR(N,12))
        RR(N,6 ) = PABCD*DCONJG(RR(N,11))
        RR(N,7 ) = PABCD*DCONJG(RR(N,10))
      ENDDO 
C
C**********************************************************************C
C     BREIT INTEGRAL BATCH NOW FULLY CONSTRUCTED                       C
C**********************************************************************C
C
C     CALCULATE THE R-INTEGRAL NORMALISATION FACTOR
      CALL SYSTEM_CLOCK(ICL1,RATE)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.1) THEN
            EKL = EXL(KBAS,3)+EXL(LBAS,4)
            EMX = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(M) = 2.0D0*PI52/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     INCLUDE THE OUTSIDE FACTOR OF (-1/2) AND MOVE TO FULL ARRAY
      IF(BGAUNT) THEN
        BFAC =-1.0D0
      ELSE
        BFAC =-0.5D0
      ENDIF
C      
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) = BFAC*PRE(IMAP(N))*RR(N,ITG)
        ENDDO
      ENDDO
      CALL SYSTEM_CLOCK(ICL2)
      TBAX = TBAX + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE BRTFAST
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  RRRRRRR TTTTTTTT FFFFFFF    AA     SSSSSS TTTTTTTT      C
C     BB    BB RR    RR   TT    FF        AAAA   SS    SS   TT         C
C     BB    BB RR    RR   TT    FF       AA  AA  SS         TT         C
C     BBBBBBB  RR    RR   TT    FFFFFF  AA    AA  SSSSSS    TT         C
C     BB    BB RRRRRRR    TT    FF      AAAAAAAA       SS   TT         C
C     BB    BB RR    RR   TT    FF      AA    AA SS    SS   TT         C
C     BBBBBBB  RR    RR   TT    FF      AA    AA  SSSSSS    TT         C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTFAST GENERATES ALL MANY-CENTRE BREIT INTERACTION INTEGRALS IN    C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL BREIT MATRIX.    C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  THIS IS A SPECIAL VERSION OF THE USUAL BREIT ROUTINE, DESIGNED TO   C
C  RECYCLE THE INTERMEDIATE INTEGRALS G(  |CD) BY REARRANGING THE LOOP C
C  ORDER WITHIN A GIVEN SET OF LQN'S. LOOP OVER (AB) BASIS FUNCTIONS   C
C  FIRST, AND THEN USE THE SAME INTERMEDIATE INTEGRALS FOR ALL (CD)    C
C  BASIS FUNCTIONS. THE SWAP OF CONTRACTION ORDER IS DONE IN BIIFAST.  C
C -------------------------------------------------------------------- C
C  TODO: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),LQN(4),KQN(4),JQN(4),MQN(4),NBAS(4)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     INTEGRAL SCREENING SENSITIVITY PARAMETER
      DATA SENS/1.0D-12/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER (INTEGRAL SYMMETRY MATTERS)
      IF(INTSYM) THEN
        ITSTRT = 2
        ITSTOP = 2
        ITSKIP = 1
      ELSE
        ITSTRT = 2
        ITSTOP = 3
        ITSKIP = 1
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
            LENIQ               = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL NUCLEAR CENTRES (USE INDEX 1000)                   C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1003 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1004 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS (DEFER TO RACAH ALGEBRA ROUTINE)
      IF(MCNT.EQ.1.AND.RACAH1) THEN
        GOTO 1100
      ENDIF
C
C     SKIP MULTI-CENTRE CONTRIBUTIONS IN STAGE 1
      IF(MCNT.NE.1.AND.ILEV.LT.3) GOTO 1100
C
C     SKIP INTEGRALS UNLESS THEY COME FROM TWO 1-CENTRE DENSITIES
      IF(VSDNSB) THEN
        IF(ICNTA.NE.ICNTB.OR.ICNTC.NE.ICNTD) GOTO 1100
      ENDIF
C
C     REPLACE BREIT INTERACTION WITH GAUNT ONLY
      IF(GAUNT2) THEN
        BGAUNT = .TRUE.
      ELSE
        BGAUNT = .FALSE.
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL LQN ORBITAL TYPES (USE INDEX 2000)                 C
C**********************************************************************C
C
C     LOOP OVER LQN(A) VALUES
      DO 2001 LA=0,(NKAP(ICNTA)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK A
        LQN(1) = LA
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER LQN(B) VALUES
      DO 2002 LB=0,(NKAP(ICNTB)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK B
        LQN(2) = LB
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER LQN(C) VALUES
      DO 2003 LC=0,(NKAP(ICNTC)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK C
        LQN(3) = LC
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER LQN(D) VALUES
      DO 2004 LD=0,(NKAP(ICNTD)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK D
        LQN(4) = LD
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C     EVALUATE SPARSITY LISTS FOR UPCOMING EQ(CD) BATCH
      CALL SYSTEM_CLOCK(ICL1,RATE)
      CALL EILSCD0(ICNT,LQN,NBAS)
      CALL SYSTEM_CLOCK(ICL2)
      TB2S = TB2S + DFLOAT(ICL2-ICL1)/RATE
C
      IF(.NOT.INTSYM) CALL EISLCD0(ICNT,LQN,NBAS)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 2100
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN(AB) SYMMETRY TYPES (USE INDEX 3000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 3001 NA=KRONECK(LA,0),1
        KA = 2*LA+NA
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        JQN(1) = 2*IABS(KQN(1))-1
C
C     LOOP OVER KQN(B) VALUES
      DO 3002 NB=KRONECK(LB,0),1
        KB = 2*LB+NB
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        JQN(2) = 2*IABS(KQN(2))-1
C
C**********************************************************************C
C     LOOP OVER ALL |MQN|(AB) SYMMETRY TYPES (USE INDEX 4000)          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 4001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 4002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IEAB  = 1
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSL = IADISL(ICNTA,ICNTB,KA,KB,MA,MB)
C
C**********************************************************************C
C     LOOP OVER ALL (AB) COMPONENT OVERLAP OPTIONS T1 (USE INDEX 5000) C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LS (2) or SL (3)
      DO 5001 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR BII ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.2) THEN
          NADDA = 0
          NADDB = NSKP
        ELSEIF(IT1.EQ.3) THEN
          NADDA = NSKP
          NADDB = 0
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDA
        NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDA
        NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDB
        NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDB
C
C**********************************************************************C
C     LOOP OVER ALL (AB) BASIS FUNCTIONS (IBAS,JBAS) (USE INDEX 6000)  C
C**********************************************************************C
C
      DO 6001 IBAS=1,NBAS(1)
      DO 6002 JBAS=1,NBAS(2)
C
C     PERFORM FIRST CONTRACTION AGAIN
      IGAB = 1
C
C**********************************************************************C
C     LOOP OVER ALL KQN(CD) SYMMETRY TYPES (USE INDEX 7000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(C) VALUES
      DO 7001 NC=KRONECK(LC,0),1
        KC = 2*LC+NC
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        JQN(3) = 2*IABS(KQN(3))-1
C
C     LOOP OVER KQN(D) VALUES
      DO 7002 ND=KRONECK(LD,0),1
        KD = 2*LD+ND
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        JQN(4) = 2*IABS(KQN(4))-1
C
C     UNIQUE INDEX FOR THIS PAIR OF KAPPAS
      NCD = 2*NC+ND+1
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C     NOTE THAT IF 'RACAH' IS SWITCHED ON, THIS WON'T BE CALLED.       C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 7100
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         CASE 1: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH ODD (UNLESS NU=0)
          IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) ISELK = 1
C
C         CASE 2: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 7100
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL |MQN|(CD) SYMMETRY TYPES (USE INDEX 8000)          C
C**********************************************************************C
C
C     LOOP OVER |MQN(C)| VALUES
      DO 8001 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 8002 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      IECD  = 1
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSL = IADISL(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        ISELM = 0
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4).AND.NOPN.EQ.0) ISELM=1
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) ISELM=1
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) ISELM=1
        IF(ISELM.EQ.0) GOTO 8100
      ENDIF
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO MMA=1,2
          DO MMB=1,2
            DO MMC=1,2
              DO MMD=1,2
                MMJA = MQN(1)*((-1)**MMA)
                MMJB = MQN(2)*((-1)**MMB)
                MMJC = MQN(3)*((-1)**MMC)
                MMJD = MQN(4)*((-1)**MMD)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 8100
      ENDIF
C
C**********************************************************************C
C     IDENTIFICATION OF BII SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     STARTING INDEX VALUES
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C     IQL = (IQ1-1)*LENIQ + IQ2
C     IQR = (IQ3-1)*LENIQ + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(INTSYM.AND.IQL.LT.IQR) GOTO 8100
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
C     NB! OPPOSITE PHASE AS IN THE LL/SS CASE SEEN IN COULOMB
      PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER ALL (CD) COMPONENT OVERLAP OPTIONS T2 (USE INDEX 9000) C        C
C**********************************************************************C
C                                              _
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LS (2) or SL (3)
      DO 9001 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.2) THEN
          NADDC = 0
          NADDD = NSKP
        ELSEIF(IT2.EQ.3) THEN
          NADDC = NSKP
          NADDD = 0
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDC
        NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDC
        ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDD
        ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C       COMPONENT OVERLAP INDEX {(LS|LS)=5,(LS|SL)=6,(SL|LS)=7,(SL|SL)=8}
        ITT = MAPTTTT(IT1,IT2)
C
C       UPDATE COUNTER FOR NUMBER OF BLOCKS CALCULATED
        IF(IBAS.EQ.1.AND.JBAS.EQ.1) THEN
          N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
        ENDIF
C
C**********************************************************************C
C     CONSTRUCTION OF WDIR/WMAT CONTRIBUTIONS FOR THIS BATCH           C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
      IF(SCHWRZ) THEN
        ITOG = 1
      ELSE
        ITOG = 0
      ENDIF
C
C     CALL THE SCREENING ROUTINE
      CALL SYSTEM_CLOCK(ICL5,RATE)
      CALL SCHWARZ(BDSC,SENS)
      CALL SYSTEM_CLOCK(ICL6)
      TB2S = TB2S + DFLOAT(ICL6-ICL5)/RATE
C
C     UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
      N2EI(MCNT,ITT) = N2EI(MCNT,ITT) + NBAS(3)*NBAS(4)
      N2ES(MCNT,ITT) = N2ES(MCNT,ITT) + NBAS(3)*NBAS(4)-MAXN
C
C     CONDITIONAL TO SKIP THIS BATCH
      IF(IBCH.EQ.1) THEN
C
C       GENERATE A BATCH OF BREIT INTERACTION INTEGRALS
        CALL BIIFAST(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C       MULTIPLY BY DENSITY ELEMENTS AND ADD TO WDIR/WMAT
        CALL SYSTEM_CLOCK(ICL5,RATE)
        IF(ISYM.EQ.0) THEN
          CALL BRTMTG(RR)
        ELSE
          CALL BRTMTZ(RR)
        ENDIF
        CALL SYSTEM_CLOCK(ICL6)
        TCMC = TCMC + DFLOAT(ICL6-ICL5)/RATE
C
      ENDIF
C
C     RECORD TIME AT END OF BATCH
      CALL SYSTEM_CLOCK(ICL4)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + DFLOAT(ICL4-ICL3)/RATE
C
9001  CONTINUE
8100  CONTINUE
8002  CONTINUE
8001  CONTINUE
7100  CONTINUE
7002  CONTINUE
7001  CONTINUE
6002  CONTINUE
6001  CONTINUE
5001  CONTINUE
4002  CONTINUE
4001  CONTINUE
3002  CONTINUE
3001  CONTINUE
2100  CONTINUE
2004  CONTINUE
2003  CONTINUE
2002  CONTINUE
2001  CONTINUE
1100  CONTINUE
1004  CONTINUE
1003  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF BREIT MATRIX BY MATRIX CONJUGATION.     C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1)
      DO I=1,NDIM-NSKP
        DO J=NSKP+1,NDIM
          BDIR(J,I) = DCONJG(BDIR(I,J))
          BXCH(J,I) = DCONJG(BXCH(I,J))
          WDIR(J,I) = DCONJG(WDIR(I,J))
          WXCH(J,I) = DCONJG(WXCH(I,J))
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS (LIFTED FROM COULOMB)
      IF(NOPN.GT.0) THEN
        DO J=1,NDIM
          DO I=1,NDIM
            WDIR(I,J) = ACFF*WDIR(I,J)
            WXCH(I,J) = BCFF*WXCH(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      CALL SYSTEM_CLOCK(ICL2)
      TBMC = TBMC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE E0LLCD0(ICNT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE 000000  LL       LL       CCCCCC  DDDDDDD   000000      C
C     EE      00   000 LL       LL      CC    CC DD    DD 00   000     C
C     EE      00  0000 LL       LL      CC       DD    DD 00  0000     C
C     EEEEEE  00 00 00 LL       LL      CC       DD    DD 00 00 00     C
C     EE      0000  00 LL       LL      CC       DD    DD 0000  00     C
C     EE      000   00 LL       LL      CC    CC DD    DD 000   00     C
C     EEEEEEEE 000000  LLLLLLLL LLLLLLLL CCCCCC  DDDDDDD   000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0LLCD0 BUILDS A LIST OF THE ZERO-VALUED EQ-COEFFICIENTS FOR A FULL C
C  BLOCK (CD) OF QUANTUM NUMBERS KQN AND MQN, WITH TOTALS.             C
C -------------------------------------------------------------------- C
C  INTENT IS TO CONTRACT OVER (AB) AND THEN (CD).                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ LQN  - FULL SET OF ORBITAL LABELS.                                C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  OUTPUT:                                                             C
C  ▶ ICDR - LISTS FOR ZERO AND NON-ZERO EQ[K,M|CD] IN A COMMON BLOCK.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ICNT(4),LQN(4),NBAS(4)
      DIMENSION ICDR11(MEQ,4),ICDI11(MEQ,4),
     &          ICDR21(MEQ,4),ICDI21(MEQ,4)
      DIMENSION ICDR11KM(4,MKP,MKP,MEQ,4),ICDI11KM(4,MKP,MKP,MEQ,4),
     &          ICDR21KM(4,MKP,MKP,MEQ,4),ICDI21KM(4,MKP,MKP,MEQ,4)
C
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICDC/ICDR11KM,ICDR11,ICDI11KM,ICDI11,
     &            ICDR21KM,ICDR21,ICDI21KM,ICDI21
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA EPSCD/1.0D-10/
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXCD = NBAS(3)*NBAS(4)
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(LL)-COEFFICIENTS
      LAMCD = LQN(3)+LQN(4)
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVCD = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
C
C     INITIALISE OVERALL BLOCK SENSITIVITY LISTS
      DO ICD=1,NTUVCD
        ICDR11(ICD,1) = 0
        ICDR21(ICD,1) = 0
        ICDI11(ICD,1) = 0
        ICDI21(ICD,1) = 0
      ENDDO
C
C**********************************************************************C
C     E(CD| -) SENSITIVITY LISTS FOR ALL KAPPA, MQN ON (CD).           C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     LOOP OVER KQN(C) VALUES
      DO 101 NC=KRONECK(LQN(3),0),1
        KC = 2*LQN(3)+NC
C
C     LOOP OVER KQN(D) VALUES
      DO 102 ND=KRONECK(LQN(4),0),1
        KD = 2*LQN(4)+ND
C
C     UNIQUE INDEX FOR THIS PAIR OF KAPPAS
      NCD = 2*NC+ND+1
C
C     LOOP OVER |MQN(C)| VALUES
      DO 201 MC=1,LQN(3)+NC
C
C     LOOP OVER |MQN(D)| VALUES
      DO 202 MD=1,LQN(4)+ND
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDTT = IAD0LL(ICNT(3),ICNT(4),KC,KD,MC,MD)
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0LLFL(MCD+M,1))
          IF(SUM.GT.EPSCD) THEN
            ICDR11KM(NCD,MC,MD,ICD,1) = 1
            GOTO 211
          ENDIF
        ENDDO
        ICDR11KM(NCD,MC,MD,ICD,1) = 0
211     CONTINUE
        ICDR11(ICD,1) = ICDR11(ICD,1) + ICDR11KM(NCD,MC,MD,ICD,1)
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0LLFL(MCD+M,2))
          IF(SUM.GT.EPSCD) THEN
            ICDI11KM(NCD,MC,MD,ICD,1) = 1
            GOTO 212
          ENDIF
        ENDDO
        ICDI11KM(NCD,MC,MD,ICD,IX) = 0
212     CONTINUE
        ICDI11(ICD,1) = ICDI11(ICD,1) + ICDI11KM(NCD,MC,MD,ICD,1)
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0LLFL(MCD+M,3))
          IF(SUM.GT.EPSCD) THEN
            ICDR21KM(NCD,MC,MD,ICD,1) = 1
            GOTO 213
          ENDIF
        ENDDO
        ICDR21KM(NCD,MC,MD,ICD,1) = 0
213     CONTINUE
        ICDR21(ICD,1) = ICDR21(ICD,1) + ICDR21KM(NCD,MC,MD,ICD,1)
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0LLFL(MCD+M,4))
          IF(SUM.GT.EPSCD) THEN
            ICDI21KM(NCD,MC,MD,ICD,1) = 1
            GOTO 214
          ENDIF
        ENDDO
        ICDI21KM(NCD,MC,MD,ICD,1) = 0
214     CONTINUE
        ICDI21(ICD,1) = ICDI21(ICD,1) + ICDI21KM(NCD,MC,MD,ICD,1)
C
      ENDDO
C
202   CONTINUE
201   CONTINUE
102   CONTINUE
101   CONTINUE
C
      CALL SYSTEM_CLOCK(ICL2)
      TBEC = TBEC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE E0SSCD0(ICNT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE 000000   SSSSSS   SSSSSS   CCCCCC  DDDDDDD   000000      C
C    EE      00   000 SS    SS SS    SS CC    CC DD    DD 00   000     C
C    EE      00  0000 SS       SS       CC       DD    DD 00  0000     C
C    EEEEEE  00 00 00  SSSSSS   SSSSSS  CC       DD    DD 00 00 00     C
C    EE      0000  00       SS       SS CC       DD    DD 0000  00     C
C    EE      000   00 SS    SS SS    SS CC    CC DD    DD 000   00     C
C    EEEEEEEE 000000   SSSSSS   SSSSSS   CCCCCC  DDDDDDD   000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0SSCD0 BUILDS A LIST OF THE ZERO-VALUED EQ-COEFFICIENTS FOR A FULL C
C  BLOCK (CD) OF QUANTUM NUMBERS KQN AND MQN, WITH TOTALS.             C
C -------------------------------------------------------------------- C
C  INTENT IS TO CONTRACT OVER (AB) AND THEN (CD).                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ LQN  - FULL SET OF ORBITAL LABELS.                                C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  OUTPUT:                                                             C
C  ▶ ICDR - LISTS FOR ZERO AND NON-ZERO EQ[K,M|CD] IN A COMMON BLOCK.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ICNT(4),LQN(4),NBAS(4)
      DIMENSION ICDR11(MEQ,4),ICDI11(MEQ,4),
     &          ICDR21(MEQ,4),ICDI21(MEQ,4)
      DIMENSION ICDR11KM(4,MKP,MKP,MEQ,4),ICDI11KM(4,MKP,MKP,MEQ,4),
     &          ICDR21KM(4,MKP,MKP,MEQ,4),ICDI21KM(4,MKP,MKP,MEQ,4)
C
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICDC/ICDR11KM,ICDR11,ICDI11KM,ICDI11,
     &            ICDR21KM,ICDR21,ICDI21KM,ICDI21
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA EPSCD/1.0D-10/
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXCD = NBAS(3)*NBAS(4)
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(SS)-COEFFICIENTS
      LAMCD = LQN(3)+LQN(4)+2
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVCD = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
C
C     INITIALISE OVERALL BLOCK SENSITIVITY LISTS
      DO ICD=1,NTUVCD
        ICDR11(ICD,4) = 0
        ICDR21(ICD,4) = 0
        ICDI11(ICD,4) = 0
        ICDI21(ICD,4) = 0
      ENDDO
C
C**********************************************************************C
C     E(CD| -) SENSITIVITY LISTS FOR ALL KAPPA, MQN ON (CD).           C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     LOOP OVER KQN(C) VALUES
      DO 101 NC=KRONECK(LQN(3),0),1
        KC = 2*LQN(3)+NC
C
C     LOOP OVER KQN(D) VALUES
      DO 102 ND=KRONECK(LQN(4),0),1
        KD = 2*LQN(4)+ND
C
C     UNIQUE INDEX FOR THIS PAIR OF KAPPAS
      NCD = 2*NC+ND+1
C
C     LOOP OVER |MQN(C)| VALUES
      DO 201 MC=1,LQN(3)+NC
C
C     LOOP OVER |MQN(D)| VALUES
      DO 202 MD=1,LQN(4)+ND
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDTT = IAD0SS(ICNT(3),ICNT(4),KC,KD,MC,MD)
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0SSFL(MCD+M,1))
          IF(SUM.GT.EPSCD) THEN
            ICDR11KM(NCD,MC,MD,ICD,4) = 1
            GOTO 211
          ENDIF
        ENDDO
        ICDR11KM(NCD,MC,MD,ICD,4) = 0
211     CONTINUE
        ICDR11(ICD,4) = ICDR11(ICD,4) + ICDR11KM(NCD,MC,MD,ICD,4)
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0SSFL(MCD+M,2))
          IF(SUM.GT.EPSCD) THEN
            ICDI11KM(NCD,MC,MD,ICD,4) = 1
            GOTO 212
          ENDIF
        ENDDO
        ICDI11KM(NCD,MC,MD,ICD,IX) = 0
212     CONTINUE
        ICDI11(ICD,4) = ICDI11(ICD,4) + ICDI11KM(NCD,MC,MD,ICD,4)
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0SSFL(MCD+M,3))
          IF(SUM.GT.EPSCD) THEN
            ICDR21KM(NCD,MC,MD,ICD,4) = 1
            GOTO 213
          ENDIF
        ENDDO
        ICDR21KM(NCD,MC,MD,ICD,4) = 0
213     CONTINUE
        ICDR21(ICD,4) = ICDR21(ICD,4) + ICDR21KM(NCD,MC,MD,ICD,4)
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(E0SSFL(MCD+M,4))
          IF(SUM.GT.EPSCD) THEN
            ICDI21KM(NCD,MC,MD,ICD,4) = 1
            GOTO 214
          ENDIF
        ENDDO
        ICDI21KM(NCD,MC,MD,ICD,4) = 0
214     CONTINUE
        ICDI21(ICD,4) = ICDI21(ICD,4) + ICDI21KM(NCD,MC,MD,ICD,4)
C
      ENDDO
C
202   CONTINUE
201   CONTINUE
102   CONTINUE
101   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL2)
      TBEC = TBEC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE EILSCD0(ICNT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE IIII LL       SSSSSS   CCCCCC  DDDDDDD   000000        C
C      EE        II  LL      SS    SS CC    CC DD    DD 00   000       C
C      EE        II  LL      SS       CC       DD    DD 00  0000       C
C      EEEEEE    II  LL       SSSSSS  CC       DD    DD 00 00 00       C
C      EE        II  LL            SS CC       DD    DD 0000  00       C
C      EE        II  LL      SS    SS CC    CC DD    DD 000   00       C
C      EEEEEEEE IIII LLLLLLLL SSSSSS   CCCCCC  DDDDDDD   000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSCD0 BUILDS A LIST OF THE ZERO-VALUED EQ-COEFFICIENTS FOR A FULL C
C  BLOCK (CD) OF QUANTUM NUMBERS KQN AND MQN, WITH TOTALS.             C
C -------------------------------------------------------------------- C
C  INTENT IS TO CONTRACT OVER (AB) AND THEN (CD).                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ LQN  - FULL SET OF ORBITAL LABELS.                                C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  OUTPUT:                                                             C
C  ▶ ICDR - LISTS FOR ZERO AND NON-ZERO EQ[K,M|CD] IN A COMMON BLOCK.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ICNT(4),LQN(4),NBAS(4)
      DIMENSION ICDR11(MEQ,3,4),ICDI11(MEQ,3,4),
     &          ICDR21(MEQ,3,4),ICDI21(MEQ,3,4)
      DIMENSION ICDR11KM(4,MKP,MKP,MEQ,3,4),ICDI11KM(4,MKP,MKP,MEQ,3,4),
     &          ICDR21KM(4,MKP,MKP,MEQ,3,4),ICDI21KM(4,MKP,MKP,MEQ,3,4)
C
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICDB/ICDR11KM,ICDR11,ICDI11KM,ICDI11,
     &            ICDR21KM,ICDR21,ICDI21KM,ICDI21
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA EPSCD/1.0D-10/
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXCD = NBAS(3)*NBAS(4)
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(LS)-COEFFICIENTS
      LAMCD = LQN(3)+LQN(4)+1
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVCD = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
C
C     INITIALISE OVERALL BLOCK SENSITIVITY LISTS
      DO IX=1,3
        DO ICD=1,NTUVCD
          ICDR11(ICD,IX,2) = 0
          ICDR21(ICD,IX,2) = 0
          ICDI11(ICD,IX,2) = 0
          ICDI21(ICD,IX,2) = 0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     E(CD| -) SENSITIVITY LISTS FOR ALL KAPPA, MQN ON (CD).           C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     LOOP OVER KQN(C) VALUES
      DO 101 NC=KRONECK(LQN(3),0),1
        KC = 2*LQN(3)+NC
C
C     LOOP OVER KQN(D) VALUES
      DO 102 ND=KRONECK(LQN(4),0),1
        KD = 2*LQN(4)+ND
C
C     UNIQUE INDEX FOR THIS PAIR OF KAPPAS
      NCD = 2*NC+ND+1
C
C     LOOP OVER |MQN(C)| VALUES
      DO 201 MC=1,LQN(3)+NC
C
C     LOOP OVER |MQN(D)| VALUES
      DO 202 MD=1,LQN(4)+ND
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDTT = IADILS(ICNT(3),ICNT(4),KC,KD,MC,MD)
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        DO IX=1,3
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EILSFL(MCD+M,4*(IX-1)+1))
            IF(SUM.GT.EPSCD) THEN
              ICDR11KM(NCD,MC,MD,ICD,IX,2) = 1
              GOTO 211
            ENDIF
          ENDDO
          ICDR11KM(NCD,MC,MD,ICD,IX,2) = 0
211       CONTINUE
          ICDR11(ICD,IX,2) = ICDR11(ICD,IX,2)
     &                     + ICDR11KM(NCD,MC,MD,ICD,IX,2)
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EILSFL(MCD+M,4*(IX-1)+2))
            IF(SUM.GT.EPSCD) THEN
              ICDI11KM(NCD,MC,MD,ICD,IX,2) = 1
              GOTO 212
            ENDIF
          ENDDO
          ICDI11KM(NCD,MC,MD,ICD,IX,2) = 0
212       CONTINUE
          ICDI11(ICD,IX,2) = ICDI11(ICD,IX,2)
     &                     + ICDI11KM(NCD,MC,MD,ICD,IX,2)
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EILSFL(MCD+M,4*(IX-1)+3))
            IF(SUM.GT.EPSCD) THEN
              ICDR21KM(NCD,MC,MD,ICD,IX,2) = 1
              GOTO 213
            ENDIF
          ENDDO
          ICDR21KM(NCD,MC,MD,ICD,IX,2) = 0
213       CONTINUE
          ICDR21(ICD,IX,2) = ICDR21(ICD,IX,2)
     &                     + ICDR21KM(NCD,MC,MD,ICD,IX,2)
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EILSFL(MCD+M,4*(IX-1)+4))
            IF(SUM.GT.EPSCD) THEN
              ICDI21KM(NCD,MC,MD,ICD,IX,2) = 1
              GOTO 214
            ENDIF
          ENDDO
          ICDI21KM(NCD,MC,MD,ICD,IX,2) = 0
214       CONTINUE
          ICDI21(ICD,IX,2) = ICDI21(ICD,IX,2)
     &                     + ICDI21KM(NCD,MC,MD,ICD,IX,2)
C
        ENDDO
      ENDDO
C
202   CONTINUE
201   CONTINUE
102   CONTINUE
101   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL2)
      TBEC = TBEC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE EISLCD0(ICNT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       EEEEEEEE IIII SSSSSS  LL       CCCCCC  DDDDDDD   000000        C
C       EE        II SS    SS LL      CC    CC DD    DD 00   000       C
C       EE        II SS       LL      CC       DD    DD 00  0000       C
C       EEEEEE    II  SSSSSS  LL      CC       DD    DD 00 00 00       C
C       EE        II       SS LL      CC       DD    DD 0000  00       C
C       EE        II SS    SS LL      CC    CC DD    DD 000   00       C
C       EEEEEEEE IIII SSSSSS  LLLLLLLL CCCCCC  DDDDDDD   000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLCD0 BUILDS A LIST OF THE ZERO-VALUED EQ-COEFFICIENTS FOR A FULL C
C  BLOCK (CD) OF QUANTUM NUMBERS KQN AND MQN, WITH TOTALS.             C
C -------------------------------------------------------------------- C
C  INTENT IS TO CONTRACT OVER (AB) AND THEN (CD).                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ICNT - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).         C
C  ▶ LQN  - FULL SET OF ORBITAL LABELS.                                C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  OUTPUT:                                                             C
C  ▶ ICDR - LISTS FOR ZERO AND NON-ZERO EQ[K,M|CD] IN A COMMON BLOCK.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ICNT(4),LQN(4),NBAS(4)
      DIMENSION ICDR11(MEQ,3,4),ICDI11(MEQ,3,4),
     &          ICDR21(MEQ,3,4),ICDI21(MEQ,3,4)
      DIMENSION ICDR11KM(4,MKP,MKP,MEQ,3,4),ICDI11KM(4,MKP,MKP,MEQ,3,4),
     &          ICDR21KM(4,MKP,MKP,MEQ,3,4),ICDI21KM(4,MKP,MKP,MEQ,3,4)
C
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICDB/ICDR11KM,ICDR11,ICDI11KM,ICDI11,
     &            ICDR21KM,ICDR21,ICDI21KM,ICDI21
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA EPSCD/1.0D-10/
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXCD = NBAS(3)*NBAS(4)
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(LS)-COEFFICIENTS
      LAMCD = LQN(3)+LQN(4)+1
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVCD = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
C
C     INITIALISE OVERALL BLOCK SENSITIVITY LISTS
      DO IX=1,3
        DO ICD=1,NTUVCD
          ICDR11(ICD,IX,3) = 0
          ICDR21(ICD,IX,3) = 0
          ICDI11(ICD,IX,3) = 0
          ICDI21(ICD,IX,3) = 0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     E(CD| -) SENSITIVITY LISTS FOR ALL KAPPA, MQN ON (CD).           C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     LOOP OVER KQN(C) VALUES
      DO 101 NC=KRONECK(LQN(3),0),1
        KC = 2*LQN(3)+NC
C
C     LOOP OVER KQN(D) VALUES
      DO 102 ND=KRONECK(LQN(4),0),1
        KD = 2*LQN(4)+ND
C
C     UNIQUE INDEX FOR THIS PAIR OF KAPPAS
      NCD = 2*NC+ND+1
C
C     LOOP OVER |MQN(C)| VALUES
      DO 201 MC=1,LQN(3)+NC
C
C     LOOP OVER |MQN(D)| VALUES
      DO 202 MD=1,LQN(4)+ND
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDTT = IADISL(ICNT(3),ICNT(4),KC,KD,MC,MD)
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO ICD=1,NTUVCD
        MCD = ICDTT + (ICD-1)*MAXCD
        DO IX=1,3
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EISLFL(MCD+M,4*(IX-1)+1))
            IF(SUM.GT.EPSCD) THEN
              ICDR11KM(NCD,MC,MD,ICD,IX,3) = 1
              GOTO 211
            ENDIF
          ENDDO
          ICDR11KM(NCD,MC,MD,ICD,IX,3) = 0
211       CONTINUE
          ICDR11(ICD,IX,3) = ICDR11(ICD,IX,3)
     &                     + ICDR11KM(NCD,MC,MD,ICD,IX,3)
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EISLFL(MCD+M,4*(IX-1)+2))
            IF(SUM.GT.EPSCD) THEN
              ICDI11KM(NCD,MC,MD,ICD,IX,3) = 1
              GOTO 212
            ENDIF
          ENDDO
          ICDI11KM(NCD,MC,MD,ICD,IX,3) = 0
212       CONTINUE
          ICDI11(ICD,IX,3) = ICDI11(ICD,IX,3)
     &                     + ICDI11KM(NCD,MC,MD,ICD,IX,3)
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EISLFL(MCD+M,4*(IX-1)+3))
            IF(SUM.GT.EPSCD) THEN
              ICDR21KM(NCD,MC,MD,ICD,IX,3) = 1
              GOTO 213
            ENDIF
          ENDDO
          ICDR21KM(NCD,MC,MD,ICD,IX,3) = 0
213       CONTINUE
          ICDR21(ICD,IX,3) = ICDR21(ICD,IX,3)
     &                     + ICDR21KM(NCD,MC,MD,ICD,IX,3)
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(EISLFL(MCD+M,4*(IX-1)+4))
            IF(SUM.GT.EPSCD) THEN
              ICDI21KM(NCD,MC,MD,ICD,IX,3) = 1
              GOTO 214
            ENDIF
          ENDDO
          ICDI21KM(NCD,MC,MD,ICD,IX,3) = 0
214       CONTINUE
          ICDI21(ICD,IX,3) = ICDI21(ICD,IX,3)
     &                     + ICDI21KM(NCD,MC,MD,ICD,IX,3)
C
        ENDDO
      ENDDO
C
202   CONTINUE
201   CONTINUE
102   CONTINUE
101   CONTINUE
C
      CALL SYSTEM_CLOCK(ICL2)
      TBEC = TBEC + DFLOAT(ICL2-ICL1)/RATE
C
      RETURN
      END
C
C
      SUBROUTINE BIIFAST(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         BBBBBBB IIII IIII FFFFFFFF   AA     SSSSSS TTTTTTTT          C
C         BB    BB II   II  FF        AAAA   SS    SS   TT             C
C         BB    BB II   II  FF       AA  AA  SS         TT             C
C         BBBBBBB  II   II  FFFFFF  AA    AA  SSSSSS    TT             C
C         BB    BB II   II  FF      AAAAAAAA       SS   TT             C
C         BB    BB II   II  FF      AA    AA SS    SS   TT             C
C         BBBBBBB IIII IIII FF      AA    AA  SSSSSS    TT             C
C                                                                      C
C -------------------------------------------------------------------- C
C  BIIFAST GENERATES A BATCH OF MOLECULAR BREIT INTERACTION INTEGRALS  C
C  BY MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM    C
C  OVER EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)           C
C -------------------------------------------------------------------- C
C  THIS IS A SPECIAL VERSION OF BII, WHICH CONTRACTS OVER THE (AB)     C
C  PAIRS BEFORE (CD), AND RECYCLES THE FIRST CONTRACTION OVER (CD).    C
C  THE ROUTINE EXPLICITLY MAKES USE OF EILS COEFFICIENTS ONLY, AND     C
C  CALLS THE COEFFICIENTS DIRECTLY FROM A GLOBAL FILE. IT CANNOT BE    C
C  INVOKED IF THE SET OF EILS OR R(AB|CD) BATCHES EXCEEDS MAX SPACE.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ    - FULL SET OF CARTESIAN BASIS CENTRES.                     C
C  ▶ ICNT   - FULL SET OF BASIS CENTRE ORIGINS (NUCLEAR LABELS).       C
C  ▶ KQN    - FULL SET OF RELATIVISTIC LABELS.                         C
C  ▶ MQN    - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).        C
C  ▶ NBAS   - FULL SET OF EXPONENT LIST LENGTHS.                       C
C  ▶ EXL    - FULL LISTS OF EXPONENTS IN THE BLOCK.                    C
C  ▶ IBAS   - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).       C
C  ▶ JBAS   - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).       C
C  ▶ ITN    - COMPONENT OVERLAP COMBINATION.                           C
C  OUTPUT:                                                             C
C  ▶ RR     - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),LQN(4),MQN(4),NBAS(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),T(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MB2,MEQ,3),IABI11(MB2,MEQ,3),
     &          IABR21(MB2,MEQ,3),IABI21(MB2,MEQ,3)
      DIMENSION ICDR11(MEQ,3,4),ICDI11(MEQ,3,4),
     &          ICDR21(MEQ,3,4),ICDI21(MEQ,3,4)
      DIMENSION ICDR11KM(4,MKP,MKP,MEQ,3,4),ICDI11KM(4,MKP,MKP,MEQ,3,4),
     &          ICDR21KM(4,MKP,MKP,MEQ,3,4),ICDI21KM(4,MKP,MKP,MEQ,3,4)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GCDR11(MB2,MEQ,3),GCDI11(MB2,MEQ,3),
     &          GCDR21(MB2,MEQ,3),GCDI21(MB2,MEQ,3)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICDB/ICDR11KM,ICDR11,ICDI11KM,ICDI11,
     &            ICDR21KM,ICDR21,ICDI21KM,ICDI21
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA EPSAB,EPSRR/1.0D-16,1.0D-10/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.2) THEN
          WRITE(6, *) 'In BIIFAST: illegal component overlaps in ITN.'
          WRITE(7, *) 'In BIIFAST: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      CALL SYSTEM_CLOCK(ICL1,RATE)
      DO N=1,4
        LQN(N) = LVAL(KQN(N))
      ENDDO
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTOR FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ-COEFFICIENTS
      LAMAB = LQN(1)+LQN(2)+1
      LAMCD = LQN(3)+LQN(4)+1
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR CONTRACTED R-INTEGRAL BATCH
      IF(BGAUNT) THEN
C       GAUNT INTEGRALS ONLY
        LAMABCD = LAMAB+LAMCD
      ELSE
C       FULL BREIT INTERACTION
        LAMABCD = LAMAB+LAMCD+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
      CALL SYSTEM_CLOCK(ICL2)
      TBAX = TBAX + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) SCREENING VALUES                  C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1,RATE)
      IF(IEAB.EQ.0) GOTO 100
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH IAB
      DO IX=1,3
        DO IAB=1,NTUVAB
          MAB = IABLS + (IAB-1)*MAXAB
C
C         Re{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(EILSFL(MAB+M,4*(IX-1)+1)).GT.EPSAB) THEN
              IABR11(M,IAB,IX) = 1
            ELSE
              IABR11(M,IAB,IX) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|--)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(EILSFL(MAB+M,4*(IX-1)+2)).GT.EPSAB) THEN
              IABI11(M,IAB,IX) = 1
            ELSE
              IABI11(M,IAB,IX) = 0
            ENDIF
          ENDDO
C
C         Re{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(EILSFL(MAB+M,4*(IX-1)+3)).GT.EPSAB) THEN
              IABR21(M,IAB,IX) = 1
            ELSE
              IABR21(M,IAB,IX) = 0
            ENDIF
          ENDDO
C
C         Im{E(AB|+-)} COEFFICIENTS
          DO M=1,MAXAB
            IF(DABS(EILSFL(MAB+M,4*(IX-1)+4)).GT.EPSAB) THEN
              IABI21(M,IAB,IX) = 1
            ELSE
              IABI21(M,IAB,IX) = 0
            ENDIF
          ENDDO
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
      CALL SYSTEM_CLOCK(ICL2)
      TBEC = TBEC + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C -------------------------------------------------------------------- C
C     IN THIS ALGORITHM WE DEFER TO EILSCD0 (EXTERNALLLY)              C
C**********************************************************************C
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) INTEGRALS IF PROMPTED            C
C**********************************************************************C
C
C     START TIME
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M   = M+1
          EKL = EXL(KBAS,3)+EXL(LBAS,4)
          QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
          QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
          QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
          PQ(M,1) = QX-PX
          PQ(M,2) = QY-PY
          PQ(M,3) = QZ-PZ
          APH(M)  = EIJ*EKL/(EIJ+EKL)
          EMX = DSQRT(EIJ+EKL)*EIJ*EKL
          PRE(M) = 2.0D0*PI52/EMX
        ENDDO
      ENDDO
C
C     MULTIPLICATIVE FACTOR DEPENDING ON GAUNT/BREIT
      IF(BGAUNT) THEN
        BFAC =-1.0D0
      ELSE
        BFAC =-0.5D0
      ENDIF
C
C     SKIP IF INTEGRAL BATCH EXISTS IN FILE
      IF(IRIJ(IBAS,JBAS).EQ.0) GOTO 300
C
      CALL SYSTEM_CLOCK(ICL3)
C
C     BATCH SIZE AND EXPANSION LENGTH
      MBCH = MAXCD
C
C     GENERATE R-INTEGRALS
      CALL RMAKE(RC,PQ,APH,MBCH,LAMABCD)
C
C     SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
      DO IABCD=1,NTUVABCD
C
C       SUM OF RC(AB|CD) MAGNITUDES
        SUM = 0.0D0
        DO N=1,MBCH
          SUM = SUM + DABS(RC(N,IABCD))
          IF(SUM.GT.EPSRR) THEN
            IRC(IABCD) = 1
            GOTO 301
          ENDIF
        ENDDO
        IRC(IABCD) = 0
301     CONTINUE
C
      ENDDO
C
      CALL SYSTEM_CLOCK(ICL4)
      TBRM = TBRM + DFLOAT(ICL4-ICL3)/RATE
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
      IF(20*MFL.LT.IJ*MAXCD*NTUVABCD) THEN
C       OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
        WRITE(6, *) 'In BIIFAST: RCTT words exceed allocated limit.'
        WRITE(7, *) 'In BIIFAST: RCTT words exceed allocated limit.'
        STOP
        GOTO 300
      ELSE
C       DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
        IRIJ(IBAS,JBAS) = 0
      ENDIF
C
C     STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
      IADRTT = (IJ-1)*MAXCD*NTUVABCD
C
C     COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
      DO IABCD=1,NTUVABCD
        IAD = IADRTT + MAXCD*(IABCD-1)
        DO M=1,MAXCD
          RCTTFL(IAD+M) = BFAC*PRE(M)*RC(M,IABCD)
        ENDDO
      ENDDO
C
C     STARTING ADDRESS FOR SCREENING FLAGS
      IADSCR = (IJ-1)*NTUVABCD
C
C     COPY SCREENING MARKERS TO A SAVED LIST
      DO IABCD=1,NTUVABCD
        IRCTTFL(IADSCR+IABCD) = IRC(IABCD)
      ENDDO
C
      CALL SYSTEM_CLOCK(ICL4)
      TBRW = TBRW + DFLOAT(ICL4-ICL3)/RATE
C
300   CONTINUE
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL SYSTEM_CLOCK(ICL2)
      TRBR = TRBR + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(CD| -) = E(AB| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR A AND B.              C
C**********************************************************************C
C
      IF(IGAB.EQ.0) GOTO 400
C
C     LOOP OVER CARTESIAN INDEX IX FOR CENTRE CD
      DO IX=1,3
C
C       TIME AT START OF FIRST CONTRACTION FOR THIS IX INDEX
        CALL SYSTEM_CLOCK(ICL1,RATE)
C
C       LOOP OVER ALL ADDRESSES FOR E(CD| -) FINITE EXPANSION
        DO ICD=1,NTUVCD
C
C         RESET CONTRACTION STORAGE ARRAYS G(CD| -)
          DO N=1,MAXN
            GCDR11(N,ICD,IX) = 0.0D0
            GCDI11(N,ICD,IX) = 0.0D0
            GCDR21(N,ICD,IX) = 0.0D0
            GCDI21(N,ICD,IX) = 0.0D0
          ENDDO
C
C         SKIP ENTIRE PROCESS IF E(CD| -) FAILS SCREENING CONDITION
          ICDALL = ICDR11(ICD,IX,2) + ICDI11(ICD,IX,2)
     &           + ICDR21(ICD,IX,2) + ICDI21(ICD,IX,2)
          IF(ICDALL.EQ.0) GOTO 401
C
C >>>>>   GAUNT INTERACTION
C
C         LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(AB| -)
          DO IAB=1,NTUVAB
C
C           RELATIVE EQ(AB) LIST STARTING ADDRESS
            MAB = IABLS + (IAB-1)*MAXAB
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),
     &                                    IC(IAB)+IC(ICD))
C
C           ARE ANY EQ-COEFFICIENTS AT THIS ADDRESS NON-ZERO?
            IABALL = IABR11(IJ,IAB,IX) + IABI11(IJ,IAB,IX)
     &             + IABR21(IJ,IAB,IX) + IABI21(IJ,IAB,IX)
C
C           SKIP THIS STEP IF THE E(AB) FAILS SCREENING CONDITION
            IF(IABALL.EQ.0) GOTO 402
C
C           RELATIVE RC(AB|CD) LIST STARTING ADDRESS
            MABCD = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IRABCD-1)
C
C           SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
            IF(IRCTTFL((IJ-1)*NTUVABCD+IRABCD).EQ.0) GOTO 450
C
C           CONTRIBUTIONS TO Re{G(CD|--)} FROM EACH Re{E(AB|--)}
            IF(ICDR11(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 451
            IF(IABR11(IJ,IAB,IX).EQ.0) GOTO 451
            DO N=1,MAXN
              GCDR11(N,ICD,IX) = GCDR11(N,ICD,IX)
     &                + EILSFL(MAB+IJ,4*(IX-1)+1)*RCTTFL(MABCD+IMAP(N))
            ENDDO
451         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(CD|--)} FROM EACH Im{E(AB|--)}
            IF(ICDI11(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 452
            IF(IABI11(IJ,IAB,IX).EQ.0) GOTO 452
            DO N=1,MAXN
              GCDI11(N,ICD,IX) = GCDI11(N,ICD,IX)
     &                + EILSFL(MAB+IJ,4*(IX-1)+2)*RCTTFL(MABCD+IMAP(N))
            ENDDO
452         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(CD|+-)} FROM EACH Re{E(AB|+-)}
            IF(ICDR21(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 453
            IF(IABR21(IJ,IAB,IX).EQ.0) GOTO 453
            DO N=1,MAXN
              GCDR21(N,ICD,IX) = GCDR21(N,ICD,IX)
     &                + EILSFL(MAB+IJ,4*(IX-1)+3)*RCTTFL(MABCD+IMAP(N))
            ENDDO
453         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(CD|+-)} FROM EACH Im{E(AB|+-)}
            IF(ICDI21(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 454
            IF(IABI21(IJ,IAB,IX).EQ.0) GOTO 454
            DO N=1,MAXN
              GCDI21(N,ICD,IX) = GCDI21(N,ICD,IX)
     &                + EILSFL(MAB+IJ,4*(IX-1)+4)*RCTTFL(MABCD+IMAP(N))
            ENDDO
454         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) AND E(AB) SCREENING
450         CONTINUE
C
C           SKIP POINT FOR ALL EQ(AB) FAILING SCREENING CONDITION
402         CONTINUE
C
C >>>>>     GAUGE TERM (REQUIRES ADDITIONAL CARTESIAN SUM Q')
            IF(BGAUNT) GOTO 480
C
C           LOOP OVER CARTESIAN INDEX JX FOR CENTRE AB
            DO JX=1,3
C
C             SKIP THIS STEP IF THE E(AB) FAILS SCREENING CONDITION
              IF(IABR11(IJ,IAB,JX)+IABI11(IJ,IAB,JX)
     &          +IABR21(IJ,IAB,JX)+IABI21(IJ,IAB,JX).EQ.0) THEN
                GOTO 403
              ENDIF
C
C             NEW ADDRESS DEPENDING ON JX CARTESIAN INDEX
              IF(JX.EQ.1) THEN
                RTP = DFLOAT(IA(IAB)+IA(ICD))
              ELSEIF(JX.EQ.2) THEN
                RTP = DFLOAT(IB(IAB)+IB(ICD))
              ELSEIF(JX.EQ.3) THEN
                RTP = DFLOAT(IC(IAB)+IC(ICD))
              ENDIF
C
C             FIRST CONTRIBUTION ADDRESS
              I1 = IA(IAB)+IA(ICD)+KRONECK(IX,1)+KRONECK(JX,1)
              J1 = IB(IAB)+IB(ICD)+KRONECK(IX,2)+KRONECK(JX,2)
              K1 = IC(IAB)+IC(ICD)+KRONECK(IX,3)+KRONECK(JX,3)
C
C             CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
              IADR1 = IABC(I1,J1,K1)
C
C             SECOND CONTRIBUTION ADDRESS
              I2 = IA(IAB)+IA(ICD)+KRONECK(IX,1)
              J2 = IB(IAB)+IB(ICD)+KRONECK(IX,2)
              K2 = IC(IAB)+IC(ICD)+KRONECK(IX,3)
C
C             CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
              IADR2 = IABC(I2,J2,K2)
C
C             THIRD CONTRIBUTION ADDRESS
              I3 = IA(IAB)+IA(ICD)+KRONECK(IX,1)-KRONECK(JX,1)
              J3 = IB(IAB)+IB(ICD)+KRONECK(IX,2)-KRONECK(JX,2)
              K3 = IC(IAB)+IC(ICD)+KRONECK(IX,3)-KRONECK(JX,3)
C
C             CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
              IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                IADR3 = IABC(I3,J3,K3)
              ELSE
                IADR3 = 0
              ENDIF
C
C             SKIP THIS STEP IF THE RC(AB|CD) FAILS SCREENING CONDITION
              IF(IADR3.NE.0) THEN
                IF(IRC(IADR1)+IRC(IADR2)+IRC(IADR3).EQ.0) GOTO 403
              ELSE
                IF(IRC(IADR1)+IRC(IADR2).EQ.0) GOTO 403
              ENDIF
C
C             PRE-FACTORS FOR THE UPCOMING CONTRACTION
              IA1 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR1-1)
              IA2 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR2-1)
              IA3 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR3-1)
              DO N=1,MAXN
                T1 = RCTTFL(IA1+IMAP(N))*0.5D0/APH(IMAP(N))
                T2 = RCTTFL(IA2+IMAP(N))*PQ(IMAP(N),JX)
                IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                  T3 = RCTTFL(IA3+IMAP(N))*RTP
                ELSE
                  T3 = 0.0D0
                ENDIF
                T(N) = T1-T2+T3
              ENDDO
C
C             CONTRIBUTIONS TO Re{G(CD|--)} FROM EACH Re{E(AB|--)}
              IF(ICDR11(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 415
              IF(IABR11(IJ,IAB,JX).EQ.0) GOTO 415
              DO N=1,MAXN
                GCDR11(N,ICD,IX) = GCDR11(N,ICD,IX)
     &                                 - EILSFL(MAB+IJ,4*(JX-1)+1)*T(N)
              ENDDO
415           CONTINUE
C
C             CONTRIBUTIONS TO Im{G(CD|--)} FROM EACH Im{E(AB|--)}
              IF(ICDI11(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 416
              IF(IABI11(IJ,IAB,JX).EQ.0) GOTO 416
              DO N=1,MAXN
                GCDI11(N,ICD,IX) = GCDI11(N,ICD,IX)
     &                                 - EILSFL(MAB+IJ,4*(JX-1)+2)*T(N)
              ENDDO
416           CONTINUE
C
C             CONTRIBUTIONS TO Re{G(CD|--)} FROM EACH Re{E(AB|--)}
              IF(ICDR21(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 417
              IF(IABR21(IJ,IAB,JX).EQ.0) GOTO 417
              DO N=1,MAXN
                GCDR21(N,ICD,IX) = GCDR21(N,ICD,IX)
     &                                 - EILSFL(MAB+IJ,4*(JX-1)+3)*T(N)
              ENDDO
417           CONTINUE
C
C             CONTRIBUTIONS TO Im{G(CD|--)} FROM EACH Im{E(AB|--)}
              IF(ICDI21(ICD,IX,2).EQ.0.AND.ISYM.GE.1) GOTO 418
              IF(IABI21(IJ,IAB,JX).EQ.0) GOTO 418
              DO N=1,MAXN
                GCDI21(N,ICD,IX) = GCDI21(N,ICD,IX)
     &                                 - EILSFL(MAB+IJ,4*(JX-1)+4)*T(N)
              ENDDO
418           CONTINUE
C
C             SKIP POINT FOR E(AB) SCREENING
403           CONTINUE
C
C             END LOOP OVER CARTESIAN INDEX JX FOR CENTRE AB
              ENDDO
C
C             SKIP POINT FOR GAUNT INTERACTION ONLY
480           CONTINUE
C
C           END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
            ENDDO
C
C         SKIP POINT FOR E(CD|  ) SCREENING
401       CONTINUE
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       TIME AT END OF FIRST CONTRACTION FOR THIS IX INDEX
        CALL SYSTEM_CLOCK(ICL2)
        TBC1 = TBC1 + DFLOAT(ICL2-ICL1)/RATE
C
C     END LOOP OVER CARTESIAN INDEX IX FOR CENTRE CD
      ENDDO
C
C     FIRST CONTRACTION DOES NOT NEED TO BE RECALCULATED
      IGAB = 0
400   CONTINUE
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(CD| -)*G(CD| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD =-ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     SHORTHAND FOR MQN VALUES IN (CD) BLOCK
      MC = (MQN(3)+1)/2
      MD = (MQN(4)+1)/2
C
C     LOOP OVER CARTESIAN INDEX IX FOR CENTRE CD
      DO IX=1,3
C
        CALL SYSTEM_CLOCK(ICL1,RATE)
C
C       SPECIAL CASE: LINEAR MOLECULE OR ATOM
        IF(ISYM.NE.1.AND.ISYM.NE.2) GOTO 501
C
C       1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C                (16) = (++|++)   (13) = (++|--)
C
C       RESET CONTRACTION STORAGE LISTS
        DO N=1,MAXN
          QR1(N) = 0.0D0
          QR2(N) = 0.0D0
        ENDDO
C
C       RAW CONTRACTION (--|--) = E(CD|--)*(Re{G(CD|--)}+i*Im{G(CD|--)})
        DO ICD=1,NTUVCD
          MCD = ICDLS + (ICD-1)*MAXCD
          Z   = DFLOAT((-1)**(ILAM(ICD)))
          IF(ICDR11KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+1)*GCDR11(N,ICD,IX)
            ENDDO
          ENDIF
          IF(ICDI11KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR2(N) = QR2(N)
     &              - Z*EILSFL(MCD+IMAP(N),4*(IX-1)+2)*GCDI11(N,ICD,IX)
            ENDDO
          ENDIF
        ENDDO
C
C       ADD THIS IX TERM TO RAW CONTRACTION
        DO N=1,MAXN
          RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),0.0D0)
          RR(N,13) = RR(N,13) + PAB*DCMPLX(QR1(N)-QR2(N),0.0D0)
        ENDDO
C
C       4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C                ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C       RESET CONTRACTION STORAGE LISTS
        DO N=1,MAXN
          QR1(N) = 0.0D0
          QR2(N) = 0.0D0
        ENDDO
C
C       RAW CONTRACTION (+-|+-) = E(CD|+-)*(Re{G(CD|+-)}+i*Im{G(CD|+-)})
        DO ICD=1,NTUVCD
          MCD = ICDLS + (ICD-1)*MAXCD
          Z   = DFLOAT((-1)**(ILAM(ICD)))
          IF(ICDR21KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+3)*GCDR21(N,ICD,IX)
            ENDDO
          ENDIF
          IF(ICDI21KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR2(N) = QR2(N)
     &              - Z*EILSFL(MCD+IMAP(N),4*(IX-1)+4)*GCDI21(N,ICD,IX)
            ENDDO
          ENDIF
        ENDDO
C
C       ADD THIS IX TERM TO RAW CONTRACTION
        DO N=1,MAXN
          RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),0.0D0)
          RR(N,7 ) = RR(N,7 ) - PAB*DCMPLX(QR1(N)-QR2(N),0.0D0)
        ENDDO
C
        GOTO 502
C
C       GENERAL CASE
501     CONTINUE
C
C       1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C                (16) = (++|++)   (13) = (++|--)
C
C       RESET CONTRACTION STORAGE LISTS
        DO N=1,MAXN
          QR1(N) = 0.0D0
          QI1(N) = 0.0D0
          QR2(N) = 0.0D0
          QI2(N) = 0.0D0
        ENDDO
C
C       RAW CONTRACTION (--|--) = E(CD|--)*(Re{G(CD|--)}+i*Im{G(CD|--)})
        DO ICD=1,NTUVCD
          MCD = ICDLS + (ICD-1)*MAXCD
          Z   = DFLOAT((-1)**(ILAM(ICD)))
          IF(ICDR11KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+1)*GCDR11(N,ICD,IX)
              QI2(N) = QI2(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+1)*GCDI11(N,ICD,IX)
            ENDDO
          ENDIF
          IF(ICDI11KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+2)*GCDR11(N,ICD,IX)
              QR2(N) = QR2(N)
     &              - Z*EILSFL(MCD+IMAP(N),4*(IX-1)+2)*GCDI11(N,ICD,IX)
            ENDDO
          ENDIF
        ENDDO
C
C       ADD THIS IX TERM TO RAW CONTRACTION
        DO N=1,MAXN
          RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
          RR(N,13) = RR(N,13) + PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        ENDDO
C
C       2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C                (14) = (++|-+)   (15) = (++|+-)
C
C       RESET CONTRACTION STORAGE LISTS
        DO N=1,MAXN
          QR1(N) = 0.0D0
          QI1(N) = 0.0D0
          QR2(N) = 0.0D0
          QI2(N) = 0.0D0
        ENDDO
C
C       RAW CONTRACTION (--|+-) = E(CD|--)*(Re{G(CD|+-)}+i*Im{G(CD|+-)})
        DO ICD=1,NTUVCD
          MCD = ICDLS + (ICD-1)*MAXCD
          Z   = DFLOAT((-1)**(ILAM(ICD)))
          IF(ICDR21KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+3)*GCDR11(N,ICD,IX)
              QI2(N) = QI2(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+3)*GCDI11(N,ICD,IX)
            ENDDO
          ENDIF
          IF(ICDI21KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+4)*GCDR11(N,ICD,IX)
              QR2(N) = QR2(N)
     &              - Z*EILSFL(MCD+IMAP(N),4*(IX-1)+4)*GCDI11(N,ICD,IX)
            ENDDO
          ENDIF
        ENDDO
C
C       ADD THIS IX TERM TO RAW CONTRACTION
        DO N=1,MAXN
          RR(N,3 ) = RR(N,3 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
          RR(N,15) = RR(N,15) + PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        ENDDO
C
C       3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C                ( 8) = (-+|++)   ( 5) = (-+|--)
C
C       RESET CONTRACTION STORAGE LISTS
        DO N=1,MAXN
          QR1(N) = 0.0D0
          QI1(N) = 0.0D0
          QR2(N) = 0.0D0
          QI2(N) = 0.0D0
        ENDDO
C
C       RAW CONTRACTION (+-|--) = E(CD|+-)*(Re{G(CD|--)}+i*Im{G(CD|--)})
        DO ICD=1,NTUVCD
          MCD = ICDLS + (ICD-1)*MAXCD
          Z   = DFLOAT((-1)**(ILAM(ICD)))
          IF(ICDR11KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+1)*GCDR21(N,ICD,IX)
              QI2(N) = QI2(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+1)*GCDI21(N,ICD,IX)
            ENDDO
          ENDIF
          IF(ICDI11KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+2)*GCDR21(N,ICD,IX)
              QR2(N) = QR2(N)
     &              - Z*EILSFL(MCD+IMAP(N),4*(IX-1)+2)*GCDI21(N,ICD,IX)
            ENDDO
          ENDIF
        ENDDO
C
C       ADD THIS IX TERM TO RAW CONTRACTION
        DO N=1,MAXN
          RR(N,9 ) = RR(N,9 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
          RR(N,5 ) = RR(N,5 ) - PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        ENDDO
C
C       4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C                ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C       RESET CONTRACTION STORAGE LISTS
        DO N=1,MAXN
          QR1(N) = 0.0D0
          QI1(N) = 0.0D0
          QR2(N) = 0.0D0
          QI2(N) = 0.0D0
        ENDDO
C
C       RAW CONTRACTION (+-|+-) = E(CD|+-)*(Re{G(CD|+-)}+i*Im{G(CD|+-)})
        DO ICD=1,NTUVCD
          MCD = ICDLS + (ICD-1)*MAXCD
          Z   = DFLOAT((-1)**(ILAM(ICD)))
          IF(ICDR21KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QR1(N) = QR1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+3)*GCDR21(N,ICD,IX)
              QI2(N) = QI2(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+3)*GCDI21(N,ICD,IX)
            ENDDO
          ENDIF
          IF(ICDI21KM(NCD,MC,MD,ICD,IX,2).NE.0) THEN
            DO N=1,MAXN
              QI1(N) = QI1(N)
     &              + Z*EILSFL(MCD+IMAP(N),4*(IX-1)+4)*GCDR21(N,ICD,IX)
              QR2(N) = QR2(N)
     &              - Z*EILSFL(MCD+IMAP(N),4*(IX-1)+4)*GCDI21(N,ICD,IX)
            ENDDO
          ENDIF
        ENDDO
C
C       ADD THIS IX TERM TO RAW CONTRACTION
        DO N=1,MAXN
          RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
          RR(N,7 ) = RR(N,7 ) - PAB*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        ENDDO
C
502     CONTINUE
C
C       TIME AT END OF SECOND CONTRACTION FOR THIS IX INDEX
        CALL SYSTEM_CLOCK(ICL2)
        TBC2 = TBC2 + DFLOAT(ICL2-ICL1)/RATE
C
C     END LOOP OVER CARTESIAN INDEX IX FOR CENTRE CD
      ENDDO
C
C     HALF OF THE RR ARRAY CAN BE GENERATED WITH PHASE RELATIONS
      DO N=1,MAXN
        RR(N,16) = PABCD*DCONJG(RR(N,1 ))
        RR(N,4 ) = PABCD*DCONJG(RR(N,13))
        RR(N,14) =-PABCD*DCONJG(RR(N,3 ))
        RR(N,2 ) =-PABCD*DCONJG(RR(N,15))
        RR(N,8 ) =-PABCD*DCONJG(RR(N,9 ))
        RR(N,12) =-PABCD*DCONJG(RR(N,5 ))
        RR(N,6 ) = PABCD*DCONJG(RR(N,11))
        RR(N,10) = PABCD*DCONJG(RR(N,7 ))
      ENDDO 
C
C**********************************************************************C
C     BREIT INTEGRAL BATCH NOW FULLY CONSTRUCTED                       C
C**********************************************************************C
C
      RETURN
      END
C
C
      SUBROUTINE BRTMTZ(RR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       BBBBBBB  RRRRRRR TTTTTTTT MM       MM TTTTTTTT ZZZZZZZZ        C
C       BB    BB RR    RR   TT    MMM     MMM    TT         ZZ         C
C       BB    BB RR    RR   TT    MMMM   MMMM    TT        ZZ          C
C       BBBBBBB  RR    RR   TT    MM MM MM MM    TT       ZZ           C
C       BB    BB RRRRRRR    TT    MM  MMM  MM    TT      ZZ            C
C       BB    BB RR    RR   TT    MM   M   MM    TT     ZZ             C
C       BBBBBBB  RR    RR   TT    MM       MM    TT    ZZZZZZZZ        C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMTZ MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF BREIT MATRICES.       C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO BII):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  THIS IS A SPECIAL CASE OF BREIT MATRIX ASSEMBLER BRTMTZ, WHICH      C
C  MAY ONLY BE USED WHEN THE FOCK MATRIX IS REAL-VALUED -- EXAMPLES    C
C  ARE ATOMS, DIATOMICS, LINEAR OR PLANAR MOLECULES.                   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ RR(MB2,16) - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C  ▶ NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION NBAS(4),MQN(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.EQ.0) THEN
        WRITE(6,*) 'In BRTMTZ: you probably should be using BRTMTG.'
        WRITE(7,*) 'In BRTMTZ: you probably should be using BRTMTG.'
      ENDIF
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     BDIR = 0 FOR CLOSED-SHELL SYSTEMS -- CAN ALLOW THIS FOR TESTING
      IF(NOPN.EQ.0) GOTO 150
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(3).NE.MQN(4))) GOTO 151
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 101
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 101
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENT(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(M, 4))*DREAL(DENT(NC2+KBAS,ND2+LBAS))
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &       +           DREAL(RR(M,13))*DREAL(DENT(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENT(NC2+KBAS,ND2+LBAS))
C
101       CONTINUE
        ENDDO
      ENDDO
151   CONTINUE
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 180
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(4).NE.MQN(3))) GOTO 152
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 102
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 102
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(M, 4))*DREAL(DENT(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(M, 1))*DREAL(DENT(ND2+LBAS,NC2+KBAS))
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &       +      PCD1*DREAL(RR(M,16))*DREAL(DENT(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(M,13))*DREAL(DENT(ND2+LBAS,NC2+KBAS))
C
102       CONTINUE
        ENDDO
      ENDDO
152   CONTINUE
C
      IF(IQL.EQ.IQR) GOTO 180
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(1).NE.MQN(2))) GOTO 153
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 103
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 103
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENT(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(M,13))*DREAL(DENT(NA2+IBAS,NB2+JBAS))
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &       +           DREAL(RR(M, 4))*DREAL(DENT(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENT(NA2+IBAS,NB2+JBAS))
C
103       CONTINUE
        ENDDO
      ENDDO
153   CONTINUE
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(2).NE.MQN(1))) GOTO 154
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 104
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 104
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(M,13))*DREAL(DENT(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(M, 1))*DREAL(DENT(NB2+JBAS,NA2+IBAS))
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &       + PAB1*     DREAL(RR(M,16))*DREAL(DENT(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(M, 4))*DREAL(DENT(NB2+JBAS,NA2+IBAS))
C
104       CONTINUE
        ENDDO
      ENDDO
154   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
180   CONTINUE
C
C     SKIP POINT FOR BDIR IN CLOSED-SHELL SYSTEMS
150   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(4).OR.MQN(3).NE.MQN(2))) GOTO 155
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 105
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 105
C
          BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENT(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(M, 7))*DREAL(DENT(NC2+KBAS,NB2+JBAS))
C
          BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &       +           DREAL(RR(M,10))*DREAL(DENT(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENT(NC2+KBAS,NB2+JBAS))
C
105       CONTINUE
        ENDDO
      ENDDO
155   CONTINUE
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 190
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(3).OR.MQN(4).NE.MQN(2))) GOTO 156
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 106
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 106
C
          BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &       +      PCD1*DREAL(RR(M, 4))*DREAL(DENT(ND1+LBAS,NB1+JBAS))
     &       +      PCD2*DREAL(RR(M, 7))*DREAL(DENT(ND2+LBAS,NB2+JBAS))
C
          BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &       +      PCD2*DREAL(RR(M,10))*DREAL(DENT(ND1+LBAS,NB1+JBAS))
     &       +      PCD1*DREAL(RR(M,13))*DREAL(DENT(ND2+LBAS,NB2+JBAS))
C
106       CONTINUE
        ENDDO
      ENDDO
156   CONTINUE
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(2).NE.MQN(4).OR.MQN(3).NE.MQN(1))) GOTO 157
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 107
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 107
C
          BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(M,13))*DREAL(DENT(NC1+KBAS,NA1+IBAS))
     &       + PAB2*     DREAL(RR(M, 7))*DREAL(DENT(NC2+KBAS,NA2+IBAS))
C
          BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &       + PAB2*     DREAL(RR(M,10))*DREAL(DENT(NC1+KBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(M, 4))*DREAL(DENT(NC2+KBAS,NA2+IBAS))
C
107       CONTINUE
        ENDDO
      ENDDO
157   CONTINUE
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 190
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(2).OR.MQN(1).NE.MQN(4))) GOTO 159
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 109
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 109
C
          BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENT(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(M,10))*DREAL(DENT(NA2+IBAS,ND2+LBAS))
C
          BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &       +           DREAL(RR(M, 7))*DREAL(DENT(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENT(NA2+IBAS,ND2+LBAS))
C
109       CONTINUE
        ENDDO
      ENDDO
159   CONTINUE
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(1).OR.MQN(2).NE.MQN(4))) GOTO 160
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 110
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 110
C
          BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &       + PAB1*     DREAL(RR(M,13))*DREAL(DENT(NB1+JBAS,ND1+LBAS))
     &       + PAB2*     DREAL(RR(M,10))*DREAL(DENT(NB2+JBAS,ND2+LBAS))
C
          BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &       + PAB2*     DREAL(RR(M, 7))*DREAL(DENT(NB1+JBAS,ND1+LBAS))
     &       + PAB1*     DREAL(RR(M, 4))*DREAL(DENT(NB2+JBAS,ND2+LBAS))
C
110       CONTINUE
        ENDDO
      ENDDO
160   CONTINUE
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(4).NE.MQN(2).OR.MQN(1).NE.MQN(3))) GOTO 161
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 111
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 111
C
          BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(M, 4))*DREAL(DENT(NA1+IBAS,NC1+KBAS))
     &       +      PCD2*DREAL(RR(M,10))*DREAL(DENT(NA2+IBAS,NC2+KBAS))
C
          BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &       +      PCD2*DREAL(RR(M, 7))*DREAL(DENT(NA1+IBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(M,13))*DREAL(DENT(NA2+IBAS,NC2+KBAS))
C
111       CONTINUE
        ENDDO
      ENDDO
161   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
190   CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5000
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(3).NE.MQN(4))) GOTO 351
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 301
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 301
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENO(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(M, 4))*DREAL(DENO(NC2+KBAS,ND2+LBAS))
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &       +           DREAL(RR(M,13))*DREAL(DENO(NC1+KBAS,ND1+LBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENO(NC2+KBAS,ND2+LBAS))
C
301       CONTINUE
        ENDDO
      ENDDO
351   CONTINUE
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 380
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(2).OR.MQN(4).NE.MQN(3))) GOTO 352
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 302
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 302
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(M, 4))*DREAL(DENO(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(M, 1))*DREAL(DENO(ND2+LBAS,NC2+KBAS))
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &       +      PCD1*DREAL(RR(M,16))*DREAL(DENO(ND1+LBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(M,13))*DREAL(DENO(ND2+LBAS,NC2+KBAS))
C
302       CONTINUE
        ENDDO
      ENDDO
352   CONTINUE
C
      IF(IQL.EQ.IQR) GOTO 380
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(1).NE.MQN(2))) GOTO 353
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 303
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 303
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENO(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(M,13))*DREAL(DENO(NA2+IBAS,NB2+JBAS))
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &       +           DREAL(RR(M, 4))*DREAL(DENO(NA1+IBAS,NB1+JBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENO(NA2+IBAS,NB2+JBAS))
C
303       CONTINUE
        ENDDO
      ENDDO
353   CONTINUE
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(4).OR.MQN(2).NE.MQN(1))) GOTO 354
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 304
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 304
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(M,13))*DREAL(DENO(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(M, 1))*DREAL(DENO(NB2+JBAS,NA2+IBAS))
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &       + PAB1*     DREAL(RR(M,16))*DREAL(DENO(NB1+JBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(M, 4))*DREAL(DENO(NB2+JBAS,NA2+IBAS))
C
304       CONTINUE
        ENDDO
      ENDDO
354   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
380   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(4).OR.MQN(3).NE.MQN(2))) GOTO 355
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 305
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 305
C
          WXCH(NA1+IBAS,ND1+LBAS) = WXCH(NA1+IBAS,ND1+LBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENO(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(M, 7))*DREAL(DENO(NC2+KBAS,NB2+JBAS))
C
          WXCH(NA2+IBAS,ND2+LBAS) = WXCH(NA2+IBAS,ND2+LBAS)
     &       +           DREAL(RR(M,10))*DREAL(DENO(NC1+KBAS,NB1+JBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENO(NC2+KBAS,NB2+JBAS))
C
305       CONTINUE
        ENDDO
      ENDDO
355   CONTINUE
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 390
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(1).NE.MQN(3).OR.MQN(4).NE.MQN(2))) GOTO 356
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 306
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 306
C
          WXCH(NA1+IBAS,NC1+KBAS) = WXCH(NA1+IBAS,NC1+KBAS)
     &       +      PCD1*DREAL(RR(M, 4))*DREAL(DENO(ND1+LBAS,NB1+JBAS))
     &       +      PCD2*DREAL(RR(M, 7))*DREAL(DENO(ND2+LBAS,NB2+JBAS))
C
          WXCH(NA2+IBAS,NC2+KBAS) = WXCH(NA2+IBAS,NC2+KBAS)
     &       +      PCD2*DREAL(RR(M,10))*DREAL(DENO(ND1+LBAS,NB1+JBAS))
     &       +      PCD1*DREAL(RR(M,13))*DREAL(DENO(ND2+LBAS,NB2+JBAS))
C
306       CONTINUE
        ENDDO
      ENDDO
356   CONTINUE
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(2).NE.MQN(4).OR.MQN(3).NE.MQN(1))) GOTO 357
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 307
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 307
C
          WXCH(NB1+JBAS,ND1+LBAS) = WXCH(NB1+JBAS,ND1+LBAS)
     &       + PAB1*     DREAL(RR(M,13))*DREAL(DENO(NC1+KBAS,NA1+IBAS))
     &       + PAB2*     DREAL(RR(M, 7))*DREAL(DENO(NC2+KBAS,NA2+IBAS))
C
          WXCH(NB2+JBAS,ND2+LBAS) = WXCH(NB2+JBAS,ND2+LBAS)
     &       + PAB2*     DREAL(RR(M,10))*DREAL(DENO(NC1+KBAS,NA1+IBAS))
     &       + PAB1*     DREAL(RR(M, 4))*DREAL(DENO(NC2+KBAS,NA2+IBAS))
C
307       CONTINUE
        ENDDO
      ENDDO
357   CONTINUE
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 390
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(2).OR.MQN(1).NE.MQN(4))) GOTO 359
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 309
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 309
C
          WXCH(NC1+KBAS,NB1+JBAS) = WXCH(NC1+KBAS,NB1+JBAS)
     &       +           DREAL(RR(M, 1))*DREAL(DENO(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(M,10))*DREAL(DENO(NA2+IBAS,ND2+LBAS))
C
          WXCH(NC2+KBAS,NB2+JBAS) = WXCH(NC2+KBAS,NB2+JBAS)
     &       +           DREAL(RR(M, 7))*DREAL(DENO(NA1+IBAS,ND1+LBAS))
     &       +           DREAL(RR(M,16))*DREAL(DENO(NA2+IBAS,ND2+LBAS))
C
309       CONTINUE
        ENDDO
      ENDDO
359   CONTINUE
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(3).NE.MQN(1).OR.MQN(2).NE.MQN(4))) GOTO 360
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 310
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 310
C
          WXCH(NC1+KBAS,NA1+IBAS) = WXCH(NC1+KBAS,NA1+IBAS)
     &       + PAB1*     DREAL(RR(M,13))*DREAL(DENO(NB1+JBAS,ND1+LBAS))
     &       + PAB2*     DREAL(RR(M,10))*DREAL(DENO(NB2+JBAS,ND2+LBAS))
C
          WXCH(NC2+KBAS,NA2+IBAS) = WXCH(NC2+KBAS,NA2+IBAS)
     &       + PAB2*     DREAL(RR(M, 7))*DREAL(DENO(NB1+JBAS,ND1+LBAS))
     &       + PAB1*     DREAL(RR(M, 4))*DREAL(DENO(NB2+JBAS,ND2+LBAS))
C
310       CONTINUE
        ENDDO
      ENDDO
360   CONTINUE
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      IF(MQNSLC.AND.(MQN(4).NE.MQN(2).OR.MQN(1).NE.MQN(3))) GOTO 361
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 311
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 311
C
          WXCH(ND1+LBAS,NB1+JBAS) = WXCH(ND1+LBAS,NB1+JBAS)
     &       +      PCD1*DREAL(RR(M, 4))*DREAL(DENO(NA1+IBAS,NC1+KBAS))
     &       +      PCD2*DREAL(RR(M,10))*DREAL(DENO(NA2+IBAS,NC2+KBAS))
C
          WXCH(ND2+LBAS,NB2+JBAS) = WXCH(ND2+LBAS,NB2+JBAS)
     &       +      PCD2*DREAL(RR(M, 7))*DREAL(DENO(NA1+IBAS,NC1+KBAS))
     &       +      PCD1*DREAL(RR(M,13))*DREAL(DENO(NA2+IBAS,NC2+KBAS))
C
311       CONTINUE
        ENDDO
      ENDDO
361   CONTINUE
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
390   CONTINUE
C
C     SKIP POINT FOR CLOSED-SHELL MOLECULES
5000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BRTMTG(RR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        BBBBBBB  RRRRRRR TTTTTTTT MM       MM TTTTTTTT GGGGGG         C
C        BB    BB RR    RR   TT    MMM     MMM    TT   GG    GG        C
C        BB    BB RR    RR   TT    MMMM   MMMM    TT   GG              C
C        BBBBBBB  RR    RR   TT    MM MM MM MM    TT   GG              C
C        BB    BB RRRRRRR    TT    MM  MMM  MM    TT   GG   GGG        C
C        BB    BB RR    RR   TT    MM   M   MM    TT   GG    GG        C
C        BBBBBBB  RR    RR   TT    MM       MM    TT    GGGGGG         C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMTG MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF BREIT MATRICES.       C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO BII):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ RR(MB2,16) - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C  ▶ NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION NBAS(4),MQN(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.NE.0) THEN
        WRITE(6,*) 'In BRTMTG: you probably should be using BRTMTZ.'
        WRITE(7,*) 'In BRTMTG: you probably should be using BRTMTZ.'
      ENDIF
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     BDIR = 0 FOR CLOSED-SHELL SYSTEMS -- CAN ALLOW THIS FOR TESTING
      IF(NOPN.EQ.0) GOTO 150
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 101
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 101
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 2)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 3)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENT(NC2+KBAS,ND2+LBAS)
C
          BDIR(NA1+IBAS,NB2+JBAS) = BDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 7)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 8)*DENT(NC2+KBAS,ND2+LBAS)
C
          BDIR(NA2+IBAS,NB1+JBAS) = BDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M, 9)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENT(NC2+KBAS,ND2+LBAS)
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(M,13)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,14)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENT(NC2+KBAS,ND2+LBAS)
C
101       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 160
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 102
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 102
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 2)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 3)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENT(ND2+LBAS,NC2+KBAS)
C
          BDIR(NA1+IBAS,NB2+JBAS) = BDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 7)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 5)*DENT(ND2+LBAS,NC2+KBAS)
C
          BDIR(NA2+IBAS,NB1+JBAS) = BDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,12)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENT(ND2+LBAS,NC2+KBAS)
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M,16)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,14)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENT(ND2+LBAS,NC2+KBAS)
C
102       CONTINUE
        ENDDO
      ENDDO
C
      IF(IQL.EQ.IQR) GOTO 160
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 103
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 103
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 5)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 9)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENT(NA2+IBAS,NB2+JBAS)
C
          BDIR(NC1+KBAS,ND2+LBAS) = BDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,10)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENT(NA2+IBAS,NB2+JBAS)      
C
          BDIR(NC2+KBAS,ND1+LBAS) = BDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 3)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,11)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,15)*DENT(NA2+IBAS,NB2+JBAS)
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(M, 4)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 8)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,12)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENT(NA2+IBAS,NB2+JBAS)
C
103       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 104
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 104
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 5)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 9)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENT(NB2+JBAS,NA2+IBAS)
C
          BDIR(NC1+KBAS,ND2+LBAS) = BDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,10)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 2)*DENT(NB2+JBAS,NA2+IBAS)
C
          BDIR(NC2+KBAS,ND1+LBAS) = BDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,15)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENT(NB2+JBAS,NA2+IBAS)
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,16)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 8)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENT(NB2+JBAS,NA2+IBAS)
C
104       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
160   CONTINUE
C
C     SKIP POINT FOR BDIR IN CLOSED-SHELL SYSTEMS
150   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 105
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 105
C
          BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 5)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 3)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENT(NC2+KBAS,NB2+JBAS)
C
          BXCH(NA1+IBAS,ND2+LBAS) = BXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 4)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 8)*DENT(NC2+KBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,ND1+LBAS) = BXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M, 9)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M,11)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,15)*DENT(NC2+KBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(M,10)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M,12)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENT(NC2+KBAS,NB2+JBAS)
C
105       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 170
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 106
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 106
C
          BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 4)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 8)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 3)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 7)*DENT(ND2+LBAS,NB2+JBAS)
C
          BXCH(NA1+IBAS,NC2+KBAS) = BXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 2)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 6)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 1)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 5)*DENT(ND2+LBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,NC1+KBAS) = BXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,12)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,16)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M,11)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M,15)*DENT(ND2+LBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,10)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M,14)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 9)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,13)*DENT(ND2+LBAS,NB2+JBAS)
C
106       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 107
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 107
C
          BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 5)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,15)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENT(NC2+KBAS,NA2+IBAS)
C
          BXCH(NB1+JBAS,ND2+LBAS) = BXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,16)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 8)*DENT(NC2+KBAS,NA2+IBAS)
C
          BXCH(NB2+JBAS,ND1+LBAS) = BXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 9)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENT(NC2+KBAS,NA2+IBAS)
C
          BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,10)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 2)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENT(NC2+KBAS,NA2+IBAS)
C
107       CONTINUE
        ENDDO
      ENDDO
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 170
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 109
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 109
C
          BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 2)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 9)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENT(NA2+IBAS,ND2+LBAS)
C
          BXCH(NC1+KBAS,NB2+JBAS) = BXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,13)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,14)*DENT(NA2+IBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NB1+JBAS) = BXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 3)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENT(NA2+IBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(M, 7)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 8)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENT(NA2+IBAS,ND2+LBAS)
C
109       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 110
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 110
C
          BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,13)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,14)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M, 9)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,10)*DENT(NB2+JBAS,ND2+LBAS)
C
          BXCH(NC1+KBAS,NA2+IBAS) = BXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 5)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 6)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 1)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 2)*DENT(NB2+JBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NA1+IBAS) = BXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,15)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,16)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,11)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,12)*DENT(NB2+JBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 7)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 8)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 3)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 4)*DENT(NB2+JBAS,ND2+LBAS)
C
110       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 111
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 111
C
          BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 2)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,12)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENT(NA2+IBAS,NC2+KBAS)
C
          BXCH(ND1+LBAS,NB2+JBAS) = BXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,16)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,14)*DENT(NA2+IBAS,NC2+KBAS)
C
          BXCH(ND2+LBAS,NB1+JBAS) = BXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 3)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENT(NA2+IBAS,NC2+KBAS)
C
          BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 7)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 5)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENT(NA2+IBAS,NC2+KBAS)
C
111       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
170   CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5000
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MC, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 301
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 301
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 3)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
          WDIR(NA1+IBAS,NB2+JBAS) = WDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
          WDIR(NA2+IBAS,NB1+JBAS) = WDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENO(NC2+KBAS,ND2+LBAS)
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(M,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP REMAINING DIRECT BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 360
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 302
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 302
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 3)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
          WDIR(NA1+IBAS,NB2+JBAS) = WDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
          WDIR(NA2+IBAS,NB1+JBAS) = WDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302       CONTINUE
        ENDDO
      ENDDO
C
      IF(IQL.EQ.IQR) GOTO 360
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 303
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 303
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 9)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENO(NA2+IBAS,NB2+JBAS)
C
          WDIR(NC1+KBAS,ND2+LBAS) = WDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENO(NA2+IBAS,NB2+JBAS)      
C
          WDIR(NC2+KBAS,ND1+LBAS) = WDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,15)*DENO(NA2+IBAS,NB2+JBAS)
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(M, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,12)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 304
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 304
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 9)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
          WDIR(NC1+KBAS,ND2+LBAS) = WDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
          WDIR(NC2+KBAS,ND1+LBAS) = WDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
360   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 305
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 305
C
          WXCH(NA1+IBAS,ND1+LBAS) = WXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 3)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
          WXCH(NA1+IBAS,ND2+LBAS) = WXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,ND1+LBAS) = WXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,15)*DENO(NC2+KBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,ND2+LBAS) = WXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(M,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M,12)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP REMAINING EXCHANGE BATCHES IF INTEGRAL SYMMETRY IS DISABLED
      IF(.NOT.INTSYM) GOTO 370
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 306
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 306
C
          WXCH(NA1+IBAS,NC1+KBAS) = WXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 3)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
          WXCH(NA1+IBAS,NC2+KBAS) = WXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,NC1+KBAS) = WXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M,15)*DENO(ND2+LBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,NC2+KBAS) = WXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 9)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 307
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 307
C
          WXCH(NB1+JBAS,ND1+LBAS) = WXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,15)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
          WXCH(NB1+JBAS,ND2+LBAS) = WXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
          WXCH(NB2+JBAS,ND1+LBAS) = WXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
          WXCH(NB2+JBAS,ND2+LBAS) = WXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307       CONTINUE
        ENDDO
      ENDDO
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 370
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 309
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 309
C
          WXCH(NC1+KBAS,NB1+JBAS) = WXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 9)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENO(NA2+IBAS,ND2+LBAS)
C
          WXCH(NC1+KBAS,NB2+JBAS) = WXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,14)*DENO(NA2+IBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NB1+JBAS) = WXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENO(NA2+IBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NB2+JBAS) = WXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(M, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 310
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 310
C
          WXCH(NC1+KBAS,NA1+IBAS) = WXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M, 9)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,10)*DENO(NB2+JBAS,ND2+LBAS)
C
          WXCH(NC1+KBAS,NA2+IBAS) = WXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NA1+IBAS) = WXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,12)*DENO(NB2+JBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NA2+IBAS) = WXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 3)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 311
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 311
C
          WXCH(ND1+LBAS,NB1+JBAS) = WXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,12)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENO(NA2+IBAS,NC2+KBAS)
C
          WXCH(ND1+LBAS,NB2+JBAS) = WXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,14)*DENO(NA2+IBAS,NC2+KBAS)
C
          WXCH(ND2+LBAS,NB1+JBAS) = WXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
          WXCH(ND2+LBAS,NB2+JBAS) = WXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR INTEGRAL SYMMETRY
370   CONTINUE
C
C     SKIP POINT FOR CLOSED-SHELL MOLECULES
5000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BREIT2
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 222222            C
C           BB    BB RR    RR EE        II     TT   22    22           C
C           BB    BB RR    RR EE        II     TT         22           C
C           BBBBBBB  RR    RR EEEEEE    II     TT        22            C
C           BB    BB RRRRRRR  EE        II     TT      22              C
C           BB    BB RR    RR EE        II     TT    22                C
C           BBBBBBB  RR    RR EEEEEEEE IIII    TT   22222222           C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT2 GENERATES ALL TWO-CENTRE BREIT INTERACTION MATRIX ELEMENTS   C
C  WHICH ARISE FROM A PAIR OF ONE-CENTRE CURRENT DENSITIES, UNDER THE  C
C  ASSUMPTION OF IDEAL ATOM-CENTRED MAGNETIC DIPOLE CURRENTS.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*80 TITLE
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RAB(MCT,MCT)
C
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 SMAT(MDM,MDM,3)
      COMPLEX*16 UMAT(MDM,MDM,3)
      COMPLEX*16 ELS11(MB2,MEQ),ELS21(MB2,MEQ)
      COMPLEX*16 ESL11(MB2,MEQ),ESL21(MB2,MEQ)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
C     SKIP MULTI-CENTRE CONTRIBUTIONS IN STAGES 1 AND 2
      IF(ILEV.LT.3) RETURN
C
C     DISTANCE BETWEEN FUNCTION ORIGINS
      DO IA=1,NCNT
        XA = BXYZ(1,IA)
        YA = BXYZ(2,IA)
        ZA = BXYZ(3,IA)
        DO IB=1,NCNT
          XB = BXYZ(1,IB)
          YB = BXYZ(2,IB)
          ZB = BXYZ(3,IB)
          RAB(IA,IB) = DSQRT((XB-XA)**2 + (YB-YA)**2 + (ZB-ZA)**2)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     BASIS PAIR CURRENT DENSITY (MATRIX S)                            C
C**********************************************************************C
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          DO IQ=1,3
            SMAT(I,J,IQ) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C     CALCULATE COMPONENT OFFSETS
      NA1L = LRGE(ICNTA,KA,2*MA-1)
      NA2L = LRGE(ICNTA,KA,2*MA  )
      NB1L = LRGE(ICNTB,KB,2*MB-1)
      NB2L = LRGE(ICNTB,KB,2*MB  )
C
      NA1S = NA1L+NSKP
      NA2S = NA2L+NSKP
      NB1S = NB1L+NSKP
      NB2S = NB2L+NSKP
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     LOOP OVER CARTESIAN INDICES
      DO 4001 IQ=1,3
C
C       GENERATE ELSQ COEFFICIENTS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLSMK(ELS11,ELS21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELS = TELS + DFLOAT(ICL2-ICL1)/RATE
C
C       GENERATE ESLQ COEFFICIENTS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSLMK(ESL11,ESL21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESL = TESL + DFLOAT(ICL2-ICL1)/RATE
C
C       OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            ERT = DSQRT(PI/EIJ)**3
C
C           MATRIX ELEMENTS
            SMAT(NA1L+IBAS,NB1S+JBAS,IQ) = ERT*ELS11(M,1)
            SMAT(NA2L+IBAS,NB1S+JBAS,IQ) = ERT*ELS21(M,1)
            SMAT(NA1L+IBAS,NB2S+JBAS,IQ) =-PHS*ERT*DCONJG(ELS21(M,1))
            SMAT(NA2L+IBAS,NB2S+JBAS,IQ) = PHS*ERT*DCONJG(ELS11(M,1))
C
            SMAT(NA1S+IBAS,NB1L+JBAS,IQ) = ERT*ESL11(M,1)
            SMAT(NA2S+IBAS,NB1L+JBAS,IQ) = ERT*ESL21(M,1)
            SMAT(NA1S+IBAS,NB2L+JBAS,IQ) =-PHS*ERT*DCONJG(ESL21(M,1))
            SMAT(NA2S+IBAS,NB2L+JBAS,IQ) = PHS*ERT*DCONJG(ESL11(M,1))
C
          ENDDO
        ENDDO
C
C     END LOOP OVER CARTESIAN INDICES
4001  CONTINUE
C
C     END LOOP OVER CENTRES A AND B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     POINT-LIKE DIPOLE CURRENTS FROM BASIS FUNCTIONS ON EACH CENTRE   C
C**********************************************************************C
C
C      DO IQ=1,3
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            IF(LABICN(I).EQ.LABICN(J)) THEN
C              CRNT(LABICN(I),IQ) = CRNT(LABICN(I),IQ)
C     &         + BASJ(I     ,J+NSKP,IQ)*DENT(I     ,J+NSKP)
C     &         + BASJ(I+NSKP,J     ,IQ)*DENT(I+NSKP,J     )
C            ENDIF
C          ENDDO
C        ENDDO
C      ENDDO
C
C      DO IZ=1,NCNT
C        WRITE(*,*) IZ,(CRNT(IZ,IQ),IQ=1,3)
C      ENDDO
C      STOP
CC
C      RETURN
C
C**********************************************************************C
C     PERFORM ONE-INDEX CONTRACTION (K) OVER SMAT AND DENS             C
C**********************************************************************C
C
      DO IQ=1,3
        DO JL=1,NDIM-NSKP
          JS = JL+NSKP
          IB = LABICN(JL)
C         J INDEX (NU) SHOULD BE ON CENTRE 1
          IF(IB.NE.1) GOTO 20
          DO LL=1,NDIM-NSKP
            LS = LL+NSKP
            ID = LABICN(LL)
C           L INDEX (TAU) SHOULD BE ON CENTRE 2
            IF(ID.NE.2) GOTO 30
            DO KL=1,NDIM-NSKP
              KS = KL+NSKP
              IC = LABICN(KL)
C             K INDEX (SIGMA) SHOULD BE ON CENTRE 2
              IF(IC.NE.2) GOTO 40
              UMAT(JL,LL,IQ) = UMAT(JL,LL,IQ)+SMAT(KS,JL,IQ)*DENT(KS,LL)
              UMAT(JL,LS,IQ) = UMAT(JL,LS,IQ)+SMAT(KS,JL,IQ)*DENT(KS,LS)
              UMAT(JS,LL,IQ) = UMAT(JS,LL,IQ)+SMAT(KL,JS,IQ)*DENT(KL,LL)
              UMAT(JS,LS,IQ) = UMAT(JS,LS,IQ)+SMAT(KL,JS,IQ)*DENT(KL,LS)
40            CONTINUE
            ENDDO
30          CONTINUE
          ENDDO
20        CONTINUE
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PERFORM ONE-INDEX CONTRACTION (L) OVER SMAT AND UMAT             C
C**********************************************************************C
C
      DO IL=1,NDIM-NSKP
        IS = IL+NSKP
        IA = LABICN(IL)
C       I INDEX (MU) SHOULD BE ON CENTRE 1
        IF(IA.NE.1) GOTO 50
        DO JL=1,NDIM-NSKP
          JS  = JL+NSKP
          IB = LABICN(JL)
C         J INDEX (NU) SHOULD BE ON CENTRE 1
          IF(IB.NE.1) GOTO 60
          DO LL=1,NDIM-NSKP
            LS = LL+NSKP
            ID = LABICN(LL)
C           L INDEX (TAU) SHOULD BE ON CENTRE 2
            IF(ID.NE.2) GOTO 70
            DO IQ=1,3
              BXCH(IL,JL) = BXCH(IL,JL)
     &                   + 0.5D0*SMAT(IL,LS,IQ)*UMAT(JL,LS,IQ)/RAB(1,2)
              BXCH(IL,JS) = BXCH(IL,JS)
     &                   + 0.5D0*SMAT(IL,LS,IQ)*UMAT(JS,LS,IQ)/RAB(1,2)
              BXCH(IS,JL) = BXCH(IS,JL)
     &                   + 0.5D0*SMAT(IS,LL,IQ)*UMAT(JL,LL,IQ)/RAB(1,2)
              BXCH(IS,JS) = BXCH(IS,JS)
     &                   + 0.5D0*SMAT(IS,LL,IQ)*UMAT(JS,LL,IQ)/RAB(1,2)
            ENDDO
70          CONTINUE
          ENDDO
60        CONTINUE
        ENDDO
50      CONTINUE
      ENDDO
C
      TITLE = 'BREIT_APPROX'
      CALL ZGNUMAP(BXCH,TITLE,NDIM)
      
      BRL = 0.0D0
      BIM = 0.0D0
      IVAL = 0
      JVAL = 0
      BMX = 0.0D0
      DO I=1,NDIM
        DO J=1,NDIM
          BRL = BRL + DABS(DREAL(BXCH(I,J)))
          BIM = BIM + DABS(DIMAG(BXCH(I,J)))
          IF(ABS(BXCH(I,J)).GT.BMX) THEN
            IVAL = I
            JVAL = J
            BMX = ABS(BXCH(I,J))
          ENDIF
        ENDDO
      ENDDO
      WRITE(*,*) 'RESIDUALS ARE: ',BRL,BIM
      WRITE(*,*) 'MAX: ',IVAL,JVAL,BMX
C
      RETURN
      END
C
C
      SUBROUTINE COUPLE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         CCCCCC   OOOOOO  UU    UU PPPPPPP  LL       EEEEEEEE         C
C        CC    CC OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EEEEEE           C
C        CC       OO    OO UU    UU PPPPPPP  LL       EE               C
C        CC    CC OO    OO UU    UU PP       LL       EE               C
C         CCCCCC   OOOOOO   UUUUUU  PP       LLLLLLLL EEEEEEEE         C
C                                                                      C
C -------------------------------------------------------------------- C
C  COUPLE SPECIFIES THE OPEN-SHELL COUPLING MATRIX R:                  C
C               R = {S.D(O).Q + Q.D(O).S}  (RSCF 89)                   C
C  AND ADDS TO THE EXISTING DIRECT- AND EXCHANGE COULOMB/BREIT ARRAYS. C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 X1,X2
      COMPLEX*16 T1(MDM,MDM),T2(MDM,MDM)
      COMPLEX*16 R1(MDM,MDM),R2(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
C
C**********************************************************************C
C     OPEN-SHELL COULOMB CONTRIBUTIONS                                 C
C**********************************************************************C
C
C     CONTRACT OVER 2ND AND 3RD MATRICES: T1(K,J) = D(K,L)*Q(L,J)
C                                         T2(K,J) = D(K,L)*S(L,J)
      DO K=1,NDIM
        DO J=1,NDIM
C
C         RESET SUM COUNTERS
          T1(K,J) = DCMPLX(0.0D0,0.0D0)
          T2(K,J) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM CONTRACTION
          DO L=1,NDIM
            T1(K,J) = T1(K,J) + DENT(K,L)*QDIR(L,J)-DENT(K,L)*QXCH(L,J)
            T2(K,J) = T2(K,J) + DENT(K,L)*OVLP(L,J)
          ENDDO
C
        ENDDO
      ENDDO
C
C     CONTRACT OVER 1ST AND 2ND MATRICES: R1(I,J) = S(I,K)*T1(K,J)
C                                         R2(I,J) = Q(I,K)*T2(K,J)
      DO I=1,NDIM
        DO J=1,NDIM
C
C         RESET SUM COUNTERS
          R1(I,J) = DCMPLX(0.0D0,0.0D0)
          R2(I,J) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM CONTRACTION
          DO K=1,NDIM
            R1(I,J) = R1(I,J) + OVLP(I,K)*T1(K,J)
            R2(I,J) = R2(I,J) + QDIR(I,K)*T2(K,J)-QXCH(I,K)*T2(K,J)
          ENDDO
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     OPEN-SHELL BREIT CONTRIBUTIONS                                   C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 100
C
C     CONTRACT OVER 2ND AND 3RD MATRICES: T1(K,J) = D(K,L)*W(L,J)
C                                         T2(K,J) = D(K,L)*S(L,J)
      DO K=1,NDIM
        DO J=1,NDIM
C
C         RESET SUM COUNTERS
          T1(K,J) = DCMPLX(0.0D0,0.0D0)
          T2(K,J) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM CONTRACTION
          DO L=1,NDIM
            T1(K,J) = T1(K,J) + DENT(K,L)*WDIR(L,J)-DENT(K,L)*WXCH(L,J)
            T2(K,J) = T2(K,J) + DENT(K,L)*OVLP(L,J)
          ENDDO
C
        ENDDO
      ENDDO
C
C     CONTRACT OVER 1ST AND 2ND MATRICES: R1(I,J) = S(I,K)*T1(K,J)
C                                         R2(I,J) = W(I,K)*T2(K,J)
      DO I=1,NDIM
        DO J=1,NDIM
C
C         PERFORM CONTRACTION
          DO K=1,NDIM
            R1(I,J) = R1(I,J) + OVLP(I,K)*T1(K,J)
            R2(I,J) = R2(I,J) + WDIR(I,K)*T2(K,J)-WXCH(I,K)*T2(K,J)
          ENDDO
C
        ENDDO
      ENDDO
C
100   CONTINUE
C
C**********************************************************************C
C     TOTAL COUPLING MATRIX                                            C
C**********************************************************************C
C
C     COUPLING MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
          CPLE(I,J) = R1(I,J) + R2(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE SPARSITY(A,N,EPS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  PPPPPPP     AA    RRRRRRR   SSSSSS IIII TTTTTTTT YY    YY  C
C  SS    SS PP    PP   AAAA   RR    RR SS    SS II     TT    YY    YY  C
C  SS       PP    PP  AA  AA  RR    RR SS       II     TT    YY    YY  C
C   SSSSSS  PP    PP AA    AA RR    RR  SSSSSS  II     TT     YY  YY   C
C        SS PPPPPPP  AAAAAAAA RRRRRRR        SS II     TT      YYYY    C
C  SS    SS PP       AA    AA RR    RR SS    SS II     TT       YY     C
C   SSSSSS  PP       AA    AA RR    RR  SSSSSS IIII    TT       YY     C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPARSITY APPLIES MATRIX SPARSITY CONDITIONS ON A COMPLEX-VALUED     C
C  ARRAY A OF DIMENSION N.                                             C
C**********************************************************************C
C
      COMPLEX*16 A(N,N)
C
C     LOOP OVER ALL MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
C
          X = DREAL(A(I,J))
          Y = DIMAG(A(I,J))
C
C         ELIMINATE ANY VANISHINGLY SMALL MATRIX ELEMENTS
          IF(DABS(X).LT.EPS) THEN
            X = 0.0D0
          ENDIF
          IF(DABS(Y).LT.EPS) THEN
            Y = 0.0D0
          ENDIF
C
C         ALSO ELMINATE ALL DIAGONAL IMAGINARY MATRIX ELEMENTS
          IF(I.EQ.J) THEN
            Y = 0.0D0
          ENDIF
C
C         TRANSFER ELEMENT BACK TO A MATRIX
          A(I,J) = DCMPLX(X,Y)
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION KRONECK(IX,JX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    KK    KK RRRRRRR   OOOOOO  NN    NN EEEEEEEE CCCCCC  KK    KK     C
C    KK   KK  RR    RR OO    OO NNN   NN EE      CC    CC KK   KK      C
C    KK  KK   RR    RR OO    OO NNNN  NN EE      CC       KK  KK       C
C    KKKKK    RR    RR OO    OO NN NN NN EEEEEE  CC       KKKKK        C
C    KK  KK   RRRRRRR  OO    OO NN  NNNN EE      CC       KK  KK       C
C    KK   KK  RR    RR OO    OO NN   NNN EE      CC    CC KK   KK      C
C    KK    KK RR    RR  OOOOOO  NN    NN EEEEEEEE CCCCCC  KK    KK     C
C                                                                      C
C -------------------------------------------------------------------- C
C  KRONECK IS A KRONECKER DELTA FUNCTION FOR INDICES IX AND JX.        C
C**********************************************************************C
C
      IF(IX.EQ.JX) THEN
        KRONECK = 1
      ELSE
        KRONECK = 0
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE NCART(IVECT,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             NN    NN  CCCCCC     AA    RRRRRRR TTTTTTTT              C
C             NNN   NN CC    CC   AAAA   RR    RR   TT                 C
C             NNNN  NN CC        AA  AA  RR    RR   TT                 C
C             NN NN NN CC       AA    AA RR    RR   TT                 C
C             NN  NNNN CC       AAAAAAAA RRRRRRR    TT                 C
C             NN   NNN CC    CC AA    AA RR    RR   TT                 C
C             NN    NN  CCCCCC  AA    AA RR    RR   TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCART RETURNS THE CARTESIAN INDEX FROM THE INDEX VALUE IND.         C
C**********************************************************************C
C
      DIMENSION IVECT(3)
C
      IF(IND.EQ.1) THEN
        IVECT(1) = 1
        IVECT(2) = 0
        IVECT(3) = 0
      ELSEIF(IND.EQ.2) THEN
        IVECT(1) = 0
        IVECT(2) = 1
        IVECT(3) = 0
      ELSEIF(IND.EQ.3) THEN
        IVECT(1) = 0
        IVECT(2) = 0
        IVECT(3) = 1
      ELSE
        WRITE(6, *) 'In NCART: supplied index not valid',IND
        WRITE(7, *) 'In NCART: supplied index not valid',IND
        RETURN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        NN    NN  CCCCCC  NN    NN TTTTTTTT RRRRRRR   SSSSSS          C
C        NNN   NN CC    CC NNN   NN    TT    RR    RR SS    SS         C
C        NNNN  NN CC       NNNN  NN    TT    RR    RR SS               C
C        NN NN NN CC       NN NN NN    TT    RR    RR  SSSSSS          C
C        NN  NNNN CC       NN  NNNN    TT    RRRRRRR        SS         C
C        NN   NNN CC    CC NN   NNN    TT    RR    RR SS    SS         C
C        NN    NN  CCCCCC  NN    NN    TT    RR    RR  SSSSSS          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCNTRS RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT VALUES.  C
C**********************************************************************C
C
C     STORE ICNTA IN FIRST PLACE
      NCNTRS = 1
C
C     CHECK ICNTB AGAINST STORED VALUES
      IF(ICNTB.NE.ICNTA) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTC AGAINST STORED VALUES
      IF(ICNTC.NE.ICNTA.AND.ICNTC.NE.ICNTB) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTD AGAINST STORED VALUES
      IF(ICNTD.NE.ICNTA.AND.ICNTD.NE.ICNTB.AND.ICNTD.NE.ICNTC) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ZPROJ(XYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            ZZZZZZZZ PPPPPPP  RRRRRRR   OOOOOO     JJJJJJ             C
C                 ZZ  PP    PP RR    RR OO    OO       JJ              C
C                ZZ   PP    PP RR    RR OO    OO       JJ              C
C               ZZ    PP    PP RR    RR OO    OO       JJ              C
C              ZZ     PPPPPPP  RRRRRRR  OO    OO       JJ              C
C             ZZ      PP       RR    RR OO    OO JJ    JJ              C
C            ZZZZZZZZ PP       RR    RR  OOOOOO   JJJJJJ               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZPROJ RETURNS THE SUM OF ABSOLUTE DIFFERENCES BETWEEN X AND Y       C
C  LOCATIONS OF FOUR SUPPLIED COORDINATES.                             C
C**********************************************************************C
C
       DIMENSION XYZ(3,4)
C
       ZPROJ = 0.0D0
C
       DO IX=1,2
         DO M=1,3
           DO N=M+1,4
             ZPROJ = ZPROJ + DABS(XYZ(IX,M)-XYZ(IX,N))
           ENDDO
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
      FUNCTION LVAL(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                  LL      VV    VV    AA    LL                        C
C                  LL      VV    VV   AAAA   LL                        C
C                  LL      VV    VV  AA  AA  LL                        C
C                  LL      VV    VV AA    AA LL                        C
C                  LL       VV  VV  AAAAAAAA LL                        C
C                  LL        VVVV   AA    AA LL                        C
C                  LLLLLLLL   VV    AA    AA LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  LVAL RETURNS THE LQN FROM A KQN VALUE.                              C
C**********************************************************************C
C
      IF(KQN.LT.0) THEN
        LVAL =-KQN-1
      ELSE
        LVAL = KQN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION LLAB(LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 LL       LL          AA    BBBBBBB                   C
C                 LL       LL         AAAA   BB    BB                  C
C                 LL       LL        AA  AA  BB    BB                  C
C                 LL       LL       AA    AA BBBBBBB                   C
C                 LL       LL       AAAAAAAA BB    BB                  C
C                 LL       LL       AA    AA BB    BB                  C
C                 LLLLLLLL LLLLLLLL AA    AA BBBBBBB                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  LLAB RETURNS THE CONVENTIONAL ATOMIC ORBITAL TYPE LABEL FOR THE     C
C  NON-RELATIVISTIC QUANTUM NUMBER LQN OF LENGTH 1.                    C
C**********************************************************************C
C
      CHARACTER*1 LLAB
C
      IF(LQN.EQ.0) THEN
        LLAB = 's'
      ELSEIF(LQN.EQ.1) THEN
        LLAB = 'p'
      ELSEIF(LQN.EQ.2) THEN
        LLAB = 'd'
      ELSEIF(LQN.EQ.3) THEN
        LLAB = 'f'
      ELSEIF(LQN.EQ.4) THEN
        LLAB = 'g'
      ELSEIF(LQN.EQ.5) THEN
        LLAB = 'h'
      ELSEIF(LQN.EQ.6) THEN
        LLAB = 'i'
      ELSEIF(LQN.EQ.7) THEN
        LLAB = 'j'
      ELSEIF(LQN.EQ.8) THEN
        LLAB = 'k'
      ELSEIF(LQN.EQ.9) THEN
        LLAB = 'l'
      ELSEIF(LQN.EQ.10) THEN
        LLAB = 'm'
      ELSEIF(LQN.EQ.11) THEN
        LLAB = 'n'
      ELSEIF(LQN.EQ.12) THEN
        LLAB = 'o'
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION KLAB(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 KK    KK LL          AA    BBBBBBB                   C
C                 KK   KK  LL         AAAA   BB    BB                  C
C                 KK  KK   LL        AA  AA  BB    BB                  C
C                 KKKKK    LL       AA    AA BBBBBBB                   C
C                 KK  KK   LL       AAAAAAAA BB    BB                  C
C                 KK   KK  LL       AA    AA BB    BB                  C
C                 KK    KK LLLLLLLL AA    AA BBBBBBB                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLAB RETURNS THE CONVENTIONAL SYMMETRY TYPE LABEL FOR DIRAC         C
C  ORBITAL TYPE KQN AS A STRING OF LENGTH 2.                           C
C**********************************************************************C
C
      CHARACTER*1 LLAB,CHS
      CHARACTER*2 KLAB
C
      LQN = LVAL(KQN)
C
      IF(KQN.EQ.-1) THEN
        CHS = ' '
      ELSEIF(KQN.LT.0) THEN
        CHS = '-'
      ELSE
        CHS = '+'
      ENDIF
C
C     STITCH TOGETHER THE LQN TITLE AND THE PARITY LABEL
      WRITE(KLAB,'(A,A)') LLAB(LQN),CHS
C
      RETURN
      END
C
C
      FUNCTION MLAB(MQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                MM       MM LL          AA    BBBBBBB                 C
C                MMM     MMM LL         AAAA   BB    BB                C
C                MMMM   MMMM LL        AA  AA  BB    BB                C
C                MM MM MM MM LL       AA    AA BBBBBBB                 C
C                MM  MMM  MM LL       AAAAAAAA BB    BB                C
C                MM   M   MM LL       AA    AA BB    BB                C
C                MM       MM LLLLLLLL AA    AA BBBBBBB                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  MLAB RETURNS THE CONVENTIONAL SYMMETRY TYPE LABEL FOR DIRAC         C
C  MAGNETIC NUMBER MQN AS A STRING OF LENGTH 5.                        C
C**********************************************************************C
C
       CHARACTER*1 CHS
       CHARACTER*5 MLAB
C
       IF(MOD(MQN,2).EQ.0) THEN
         CHS = '+'
       ELSE
         CHS = '-'
       ENDIF
C
C      ODD INTEGER FOR NUMERATOR
       MAG = MQN-MOD(MQN+1,2)
C
C      STITCH TOGETHER THE MQN TITLE
       IF(MAG.LT.10) THEN
         WRITE(MLAB,'(A,I1,A)') CHS,MAG,'/2 '
       ELSE
         WRITE(MLAB,'(A,I2,A)') CHS,MAG,'/2'
       ENDIF
C
       RETURN
       END
C
C
C**********************************************************************C
C ==================================================================== C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] COULOMB1: ATOM-CENTRED CONTRIBUTIONS TO COULOMB MATRIX.        C
C   [B] RKCLM1: MAKES A BATCH OF RADIAL COULOMB INTEGRALS RK(ABCD).    C
C   [C] ANGCLM1: CONSTRUCTS ANGULAR COEFFICIENTS FOR COULOMB1.         C
C   [D] DK: ANGULAR AND CG-COEFFICIENT PRE-FACTORS FOR ANGCLM1.        C
C   [E] SYM3J: EVALUATES A WIGNER 3J-SYMBOL.                           C
C   [F] BREIT1: ONE-CENTRE CONTRIBUTION TO MOLECULAR BREIT MATRIX.     C
C   [G] RKBRT1: MAKES A BATCH OF RADIAL COULOMB INTEGRALS RK(ABCD).    C
C   [H] ANGBRT1: ANGULAR TERMS FOR ONE-CENTRE BREIT INTEGRALS.         C
C   [I] BRCOEF1: INTERMEDIATE COUPLING TERMS FOR ABOVE BREIT INTEGRALS.C
C   [J] IJSET1: BASIS SET INTERMEDIATES FOR IJ-PAIRS IN RKCLM1/RKBRT1. C
C   [K] KLSET1: BASIS SET INTERMEDIATES FOR KL-PAIRS IN RKCLM1/RKBRT1. C
C   [L] TESTANG: TESTS A FULL BATCH OF COMMON ANGULAR COEFFICIENTS.    C
C**********************************************************************C
C
C
      SUBROUTINE COULOMB1(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB   11  C
C CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB 111  C
C CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB  11  C
C CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB   11  C
C CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB  11  C
C CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB  11  C
C  CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB  1111 C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB1 CONSTRUCTS ALL ATOM-CENTRED CONTRIBUTIONS TO THE MOLECULAR C
C  MEAN-FIELD COULOMB MATRIX WITH RACAH ALGEBRA AND BETA INTEGRALS.    C
C  THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD   C
C  ATOMIC COULOMB MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION RJLLLL(MB2,MNU),RJLLSS(MB2,MNU),
     &          RJSSLL(MB2,MNU),RJSSSS(MB2,MNU)
      DIMENSION XLLLL(MB2),XSSLL(MB2),XLLSS(MB2),XSSSS(MB2)
C
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MT1A/PAB,PCD,MMA,MMB,MMC,MMD,
     &            NAL,NBL,NCL,NDL,NAS,NBS,NCS,NDS,
     &            KAL,KBL,KCL,KDL,KAS,KBS,KCS,KDS
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     ANGULAR FACTOR SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
      CALL SYSTEM_CLOCK(ICL1,RATE)
C
C     INTEGRAL PERMUTATIONS: FEEL FREE TO PLAY WITH THESE BOOLEANS
      PRM1IJ = .TRUE.
      PRM1KL = .TRUE.
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     MANUAL OVERRIDE FOR GENERAL MOLECULES (MIGHT WORK; NEEDS TESTING)
      IF(ISYM.EQ.0) THEN
        PRM1IJ = .FALSE.
        PRM1KL = .FALSE.
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL LQN ORBITAL TYPES (USE INDEX 1000)                 C
C**********************************************************************C
C
C     LOOP OVER LQN(A) VALUES
      DO 1001 LA=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK A
        LQN(1) = LA
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),IZ)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),IZ)
        ENDDO
C
C     LOOP OVER LQN(B) VALUES
      DO 1002 LB=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK B
        LQN(2) = LB
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),IZ)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),IZ)
        ENDDO
C
C       NUMBER OF BASIS FUNCTIONS IN (AB) BLOCK
        MAXAB = NBAS(1)*NBAS(2)
C
C       TRIANGLE RULE FOR LA <-> LB
        IF(PRM1IJ) THEN
          IF(LA.GT.LB) GOTO 1100
        ENDIF
C
C     LOOP OVER LQN(C) VALUES
      DO 1101 LC=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK C
        LQN(3) = LC
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),IZ)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),IZ)
        ENDDO
C
C     LOOP OVER LQN(D) VALUES
      DO 1102 LD=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK D
        LQN(4) = LD
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),IZ)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),IZ)
        ENDDO
C
C       NUMBER OF BASIS FUNCTIONS IN (CD) BLOCK
        MAXCD = NBAS(3)*NBAS(4)
C
C       TRIANGLE RULE FOR LC <-> LD
        IF(PRM1KL) THEN
          IF(LC.GT.LD) GOTO 1200
        ENDIF
C
C       DETERMINE THE TENSOR ORDERS REQUIRED FOR THIS LQN BLOCK
        CALL SYSTEM_CLOCK(ICL3,RATE)
        CALL TNSCLM1(LQN,ISEL)
        CALL SYSTEM_CLOCK(ICL4)
        TC1A = TC1A + DFLOAT(ICL4-ICL3)/RATE
C
        IF(ISEL.EQ.0) GOTO 1200
C
C       BASIS SET INTERMEDIATES FOR THE DENSITY PAIRS
        CALL SYSTEM_CLOCK(ICL3,RATE)
        CALL IJSET1
        CALL KLSET1
        CALL SYSTEM_CLOCK(ICL4)
        TC1I = TC1I + DFLOAT(ICL4-ICL3)/RATE
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES FOR THESE LQNS (USE INDEX 2000) C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 NA=1,KRONECK(LA,0),-1
        KA = 2*LA+NA
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,IZ)
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 NB=1,KRONECK(LB,0),-1
        KB = 2*LB+NB
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,IZ)
C
C       TRIANGLE RULE FOR KA <-> KB
        IF(PRM1IJ) THEN
          IF(KA.GT.KB) GOTO 2100
        ENDIF
C
C     LOOP OVER KQN(C) VALUES
      DO 2101 NC=1,KRONECK(LC,0),-1
        KC = 2*LC+NC
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,IZ)
C
C     LOOP OVER KQN(D) VALUES
      DO 2102 ND=1,KRONECK(LD,0),-1
        KD = 2*LD+ND
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,IZ)
C
C       TRIANGLE RULE FOR KC <-> KD
        IF(PRM1KL) THEN
          IF(KC.GT.KD) GOTO 2200
        ENDIF
C
C     UNIQUE ADDRESS FOR THIS KQN COMBINATION WITHIN THE LQN BLOCK
      K4AD = 16 - (8*NA + 4*NB + 2*NC + ND)
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RKCLM1                      C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      CALL SYSTEM_CLOCK(ICL3,RATE)
      C1 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+1)
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
      C9 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
      CALL SYSTEM_CLOCK(ICL4)
      TC1I = TC1I + DFLOAT(ICL4-ICL3)/RATE
C
C     ANGULAR COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL3,RATE)
      CALL ANGCLM1(DKAB,DKCD,KQN,LQN,ISEL)
      CALL SYSTEM_CLOCK(ICL4)
      TC1A = TC1A + DFLOAT(ICL4-ICL3)/RATE
C
C     EXIT THIS COMBINATION IF IT VIOLATES A SELECTION RULE
      IF(ISEL.EQ.0) GOTO 2200
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 3000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      IF(HMLT.EQ.'NORL') THEN
        N2EB(1,1) = N2EB(1,1) + 1
      ELSE
        N2EB(1,1) = N2EB(1,1) + 1
        N2EB(1,2) = N2EB(1,2) + 1
        N2EB(1,3) = N2EB(1,3) + 1
        N2EB(1,4) = N2EB(1,4) + 1
      ENDIF
C
      IJ = 0
      DO 3001 IBAS=1,NBAS(1)
      DO 3002 JBAS=1,NBAS(2)
        IJ = IJ+1
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        IF(HMLT.EQ.'NORL') THEN
          N2EI(1,1) = N2EI(1,1) + MAXCD
        ELSE
          N2EI(1,1) = N2EI(1,1) + MAXCD
          N2EI(1,2) = N2EI(1,2) + MAXCD
          N2EI(1,3) = N2EI(1,3) + MAXCD
          N2EI(1,4) = N2EI(1,4) + MAXCD
        ENDIF
C
C       NEW SET OF BETA INTEGRALS FOR THIS LQN BLOCK
        CALL SYSTEM_CLOCK(ICL3,RATE)
        IF(K4AD.EQ.1) THEN
          CALL BTACLM1
C         CALL BETASET((NUF-NUI)/2+3,NUI-1,NUF+2)
        ENDIF
        CALL SYSTEM_CLOCK(ICL4)
        TC1B = TC1B + DFLOAT(ICL4-ICL3)/RATE
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL SYSTEM_CLOCK(ICL3,RATE)
        CALL RKCLM1(RJLLLL,RJLLSS,RJSSLL,RJSSSS)
        CALL SYSTEM_CLOCK(ICL4)
        TC1R = TC1R + DFLOAT(ICL4-ICL3)/RATE
C
C       CAN NOW CONTRACT THESE RADIAL INTEGRALS OVER ANGULAR COMPONENTS
C       OF G-SPINOR BASIS FUNCTIONS USING A TENSOR EXPANSION IN {L,Q}
C
C**********************************************************************C
C     LOOP OVER |MQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 4000)   C
C**********************************************************************C
C
      DO 4001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 4002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
CC
CC       TRIANGLE RULE FOR MA <-> MB
C        IF(PRM1IJ) THEN
C          IF(KA.EQ.KB.AND.MA.GT.MB) GOTO 4100
C        ENDIF
C
      DO 4101 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 4102 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
CC
CC       TRIANGLE RULE FOR MC <-> MD
C        IF(PRM1KL) THEN
C          IF(MC.GT.MD) GOTO 4200
C        ENDIF
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        ISELM = 0
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) ISELM = 1
        IF(ISELM.EQ.0) GOTO 4200
      ENDIF
C
C**********************************************************************C
C     LOOP OVER THE SIGNS OF |MQN| FOR A,B,C,D BLOCKS (USE INDEX 5000) C
C**********************************************************************C
C
      DO 5001 MMA=1,2
        MMJA = MQN(1)*((-1)**MMA)
        IMJA = MQN(1)+MMA-1
C
      DO 5002 MMB=1,2
        MMJB = MQN(2)*((-1)**MMB)
        IMJB = MQN(2)+MMB-1
C
C       TRIANGLE RULE FOR |MA| <-> |MB|
        IF(PRM1IJ) THEN
          IF(KA.EQ.KB.AND.MA.EQ.MB.AND.MMA.GT.MMB) GOTO 5100
        ENDIF
C
      DO 5101 MMC=1,2
        MMJC = MQN(3)*((-1)**MMC)
        IMJC = MQN(3)+MMC-1
C
      DO 5102 MMD=1,2
        MMJD = MQN(4)*((-1)**MMD)
        IMJD = MQN(4)+MMD-1
C
C       TRIANGLE RULE FOR |MC| <-> |MD|
        IF(PRM1KL) THEN
          IF(KC.EQ.KD.AND.MC.EQ.MD.AND.MMC.GT.MMD) GOTO 5200
        ENDIF
C
C     PHASE FACTORS FOR PERMUTATION SWAPS
      PAB = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((MMJA-MMJB)/2))
      PCD = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((MMJC-MMJD)/2))
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LRGE(IZ,KA,2*MA-2+MMA)
      NBL = LRGE(IZ,KB,2*MB-2+MMB)
      NCL = LRGE(IZ,KC,2*MC-2+MMC)
      NDL = LRGE(IZ,KD,2*MD-2+MMD)
C
      NAS = NAL+NSKP
      NBS = NBL+NSKP
      NCS = NCL+NSKP
      NDS = NDL+NSKP
C
C     STARTING FOCK ADDRESS FOR KRAMERS COMPLEMENTS
      KAL = LRGE(IZ,KA,2*MA+1-MMA)
      KBL = LRGE(IZ,KB,2*MB+1-MMB)
      KCL = LRGE(IZ,KC,2*MC+1-MMC)
      KDL = LRGE(IZ,KD,2*MD+1-MMD)
C
      KAS = KAL+NSKP
      KBS = KBL+NSKP
      KCS = KCL+NSKP
      KDS = KDL+NSKP
C
C     APPLY MORE MQN SELECTION RULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        ISELM = 0
        IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
        IF(ISELM.EQ.0) GOTO 5200
      ENDIF
C
C     INITIALISE EFFECTIVE INTERACTION STRENGTH VALUES
      CALL SYSTEM_CLOCK(ICL3,RATE)
      DO M=1,MAXCD
        XLLLL(M) = 0.0D0
        XLLSS(M) = 0.0D0
        XSSLL(M) = 0.0D0
        XSSSS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       SKIP IF THIS LQN BLOCK TENSOR ORDER ISN'T IN THE KQN BLOCK
        IF(INU(LTEN,K4AD).EQ.0) GOTO 5201
C
C       ANGULAR COEFFICIENT
        ANGFAC = DKAB(LTEN,IMJA,IMJB)*DKCD(LTEN,IMJC,IMJD)
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        IF(DABS(ANGFAC).LE.SENS) GOTO 5201
C
        IF(HMLT.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          DO M=1,MAXCD
            XLLLL(M) = XLLLL(M) + ANGFAC*RJLLLL(M,LTEN)
          ENDDO
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
          DO M=1,MAXCD
            XLLLL(M) = XLLLL(M) + ANGFAC*RJLLLL(M,LTEN)
            XLLSS(M) = XLLSS(M) + ANGFAC*RJLLSS(M,LTEN)
            XSSLL(M) = XSSLL(M) + ANGFAC*RJSSLL(M,LTEN)
            XSSSS(M) = XSSSS(M) + ANGFAC*RJSSSS(M,LTEN)
          ENDDO
C
        ENDIF
C
C       SKIP POINT FOR ANGULAR SCREENING
5201    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL SYSTEM_CLOCK(ICL4)
      TC1F = TC1F + DFLOAT(ICL4-ICL3)/RATE
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL COULOMB MATRIX     C
C -------------------------------------------------------------------- C
C     TODO: BE AWARE THAT THERE ARE ISSUES WITH NUMERICAL ACCURACY     C
C           IN THIS METHOD, STEMMING FROM ACCUMULATING ERRORS IN THE   C
C           FLOATING-POINT REPRESENTATION OF INTEGERS AND RATIONALS.   C
C           (EG. ANGFAC^2 IS A RATIONAL NUMBER).                       C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL3,RATE)
C
C     MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
      IF(ISYM.EQ.0) THEN
        CALL CLMMT1G(XLLLL,XSSLL,XLLSS,XSSSS)
      ELSE
        CALL CLMMT1Z(XLLLL,XSSLL,XLLSS,XSSSS)
      ENDIF
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL SYSTEM_CLOCK(ICL4)
      TC1M = TC1M + DFLOAT(ICL4-ICL3)/RATE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTRE CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
5200  CONTINUE
C     END LOOP OVER ALL |MQN|(CD) SIGNS
5102  CONTINUE
5101  CONTINUE
C     EARLY EXIT FOR MQN TRIANGLE RULES
5100  CONTINUE
C     END LOOP OVER ALL |MQN|(AB) SIGNS
5002  CONTINUE
5001  CONTINUE
C     EARLY EXIT FOR MQN TRIANGLE RULE
4200  CONTINUE
C     END LOOP OVER |MQN|(CD) MAGNITUDES
4102  CONTINUE
4101  CONTINUE
C     EARLY EXIT FOR MQN TRIANGLE RULE
4100  CONTINUE
C     END LOOP OVER |MQN|(AB) MAGNITUDES
4002  CONTINUE
4001  CONTINUE
C     END LOOP OVER IBAS AND JBAS
3002  CONTINUE
3001  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES/TRIANGLE RULE
2200  CONTINUE
C     END LOOP OVER KQN(CD)
2102  CONTINUE
2101  CONTINUE
C     EARLY EXIT FOR KQN TRIANGLE RULE
2100  CONTINUE
C     END LOOP OVER KQN(AB)
2002  CONTINUE
2001  CONTINUE
C     EARLY EXIT FOR LQN SELECTION RULES/TRIANGLE RULE
1200  CONTINUE
C     END LOOP OVER LQN(CD)
1102  CONTINUE
1101  CONTINUE
C     EARLY EXIT FOR LQN TRIANGLE RULE
1100  CONTINUE
C     END LOOP OVER LQN(AB)
1002  CONTINUE
1001  CONTINUE
C
C     MATRIX HERMITICITY (CLOSED-SHELL)
      CALL SYSTEM_CLOCK(ICL3,RATE)
      DO I=1,NDIM
        DO J=I+1,NDIM
          GDIR(J,I) = DCONJG(GDIR(I,J))
          GXCH(J,I) = DCONJG(GXCH(I,J))
        ENDDO
      ENDDO
C
C     MATRIX HERMITICITY (OPEN-SHELL)
      IF(NOPN.NE.0) THEN
        DO I=1,NDIM
          DO J=I+1,NDIM
            QDIR(J,I) = DCONJG(QDIR(I,J))
            QXCH(J,I) = DCONJG(QXCH(I,J))
          ENDDO
        ENDDO
      ENDIF
      CALL SYSTEM_CLOCK(ICL4)
      TC1M = TC1M + DFLOAT(ICL4-ICL3)/RATE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL SYSTEM_CLOCK(ICL2)
      IF(HMLT.EQ.'NORL') THEN
        T2ES(1,1) = T2ES(1,1) +        DFLOAT(ICL2-ICL1)/RATE
      ELSE
        T2ES(1,1) = T2ES(1,1) + 0.25D0*DFLOAT(ICL2-ICL1)/RATE
        T2ES(1,2) = T2ES(1,2) + 0.25D0*DFLOAT(ICL2-ICL1)/RATE
        T2ES(1,3) = T2ES(1,3) + 0.25D0*DFLOAT(ICL2-ICL1)/RATE
        T2ES(1,4) = T2ES(1,4) + 0.25D0*DFLOAT(ICL2-ICL1)/RATE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE CLMMT1Z(XLLLL,XSSLL,XLLSS,XSSSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC  LL       MM       MM MM       MM TTTTTTTT 11  ZZZZZZZZ    C
C   CC    CC LL       MMM     MMM MMM     MMM    TT   111       ZZ     C
C   CC       LL       MMMM   MMMM MMMM   MMMM    TT    11      ZZ      C
C   CC       LL       MM MM MM MM MM MM MM MM    TT    11     ZZ       C
C   CC       LL       MM  MMM  MM MM  MMM  MM    TT    11    ZZ        C
C   CC    CC LL       MM   M   MM MM   M   MM    TT    11   ZZ         C
C    CCCCCC  LLLLLLLL MM       MM MM       MM    TT   1111 ZZZZZZZZ    C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMT1Z ASSEMBLES CONTRIBUTIONS TO THE MOLECULAR COULOMB MATRIX     C
C  WHICH ARISE FROM A SINGLE NUCLEAR CENTRE IN A GENERAL MOLECULE.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION XLLLL(MB2),XSSLL(MB2),XLLSS(MB2),XSSSS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MT1A/PAB,PCD,MMA,MMB,MMC,MMD,
     &            NAL,NBL,NCL,NDL,NAS,NBS,NCS,NDS,
     &            KAL,KBL,KCL,KDL,KAS,KBS,KCS,KDS
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.EQ.0) THEN
        WRITE(6,*) 'In CLMMT1Z: you probably should be using CLMMT1G.'
        WRITE(7,*) 'In CLMMT1Z: you probably should be using CLMMT1G.'
      ENDIF
C
C     VALUES WHICH REFLECT SIGN AND MAGNITUDE OF MQN
      MMJA = MQN(1)*((-1)**MMA)
      MMJB = MQN(2)*((-1)**MMB)
      MMJC = MQN(3)*((-1)**MMC)
      MMJD = MQN(4)*((-1)**MMD)
C
C**********************************************************************C
C     ASSEMBLE THE CLOSED-SHELL DIRECT COULOMB MATRIX (GDIR)           C
C**********************************************************************C
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)
        IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 101
        IF(MMA.NE.MMB.OR.MMC.NE.MMD) GOTO 101
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                   +      XLLLL(M)*DREAL(DENT(NCL+KBAS,NDL+LBAS))
            ENDDO
          ENDDO
        ENDIF
101     CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GDIR: NO PERMUTATION SYMMETRY EMPLOYED                         C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
        IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 102
        IF(MMA.NE.MMB.OR.MMC.NE.MMD) GOTO 102
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)  --  (AB|CD)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                   +      XLLLL(M)*DREAL(DENT(NCL+KBAS,NDL+LBAS))
     &                   +      XLLSS(M)*DREAL(DENT(NCS+KBAS,NDS+LBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(SS)  --  (AB|CD)
        IF(NAS.LE.NBS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS)
     &                   +      XSSLL(M)*DREAL(DENT(NCL+KBAS,NDL+LBAS))
     &                   +      XSSSS(M)*DREAL(DENT(NCS+KBAS,NDS+LBAS))
            ENDDO
          ENDDO
        ENDIF
C
102     CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GDIR: PERMUTATION SYMMETRY I⇄J         ONLY                    C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C       MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
        IF(.NOT.PRM1IJ) GOTO 103
C
C       SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
        IF(KQN(1).EQ.KQN(2)) GOTO 103
C
C       MQN SIGN SELECTION RULE
        IF(-MMJB-MMJA.NE.-MMJD-MMJC) GOTO 103
        IF(MMB.EQ.MMA.OR.MMC.EQ.MMD) GOTO 103
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)  --  (BA|CD)
        IF(KBL.LE.KAL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(KBL+JBAS,KAL+IBAS) = GDIR(KBL+JBAS,KAL+IBAS)
     &                   +  PAB*XLLLL(M)*DREAL(DENT(NCL+KBAS,NDL+LBAS))
     &                   +  PAB*XLLSS(M)*DREAL(DENT(NCS+KBAS,NDS+LBAS))
            ENDDO
          ENDDO
        ENDIF

C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(SS)  --  (BA|CD)
        IF(KBS.LE.KAS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(KBS+JBAS,KAS+IBAS) = GDIR(KBS+JBAS,KAS+IBAS)
     &                   +  PAB*XSSLL(M)*DREAL(DENT(NCL+KBAS,NDL+LBAS))
     &                   +  PAB*XSSSS(M)*DREAL(DENT(NCS+KBAS,NDS+LBAS))
            ENDDO
          ENDDO
        ENDIF
C
103     CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GDIR: PERMUTATION SYMMETRY      K⇄L ONLY                       C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C       MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
        IF(.NOT.PRM1KL) GOTO 104
C
C       SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
        IF(KQN(3).EQ.KQN(4)) GOTO 104
C
C       MQN SIGN SELECTION RULE
        IF(MMJA-MMJB.NE.MMJC-MMJD) GOTO 104
        IF(MMA.NE.MMB.OR.MMD.NE.MMC) GOTO 104
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)  --  (AB|DC)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                   +  PCD*XLLLL(M)*DREAL(DENT(KDL+LBAS,KCL+KBAS))
     &                   +  PCD*XLLSS(M)*DREAL(DENT(KDS+LBAS,KCS+KBAS))
            ENDDO
          ENDDO
        ENDIF

C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(SS)  --  (AB|DC)
        IF(NAS.LE.NBS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS)
     &                   +  PCD*XSSLL(M)*DREAL(DENT(KDL+LBAS,KCL+KBAS))
     &                   +  PCD*XSSSS(M)*DREAL(DENT(KDS+LBAS,KCS+KBAS))
            ENDDO
          ENDDO
        ENDIF
C
104     CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GDIR: PERMUTATION SYMMETRY I⇄J AND K⇄L                         C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
        IF(.NOT.PRM1IJ) GOTO 105
        IF(.NOT.PRM1KL) GOTO 105
C
C       SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
        IF(KQN(1).EQ.KQN(2)) GOTO 105
        IF(KQN(3).EQ.KQN(4)) GOTO 105
C
C       MQN SIGN SELECTION RULE
        IF(-MMJB+MMJC.NE.-MMJA+MMJD) GOTO 105
        IF(MMB.NE.MMC.OR.MMD.NE.MMA) GOTO 105
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)  --  (BA|DC)
        IF(KBL.LE.KAL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(KBL+JBAS,KAL+IBAS) = GDIR(KBL+JBAS,KAL+IBAS)
     &                + PAB*PCD*XLLLL(M)*DREAL(DENT(KDL+LBAS,KCL+KBAS))
     &                + PAB*PCD*XLLSS(M)*DREAL(DENT(KDS+LBAS,KCS+KBAS))
            ENDDO
          ENDDO
        ENDIF

C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(SS)  --  (BA|DC)
        IF(KBS.LE.KAS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(KBS+JBAS,KAS+IBAS) = GDIR(KBS+JBAS,KAS+IBAS)
     &                + PAB*PCD*XSSLL(M)*DREAL(DENT(KDL+LBAS,KCL+KBAS))
     &                + PAB*PCD*XSSSS(M)*DREAL(DENT(KDS+LBAS,KCS+KBAS))
            ENDDO
          ENDDO
        ENDIF
C
105     CONTINUE
C
C     END CONDITIONAL OVER HMLT TYPES
      ENDIF
C
C**********************************************************************C
C     ASSEMBLE THE CLOSED-SHELL EXCHANGE COULOMB MATRIX (GXCH)         C
C**********************************************************************C
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GXCH(LL)
        IF(MMJA-MMJD.NE.MMJB-MMJC) GOTO 201
        IF(MMA.NE.MMD.OR.MMC.NE.MMB) GOTO 201
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS) 
     &                   +      XLLLL(M)*DREAL(DENT(NCL+KBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
201     CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GXCH: NO PERMUTATION SYMMETRY EMPLOYED                         C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C       CLOSED-SHELL EXCHANGE MATRIX GXCH
        IF(MMJA-MMJD.NE.MMJB-MMJC) GOTO 202
        IF(MMA.NE.MMD.OR.MMC.NE.MMB) GOTO 202
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LL)  --  (AD|CB)
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS)
     &                   +      XLLLL(M)*DREAL(DENT(NCL+KBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LS)  --  (AD|CB)
        IF(NAL.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,NDS+LBAS) = GXCH(NAL+IBAS,NDS+LBAS)
     &                   +      XLLSS(M)*DREAL(DENT(NCS+KBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
CC       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SL)  --  (AD|CB)
C        M = 0
C        DO KBAS=1,NBAS(3)
C          DO LBAS=1,NBAS(4)
C            M = M+1
C            GXCH(NAS+IBAS,NDL+LBAS) = GXCH(NAS+IBAS,NDL+LBAS)
C     &                   +      XSSLL(M)*DREAL(DENT(NCL+KBAS,NBS+JBAS)
C          ENDDO
C        ENDDO
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SS)  --  (AD|CB)
        IF(NAS.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAS+IBAS,NDS+LBAS) = GXCH(NAS+IBAS,NDS+LBAS)
     &                   +      XSSSS(M)*DREAL(DENT(NCS+KBAS,NBS+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
202     CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GXCH: PERMUTATION SYMMETRY I⇄J         ONLY                    C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C       MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
        IF(.NOT.PRM1IJ) GOTO 203
C
C       SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
        IF(KQN(1).EQ.KQN(2)) GOTO 203
C
C       MQN SIGN SELECTION RULE
        IF(-MMJB-MMJD.NE.-MMJA-MMJC) GOTO 203
        IF(MMB.EQ.MMD.OR.MMC.EQ.MMA) GOTO 203
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LL)  --  (AD|CB)
        IF(KBL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(KBL+JBAS,NDL+LBAS) = GXCH(KBL+JBAS,NDL+LBAS)
     &                + PAB*    XLLLL(M)*DREAL(DENT(NCL+KBAS,KAL+IBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LS)  --  (AD|CB)
        IF(KBL.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(KBL+JBAS,NDS+LBAS) = GXCH(KBL+JBAS,NDS+LBAS)
     &                + PAB*    XLLSS(M)*DREAL(DENT(NCS+KBAS,KAL+IBAS))
            ENDDO
          ENDDO
        ENDIF
C
CC       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SL)  --  (AD|CB)
C        IF(KBS.LT.NDL) THEN
C          M = 0
C          DO KBAS=1,NBAS(3)
C            DO LBAS=1,NBAS(4)
C              M = M+1
C              GXCH(KBS+JBAS,NDL+LBAS) = GXCH(KBS+JBAS,NDL+LBAS)
C     &                   +      XSSLL(M)*DREAL(DENT(NCL+KBAS,KAS+IBAS))
C            ENDDO
C          ENDDO
C        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SS)  --  (AD|CB)
        IF(KBS.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(KBS+JBAS,NDS+LBAS) = GXCH(KBS+JBAS,NDS+LBAS)
     &                + PAB*    XSSSS(M)*DREAL(DENT(NCS+KBAS,KAS+IBAS))
            ENDDO
          ENDDO
        ENDIF
C
203     CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GXCH: PERMUTATION SYMMETRY         K⇄L ONLY                    C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C       MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
        IF(.NOT.PRM1KL) GOTO 204
C
C       SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
        IF(KQN(3).EQ.KQN(4)) GOTO 204
C
C       MQN SIGN SELECTION RULE
        IF(MMJA+MMJC.NE.MMJB+MMJD) GOTO 204
        IF(MMA.EQ.MMC.OR.MMD.EQ.MMB) GOTO 204
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LL)  --  (AC|DB)
        IF(NAL.LE.KCL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,KCL+KBAS) = GXCH(NAL+IBAS,KCL+KBAS)
     &                +     PCD*XLLLL(M)*DREAL(DENT(KDL+LBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LS)  --  (AC|DB)
        IF(NAL.LE.KCS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,KCS+KBAS) = GXCH(NAL+IBAS,KCS+KBAS)
     &                +     PCD*XLLSS(M)*DREAL(DENT(KDS+LBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
CC       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SL)  --  (AC|DB)
C        M = 0
C        DO KBAS=1,NBAS(3)
C          DO LBAS=1,NBAS(4)
C            M = M+1
C            GXCH(NAS+IBAS,KCL+KBAS) = GXCH(NAS+IBAS,KCL+KBAS)
C     &                +     PCD*XSSLL(M)*DREAL(DENT(KDL+LBAS,NBS+JBAS)
C          ENDDO
C        ENDDO
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SS)  --  (AC|DB)
        IF(NAS.LE.KCS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAS+IBAS,KCS+KBAS) = GXCH(NAS+IBAS,KCS+KBAS)
     &                +     PCD*XSSSS(M)*DREAL(DENT(KDS+LBAS,NBS+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
204     CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C       GXCH: PERMUTATION SYMMETRY I⇄J AND K⇄L                         C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C       MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
        IF(.NOT.PRM1IJ) GOTO 205
        IF(.NOT.PRM1KL) GOTO 205
C
C       SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
        IF(KQN(1).EQ.KQN(2)) GOTO 205
        IF(KQN(3).EQ.KQN(4)) GOTO 205
C
C       MQN SIGN SELECTION RULE
        IF(-MMJB+MMJC.NE.-MMJA+MMJD) GOTO 205
        IF(MMB.NE.MMC.OR.MMD.NE.MMA) GOTO 205
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LL)  --  (BC|DA)
        IF(KBL.LE.KCL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(KBL+JBAS,KCL+KBAS) = GXCH(KBL+JBAS,KCL+KBAS)
     &                + PAB*PCD*XLLLL(M)*DREAL(DENT(KDL+LBAS,KAL+IBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LS)  --  (BC|DA)
        IF(KBL.LE.KCS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(KBL+JBAS,KCS+KBAS) = GXCH(KBL+JBAS,KCS+KBAS)
     &                + PAB*PCD*XLLSS(M)*DREAL(DENT(KDS+LBAS,KAL+IBAS))
            ENDDO
          ENDDO
        ENDIF
C
CC       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SL)  --  (BC|DA)
C        M = 0
C        DO KBAS=1,NBAS(3)
C          DO LBAS=1,NBAS(4)
C            M = M+1
C            GXCH(KBS+JBAS,KCL+KBAS) = GXCH(KBS+JBAS,KCL+KBAS)
C     &                 + PAB*PCD*XSSLL(M)*DREAL(DENT(KDL+LBAS,KAS+IBAS)
C          ENDDO
C        ENDDO
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SS)  --  (BC|DA)
        IF(KBS.LE.KCS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(KBS+JBAS,KCS+KBAS) = GXCH(KBS+JBAS,KCS+KBAS)
     &                + PAB*PCD*XSSSS(M)*DREAL(DENT(KDS+LBAS,KAS+IBAS))
            ENDDO
          ENDDO
        ENDIF
C
205     CONTINUE
C
C     END CONDITIONAL OVER HMLT TYPES
      ENDIF
C
      IF(NOPN.EQ.0) GOTO 901
C
C**********************************************************************C
C     ASSEMBLE THE OPEN-SHELL DIRECT COULOMB MATRIX (QDIR)             C
C**********************************************************************C
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       OPEN-SHELL DIRECT MATRIX BLOCK QDIR(LL)
        IF(MMA.NE.MMB.OR.MMC.NE.MMD) GOTO 301
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                   + ACFF*XLLLL(M)*DREAL(DENO(NCL+KBAS,NDL+LBAS))
            ENDDO
          ENDDO
        ENDIF
C
301     CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       OPEN-SHELL DIRECT MATRIX QDIR
        IF(MMA.NE.MMB.OR.MMC.NE.MMD) GOTO 302
C
C       OPEN-SHELL DIRECT MATRIX BLOCK QDIR(LL)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                   + ACFF*XLLLL(M)*DREAL(DENO(NCL+KBAS,NDL+LBAS))
     &                   + ACFF*XLLSS(M)*DREAL(DENO(NCS+KBAS,NDS+LBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       OPEN-SHELL DIRECT MATRIX BLOCK QDIR(SS)
        IF(NAS.LE.NBS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QDIR(NAS+IBAS,NBS+JBAS) = QDIR(NAS+IBAS,NBS+JBAS)
     &                   + ACFF*XSSLL(M)*DREAL(DENO(NCL+KBAS,NDL+LBAS))
     &                   + ACFF*XSSSS(M)*DREAL(DENO(NCS+KBAS,NDS+LBAS))
            ENDDO
          ENDDO
        ENDIF
C
302     CONTINUE
C
C     END CONDITIONAL OVER HMLT TYPES
      ENDIF
C
C**********************************************************************C
C     ASSEMBLE THE OPEN-SHELL EXCHANGE COULOMB MATRIX (QXCH)           C
C**********************************************************************C
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(LL)
        IF(MMA.NE.MMD.OR.MMC.NE.MMB) GOTO 401
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                   + BCFF*XLLLL(M)*DREAL(DENO(NCL+KBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
401     CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       OPEN-SHELL EXCHANGE MATRIX GXCH
        IF(MMA.NE.MMD.OR.MMC.NE.MMB) GOTO 402
C
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(LL)
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                   + BCFF*XLLLL(M)*DREAL(DENO(NCL+KBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(LS)
        IF(NAL.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAL+IBAS,NDS+LBAS) = QXCH(NAL+IBAS,NDS+LBAS)
     &                   + BCFF*XLLSS(M)*DREAL(DENO(NCS+KBAS,NBL+JBAS))
            ENDDO
          ENDDO
        ENDIF
CC
CC       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(SL)
C        IF(NAS.LE.NDL) THEN
C          M = 0
C          DO KBAS=1,NBAS(3)
C            DO LBAS=1,NBAS(4)
C              M = M+1
C              QXCH(NAS+IBAS,NDL+LBAS) = QXCH(NAS+IBAS,NDL+LBAS)
C     &                   + BCFF*XSSLL(M)*DREAL(DENO(NCL+KBAS,NBS+JBAS))
C            ENDDO
C          ENDDO
C        ENDIF
CC
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(SS)
        IF(NAS.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAS+IBAS,NDS+LBAS) = QXCH(NAS+IBAS,NDS+LBAS)
     &                   + BCFF*XSSSS(M)*DREAL(DENO(NCS+KBAS,NBS+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
402     CONTINUE
C
C     END CONDITIONAL OVER HMLT TYPES
      ENDIF
C
C     END CONDITIONAL FOR OPEN-SHELL SYSTEM
901   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE CLMMT1G(XLLLL,XSSLL,XLLSS,XSSSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC  LL       MM       MM MM       MM TTTTTTTT 11  GGGGGG     C
C    CC    CC LL       MMM     MMM MMM     MMM    TT   111 GG    GG    C
C    CC       LL       MMMM   MMMM MMMM   MMMM    TT    11 GG          C
C    CC       LL       MM MM MM MM MM MM MM MM    TT    11 GG          C
C    CC       LL       MM  MMM  MM MM  MMM  MM    TT    11 GG   GGG    C
C    CC    CC LL       MM   M   MM MM   M   MM    TT    11 GG    GG    C
C     CCCCCC  LLLLLLLL MM       MM MM       MM    TT   1111 GGGGGG     C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMT1G ASSEMBLES CONTRIBUTIONS TO THE MOLECULAR COULOMB MATRIX     C
C  WHICH ARISE FROM A SINGLE NUCLEAR CENTRE IN A GENERAL MOLECULE.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION XLLLL(MB2),XSSLL(MB2),XLLSS(MB2),XSSSS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MT1A/PAB,PCD,MMA,MMB,MMC,MMD,
     &            NAL,NBL,NCL,NDL,NAS,NBS,NCS,NDS,
     &            KAL,KBL,KCL,KDL,KAS,KBS,KCS,KDS
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.NE.0) THEN
        WRITE(6,*) 'In CLMMT1G: you probably should be using CLMMT1Z.'
        WRITE(7,*) 'In CLMMT1G: you probably should be using CLMMT1Z.'
      ENDIF
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NDL+LBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GXCH(LL)
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS) 
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NBL+JBAS)
            ENDDO
          ENDDO
        ENDIF
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(LL)  --  (AB|CD)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NDL+LBAS)
     &                          +      XLLSS(M)*DENT(NCS+KBAS,NDS+LBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL DIRECT MATRIX BLOCK GDIR(SS)  --  (AB|CD)
        IF(NAS.LE.NBS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS)
     &                          +      XSSLL(M)*DENT(NCL+KBAS,NDL+LBAS)
     &                          +      XSSSS(M)*DENT(NCS+KBAS,NDS+LBAS)
            ENDDO
          ENDDO
        ENDIF
C
        IF(.NOT.PRM1IJ) GOTO 6900
        GOTO 6900
C
C       PERMUTATION BLOCK  A <-> B
        IF(KA.GT.KB.AND.IQ1.GT.IQ2) THEN
        
C          IF(IBAS.EQ.1.AND.JBAS.EQ.1) THEN
C            WRITE(*,*) 'TRIGGER'
C          ENDIF
C
          IF(NBL.LT.NAL) THEN
            M = 0
            DO KBAS=1,NBAS(3)
              DO LBAS=1,NBAS(4)
                M = M+1
                GDIR(NBL+JBAS,NAL+IBAS) = GDIR(NBL+JBAS,NAL+IBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NDL+LBAS)
     &                          +      XLLSS(M)*DENT(NCS+KBAS,NDS+LBAS)
              ENDDO
            ENDDO
          ENDIF

          IF(NBS.LT.NAS) THEN
            M = 0
            DO KBAS=1,NBAS(3)
              DO LBAS=1,NBAS(4)
                M = M+1
                GDIR(NBS+JBAS,NAS+IBAS) = GDIR(NBS+JBAS,NAS+IBAS)
     &                          +      XSSLL(M)*DENT(NCL+KBAS,NDL+LBAS)
     &                          +      XSSSS(M)*DENT(NCS+KBAS,NDS+LBAS)
              ENDDO
            ENDDO
          ENDIF
        
        ENDIF
6900    CONTINUE
C
C       CLOSED-SHELL EXCHANGE MATRIX GXCH
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LL)  --  (AD|CB)
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NBL+JBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LS)  --  (AD|CB)
        IF(NAL.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAL+IBAS,NDS+LBAS) = GXCH(NAL+IBAS,NDS+LBAS)
     &                          +      XLLSS(M)*DENT(NCS+KBAS,NBL+JBAS)
            ENDDO
          ENDDO
        ENDIF
CC
CC       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SL)  --  (AD|CB)
C        IF(NAS.LE.NDL) THEN
C          M = 0
C          DO KBAS=1,NBAS(3)
C            DO LBAS=1,NBAS(4)
C              M = M+1
C              GXCH(NAS+IBAS,NDL+LBAS) = GXCH(NAS+IBAS,NDL+LBAS)
C     &                          +      XSSLL(M)*DENT(NCL+KBAS,NBS+JBAS)
C            ENDDO
C          ENDDO
C        ENDIF
C
C       CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SS)  --  (AD|CB)
        IF(NAS.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              GXCH(NAS+IBAS,NDS+LBAS) = GXCH(NAS+IBAS,NDS+LBAS)
     &                          +      XSSSS(M)*DENT(NCS+KBAS,NBS+JBAS)
            ENDDO
          ENDDO
        ENDIF
C
        IF(.NOT.PRM1IJ) GOTO 6901
C       GOTO 6901
C
C       PERMUTATION BLOCK  A <-> B
C        IF(IQ1.GT.IQ2) THEN
C          WRITE(*,*) 'HERE?'
C
C         CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LL)  --  (AD|CB)
          IF(NBL.LT.NDL) THEN
            M = 0
            DO KBAS=1,NBAS(3)
              DO LBAS=1,NBAS(4)
                M = M+1
                GXCH(NBL+JBAS,NDL+LBAS) = GXCH(NBL+JBAS,NDL+LBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NAL+IBAS)
              ENDDO
            ENDDO
          ENDIF
C
C         CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(LS)  --  (AD|CB)
          IF(NBL.LT.NDS) THEN
            M = 0
            DO KBAS=1,NBAS(3)
              DO LBAS=1,NBAS(4)
                M = M+1
                GXCH(NBL+JBAS,NDS+LBAS) = GXCH(NBL+JBAS,NDS+LBAS)
     &                          +      XLLSS(M)*DENT(NCS+KBAS,NAL+IBAS)
              ENDDO
            ENDDO
          ENDIF
CC
CC         CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SL)  --  (AD|CB)
C          IF(NBS.LT.NDL) THEN
C            M = 0
C            DO KBAS=1,NBAS(3)
C              DO LBAS=1,NBAS(4)
C                M = M+1
C                GXCH(NBS+JBAS,NDL+LBAS) = GXCH(NBS+JBAS,NDL+LBAS)
C     &                          +      XSSLL(M)*DENT(NCL+KBAS,NAS+IBAS)
C              ENDDO
C            ENDDO
C          ENDIF
C
C         CLOSED-SHELL EXCHANGE MATRIX BLOCK GXCH(SS)  --  (AD|CB)
          IF(NBS.LT.NDS) THEN
            M = 0
            DO KBAS=1,NBAS(3)
              DO LBAS=1,NBAS(4)
                M = M+1
                GXCH(NBS+JBAS,NDS+LBAS) = GXCH(NBS+JBAS,NDS+LBAS)
     &                          +      XSSSS(M)*DENT(NCS+KBAS,NAS+IBAS)
              ENDDO
            ENDDO
          ENDIF
        
C        ENDIF
6901    CONTINUE
C
      ENDIF
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL COULOMB MATRIX       C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 6100
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       OPEN-SHELL DIRECT MATRIX BLOCK QDIR(LL)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                          + ACFF*XLLLL(M)*DENO(NCL+KBAS,NDL+LBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(LL)
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLLLL(M)*DENO(NCL+KBAS,NBL+JBAS)
            ENDDO
          ENDDO
        ENDIF
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       OPEN-SHELL DIRECT MATRIX QDIR
C
C       OPEN-SHELL DIRECT MATRIX BLOCK QDIR(LL)
        IF(NAL.LE.NBL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                          + ACFF*XLLLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                          + ACFF*XLLSS(M)*DENO(NCS+KBAS,NDS+LBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       OPEN-SHELL DIRECT MATRIX BLOCK QDIR(SS)
        IF(NAS.LE.NBS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QDIR(NAS+IBAS,NBS+JBAS) = QDIR(NAS+IBAS,NBS+JBAS)
     &                          + ACFF*XSSLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                          + ACFF*XSSSS(M)*DENO(NCS+KBAS,NDS+LBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       OPEN-SHELL EXCHANGE MATRIX GXCH
C
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(LL)
        IF(NAL.LE.NDL) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLLLL(M)*DENO(NCL+KBAS,NBL+JBAS)
            ENDDO
          ENDDO
        ENDIF
C
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(LS)
        IF(NAL.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAL+IBAS,NDS+LBAS) = QXCH(NAL+IBAS,NDS+LBAS)
     &                          + BCFF*XLLSS(M)*DENO(NCS+KBAS,NBL+JBAS)
            ENDDO
          ENDDO
        ENDIF
CC
CC       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(SL)
C        IF(NAS.LE.NDL) THEN
C          M = 0
C          DO KBAS=1,NBAS(3)
C            DO LBAS=1,NBAS(4)
C              M = M+1
C              QXCH(NAS+IBAS,NDL+LBAS) = QXCH(NAS+IBAS,NDL+LBAS)
C     &                          + BCFF*XSSLL(M)*DENO(NCL+KBAS,NBS+JBAS)
C            ENDDO
C          ENDDO
C        ENDIF
CC
C       OPEN-SHELL EXCHANGE MATRIX BLOCK QXCH(SS)
        IF(NAS.LE.NDS) THEN
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              QXCH(NAS+IBAS,NDS+LBAS) = QXCH(NAS+IBAS,NDS+LBAS)
     &                          + BCFF*XSSSS(M)*DENO(NCS+KBAS,NBS+JBAS)
            ENDDO
          ENDDO
        ENDIF
C
      ENDIF
C
6100  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BTACLM1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      BBBBBBB TTTTTTTT   AA     CCCCCC  LL       MM       MM  11      C
C      BB    BB   TT     AAAA   CC    CC LL       MMM     MMM 111      C
C      BB    BB   TT    AA  AA  CC       LL       MMMM   MMMM  11      C
C      BBBBBBB    TT   AA    AA CC       LL       MM MM MM MM  11      C
C      BB    BB   TT   AAAAAAAA CC       LL       MM  MMM  MM  11      C
C      BB    BB   TT   AA    AA CC    CC LL       MM   M   MM  11      C
C      BBBBBBB    TT   AA    AA  CCCCCC  LLLLLLLL MM       MM 1111     C
C                                                                      C
C -------------------------------------------------------------------- C
C  BTACLM1 EVALUATES A BATCH OF BETA INTEGRALS REQUIRED FOR THE        C
C  ONE-CENTRE RADIAL INTEGRALS OVER THE COULOMB INTERACTION.           C
C -------------------------------------------------------------------- C
C  INDEX 1 FOR UPPER INTEGRALS, INDEX 2 FOR LOWER INTEGRALS.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
C
      DIMENSION RJLSLS(MB2,MNU,2),RJSLSL(MB2,MNU,2),
     &          RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BETA/BDU(MB2*MB2,MNU,MNU),BDL(MB2*MB2,MNU,MNU)
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI(IJ)+EJ(IJ)
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXCD
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+3
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+NUI+2*NX-1
        IAA(2) = LQN(3)+LQN(4)+NUI+2*NX-1
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)-NUF+2*NY-2
          IBB(2) = LQN(1)+LQN(2)-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXCD
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXCD
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXCD
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXCD
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXCD
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXCD
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXCD
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
C           ASSEMBLE A LIST OF UPPER AND LOWER BETA INTEGRALS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXCD
                BDU((IJ-1)*MAXCD+M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXCD
                BDL((IJ-1)*MAXCD+M,NX,NY) = BETA(M)
              ENDDO
            ENDIF
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE TNSCLM1(LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     TTTTTTTT NN    NN  SSSSSS   CCCCCC  LL       MM       MM  11     C
C        TT    NNN   NN SS    SS CC    CC LL       MMM     MMM 111     C
C        TT    NNNN  NN SS       CC       LL       MMMM   MMMM  11     C
C        TT    NN NN NN  SSSSSS  CC       LL       MM MM MM MM  11     C
C        TT    NN  NNNN       SS CC       LL       MM  MMM  MM  11     C
C        TT    NN   NNN SS    SS CC    CC LL       MM   M   MM  11     C
C        TT    NN    NN  SSSSSS   CCCCCC  LLLLLLLL MM       MM 1111    C
C                                                                      C
C -------------------------------------------------------------------- C
C  TNSCLM1 PERFORMS THE TENSOR EXPANSION ANALYSIS FOR THE ONE-CENTRE   C
C  BREIT INTERACTION, FOR A GIVEN LQN COMBINATION BLOCK.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQN(4)
C
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     INITIALISE TENSOR EXPANSION ARRAY
      DO LTEN=1,MNU
        NUS(LTEN) = 0
        DO I=1,16
          INU(LTEN,I) = 0
        ENDDO
      ENDDO
      NUNUM = 0
C
C**********************************************************************C
C     LQN PARITY ANALYSIS: CHECK PARITY OF LQN COMBINATIONS.           C
C     EXIT IF THERE IS NO MULTIPOLE EXPANSION FOR THIS CASE.           C
C**********************************************************************C
C
C     A AND B: PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
      IPARAB = MOD(LQN(1)+LQN(2),2)
C
C     C AND D: PARITY OF 'LQN(3)+LQN(4)' (0 IF EVEN, 1 IF ODD)
      IPARCD = MOD(LQN(3)+LQN(4),2)
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.NE.IPARCD) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     TENSOR LIMITS BY TRIANGLE RULE
      NUI = MAX0(IABS(LQN(1)-LQN(2)),IABS(LQN(3)-LQN(4)))
      NUF = MIN0(    (LQN(1)+LQN(2)),    (LQN(3)+LQN(4)))
C
C     TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     CALCULATE COMPONENT-TYPE OVERLAP COEFFICIENTS FOR TENSOR ORDERS  C
C     NU (AND NU±1 WHERE APPLICABLE), COUPLING IN ANGULAR FACTORS.     C
C**********************************************************************C
C
      ISEL = 0
      NUNUM = 0
      DO NU=NUI,NUF
C
C       A AND B: PARITY OF 'LA+LB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C       C AND D: PARITY OF 'LC+LD+NU' (0 IF EVEN, 1 IF ODD)
        IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C       CASE 1: LA+LB+NU AND LC+LD+NU ARE BOTH ODD (AND NU=/=0)
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         INCREASE TOTAL NUMBER OF NU VALUES TO BE FACILITATED
          NUNUM = NUNUM+1
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(NUNUM) = NU
C
        ENDIF
C
      ENDDO
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(NUNUM.EQ.0) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C     RESET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
      RETURN
      END
C
C
      SUBROUTINE RKCLM1(RJLLLL,RJLLSS,RJSSLL,RJSSSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  KK    KK CCCCCC  LL       MM       MM  11           C
C         RR    RR KK   KK CC    CC LL       MMM     MMM 111           C
C         RR    RR KK  KK  CC       LL       MMMM   MMMM  11           C
C         RR    RR KKKKK   CC       LL       MM MM MM MM  11           C
C         RRRRRRR  KK  KK  CC       LL       MM  MMM  MM  11           C
C         RR    RR KK   KK CC    CC LL       MM   M   MM  11           C
C         RR    RR KK    KK CCCCCC  LLLLLLLL MM       MM 1111          C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKCLM1 EVALUATES A BATCH OF GENERAL (OPEN-SHELL) ONE-CENTRE RADIAL  C
C  INTEGRALS OVER THE COULOMB INTERACTION, SEPARATING RESULTS BY THE   C
C  ALLOWED TENSOR ORDERS RK(ABCD).                                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
C
      DIMENSION RJLLLL(MB2,MNU),RJLLSS(MB2,MNU),
     &          RJSSLL(MB2,MNU),RJSSSS(MB2,MNU)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BETA/BDU(MB2*MB2,MNU,MNU),BDL(MB2*MB2,MNU,MNU)
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR INTEGRALS
      DO M=1,MAXCD
        DO LTEN=1,NUNUM
          RJLLLL(M,LTEN) = 0.0D0
          RJLLSS(M,LTEN) = 0.0D0
          RJSSLL(M,LTEN) = 0.0D0
          RJSSSS(M,LTEN) = 0.0D0
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI(IJ)
      E0100 = EJ(IJ)
      E1100 = EI(IJ)*EJ(IJ)
C
C     LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXCD
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI(IJ)*EK(M)
        E1001 = EI(IJ)*EL(M)
        E0110 = EJ(IJ)*EK(M)
        E0101 = EJ(IJ)*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI(IJ)*EJ(IJ)*EK(M)
        E1101 = EI(IJ)*EJ(IJ)*EL(M)
        E1011 = EI(IJ)*EK(M)*EL(M)
        E0111 = EJ(IJ)*EK(M)*EL(M)
        E1111 = EI(IJ)*EJ(IJ)*EK(M)*EL(M)
C
C       UNIQUE FIXED ADDRESS FOR THE IBAS,JBAS COMBINATION
        MIJKL = (IJ-1)*MAXCD + M
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         SCREEN LQN BLOCK TENSOR ORDERS THAT ARE NOT IN THIS KQN BLOCK
          IF(INU(LTEN,K4AD).EQ.0) GOTO 50
C
C         BACKWARDS COUNT
          NTEN = NUNUM-LTEN
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C**********************************************************************C
C     SPECIAL CASE: NON-RELATIVISTIC HAMILTONIAN                       C
C**********************************************************************C
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           BETA INTEGRALS WITH POWERS OF EXPONENTIALS
            B32 = EIJ(IJ,-NU+2)*EKL(M, NU+3)*BDL(MIJKL,LTEN+1,NTEN+2)
     &          + EIJ(IJ, NU+3)*EKL(M,-NU+2)*BDU(MIJKL,LTEN+1,NTEN+2)
C
C           EFFECTIVE INTERACTION STRENGTH FOR THIS TENSOR ORDER
            RJLLLL(M,LTEN) = C5*B32
C
C           SKIP PAST THE RELATIVISTIC STAGES
            GOTO 999
C
          ENDIF
C
C**********************************************************************C
C     LARGER CASE: RELATIVISTIC HAMILTONIAN (T TERMS GIVE ZEROES)      C
C**********************************************************************C
C
C         TEMPORARY STORAGE OF RAW RJ(LTEN,M)
          B10 = EIJ(IJ,-NU  )*EKL(M, NU+1)*BDL(MIJKL,LTEN  ,NTEN+1)
     &        + EIJ(IJ, NU+1)*EKL(M,-NU  )*BDU(MIJKL,LTEN  ,NTEN+1)
          B12 = EIJ(IJ,-NU+2)*EKL(M, NU+1)*BDL(MIJKL,LTEN  ,NTEN+2)
     &        + EIJ(IJ, NU+3)*EKL(M,-NU  )*BDU(MIJKL,LTEN+1,NTEN+1)
          B14 = EIJ(IJ,-NU+4)*EKL(M, NU+1)*BDL(MIJKL,LTEN  ,NTEN+3)
     &        + EIJ(IJ, NU+5)*EKL(M,-NU  )*BDU(MIJKL,LTEN+2,NTEN+1)
          B30 = EIJ(IJ,-NU  )*EKL(M, NU+3)*BDL(MIJKL,LTEN+1,NTEN+1)
     &        + EIJ(IJ, NU+1)*EKL(M,-NU+2)*BDU(MIJKL,LTEN  ,NTEN+2)
          B32 = EIJ(IJ,-NU+2)*EKL(M, NU+3)*BDL(MIJKL,LTEN+1,NTEN+2)
     &        + EIJ(IJ, NU+3)*EKL(M,-NU+2)*BDU(MIJKL,LTEN+1,NTEN+2)
          B34 = EIJ(IJ,-NU+4)*EKL(M, NU+3)*BDL(MIJKL,LTEN+1,NTEN+3)
     &        + EIJ(IJ, NU+5)*EKL(M,-NU+2)*BDU(MIJKL,LTEN+2,NTEN+2)
          B50 = EIJ(IJ,-NU  )*EKL(M, NU+5)*BDL(MIJKL,LTEN+2,NTEN+1)
     &        + EIJ(IJ, NU+1)*EKL(M,-NU+4)*BDU(MIJKL,LTEN  ,NTEN+3)
          B52 = EIJ(IJ,-NU+2)*EKL(M, NU+5)*BDL(MIJKL,LTEN+2,NTEN+2)
     &        + EIJ(IJ, NU+3)*EKL(M,-NU+4)*BDU(MIJKL,LTEN+1,NTEN+3)
          B54 = EIJ(IJ,-NU+4)*EKL(M, NU+5)*BDL(MIJKL,LTEN+2,NTEN+3)
     &        + EIJ(IJ, NU+5)*EKL(M,-NU+4)*BDU(MIJKL,LTEN+2,NTEN+3)
C
C         EFFECTIVE INTERACTION STRENGTH RJLLLL(M,LTEN)
          RJLLLL(M,LTEN) = V1*T0000*E0000*C5*B32
C
C         EFFECTIVE INTERACTION STRENGTH RJLLSS(M,LTEN)
          RJLLSS(M,LTEN) = V4*T0000*E0011*C7*B52 - V2*T0001*E0010*C5*B32
     &                   - V2*T0010*E0001*C5*B32 + V1*T0011*E0000*C3*B12
C
C         EFFECTIVE INTERACTION STRENGTH RJSSLL(M,LTEN)
          RJSSLL(M,LTEN) = V4*T0000*E1100*C7*B34 - V2*T0100*E1000*C5*B32
     &                   - V2*T1000*E0100*C5*B32 + V1*T1100*E0000*C3*B30
C
C         EFFECTIVE INTERACTION STRENGTH RJSSSS(M,LTEN)
          RJSSSS(M,LTEN) = VS*T0000*E1111*C9*B54
     &                   - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                   - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                   + V4*T1100*E0011*C5*B50 + V4*T0011*E1100*C5*B14
     &                   + V4*T1001*E0110*C5*B32 + V4*T0110*E1001*C5*B32
     &                   + V4*T0101*E1010*C5*B32 + V4*T1010*E0101*C5*B32
     &                   - V2*T1101*E0010*C3*B30 - V2*T0111*E1000*C3*B12
     &                   - V2*T1110*E0001*C3*B30 - V2*T1011*E0100*C3*B12
     &                   + V1*T1111*E0000*C1*B10
C
50        CONTINUE
C
C         SKIP POINT FOR NON-RELATIVISTIC HAMILTONIANS
999       CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXCD
          RNLLLL = RNIJ(IJ,1)*RNKL(M,1)
          DO LTEN=1,NUNUM
            RJLLLL(M,LTEN) = RNLLLL*RJLLLL(M,LTEN)
          ENDDO
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXCD
          RNLLLL = RNIJ(IJ,1)*RNKL(M,1)
          RNLLSS = RNIJ(IJ,1)*RNKL(M,4)
          RNSSLL = RNIJ(IJ,4)*RNKL(M,1)
          RNSSSS = RNIJ(IJ,4)*RNKL(M,4)
          DO LTEN=1,NUNUM
            IF(INU(LTEN,K4AD).NE.0) THEN
              RJLLLL(M,LTEN) = RNLLLL*RJLLLL(M,LTEN)
              RJLLSS(M,LTEN) = RNLLSS*RJLLSS(M,LTEN)
              RJSSLL(M,LTEN) = RNSSLL*RJSSLL(M,LTEN)
              RJSSSS(M,LTEN) = RNSSSS*RJSSSS(M,LTEN)
            ENDIF
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM1(DKAB,DKCD,KQN,LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  11      C
C      AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 111      C
C     AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM  11      C
C    AA    AA NN NN NN GG       CC       LL       MM MM MM MM  11      C
C    AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM  11      C
C    AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM  11      C
C    AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM 1111     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION KQN(4),LQN(4),JQN(4)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
C
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
C     TENSOR LIMITS BY TRIANGLE RULE
      NUIT = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUFT = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUIT.GT.NUFT) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     FURTHER PARITY ANALYSIS: RUN OVER ALLOWED TENSOR ORDERS NU AND   C
C     SCREEN THOSE WHICH ARE NOT ALLOWED ON PARITY GROUNDS.            C
C**********************************************************************C
C
      NULNG = 0
      DO NU=NUIT,NUFT
C
C       A AND B: PARITY OF 'LQN(1)+LQN(2)+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C       C AND D: PARITY OF 'LQN(3)+LQN(4)+NU' (0 IF EVEN, 1 IF ODD)
        IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C       LQN SELECTION RULE: WHEN SUM OF A AND B, C AND D EVEN
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) THEN
C
C         FIND THE APPROPRIATE INDEX K FOR THIS NU
          K = KFIND(NU)
          INU(K,K4AD) = 1
C
C         INCREASE TOTAL NUMBER OF NU VALUES TO BE FACILITATED
          NULNG = NULNG+1
C
        ENDIF
C
      ENDDO
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(NULNG.EQ.0) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     WIGNER-ECKART: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|        C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           LOOP OVER THE TENSOR ORDERS ACTUALLY NEEDED FOR KQN BLOCK
            IF(INU(LTEN,K4AD).NE.0) THEN
C
C             READ THE ACTUAL ORDER NU
              NU = NUS(LTEN)
C
C             GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
              DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
              DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(1), MJA,JQN(2),-MJB,NU)
              DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2), MJB,NU)
              DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(1), MJA,JQN(2), MJB,NU)
C
            ENDIF
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J',M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           LOOP OVER THE TENSOR ORDERS ACTUALLY NEEDED FOR KQN BLOCK
            IF(INU(LTEN,K4AD).NE.0) THEN
C
C             READ THE ACTUAL ORDER NU
              NU = NUS(LTEN)
C
C             GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
              DKCD(LTEN,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
              DKCD(LTEN,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3), MJC,NU)
              DKCD(LTEN,MJC  ,MJD+1) = DK(JQN(4), MJD,JQN(3),-MJC,NU)
              DKCD(LTEN,MJC+1,MJD+1) = DK(JQN(4), MJD,JQN(3), MJC,NU)
C
            ENDIF
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BREIT1(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 11              C
C             BB    BB RR    RR EE        II     TT   111              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEE    II     TT    11              C
C             BB    BB RRRRRRR  EE        II     TT    11              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEEEE IIII    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT1 CONSTRUCTS A ONE-CENTRE CONTRIBUTION TO THE MOLECULAR        C
C  MEAN-FIELD BREIT MATRIX WITH RACAH ALGEBRA AND BETA INTEGRALS.      C
C  THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD   C
C  ATOMIC BREIT MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.      C
C -------------------------------------------------------------------- C
C  NOTE: THE INDEX PERMUTATION FEATURES SHOULD BE ENABLED AT YOUR OWN  C
C        PERIL! THEY DON'T YET ACCOUNT FOR THE FULL INTERACTION.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ANGFAC(8)
      DIMENSION BCOF(MNU,8,MKP+1,MKP+1,MKP+1,MKP+1)
      DIMENSION RJLSLS(MB2,MNU,2),RJSLSL(MB2,MNU,2),
     &          RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2)
      DIMENSION XLSLS(MB2),XSLSL(MB2),XLSSL(MB2),XSLLS(MB2)
C
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MT1A/PAB,PCD,MMA,MMB,MMC,MMD,
     &            NAL,NBL,NCL,NDL,NAS,NBS,NCS,NDS,
     &            KAL,KBL,KCL,KDL,KAS,KBS,KCS,KDS
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/T2EL/F2ES(5,9),T2ES(5,9),N2EB(5,9),N2EI(5,9),N2ES(5,9)
      COMMON/TSCF/TC1A,TC1I,TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,
     &            TCC2,TCAX,TCMC,TB1A,TB1I,TB1B,TB1R,TB1F,TB1M,TB1T,
     &            TBEC,TBRM,TBRW,TBC1,TBC2,TBAX,TBMC,TSMX,TUMX,THMX,
     &            TAMX,TC1T,TC2T,TCVT,TB2T,TACC,TEIG,TSCR,TTOT,TC2S,
     &            TB2S
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     ANGULAR FACTOR SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
      CALL SYSTEM_CLOCK(IBCH1,RATE)
C
C     INTEGRAL PERMUTATIONS: FEEL FREE TO PLAY WITH THESE BOOLEANS
      PRM1IJ = .TRUE.
      PRM1KL = .TRUE.
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
CC     MANUAL OVERRIDE FOR GENERAL MOLECULES (MIGHT WORK; NEEDS TESTING)
C      IF(ISYM.EQ.0) THEN
C        PRM1IJ = .FALSE.
C        PRM1KL = .FALSE.
C      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL LQN ORBITAL TYPES (USE INDEX 1000)                 C
C**********************************************************************C
C
C     LOOP OVER LQN(A) VALUES
      DO 1001 LA=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK A
        LQN(1) = LA
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),IZ)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),IZ)
        ENDDO
C
C     LOOP OVER LQN(B) VALUES
      DO 1002 LB=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK B
        LQN(2) = LB
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),IZ)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),IZ)
        ENDDO
C
C       NUMBER OF BASIS FUNCTIONS IN (AB) BLOCK
        MAXAB = NBAS(1)*NBAS(2)
C
C       TRIANGLE RULE FOR LA <-> LB
        IF(PRM1IJ) THEN
          IF(LA.GT.LB) GOTO 1100
        ENDIF
C
C     LOOP OVER LQN(C) VALUES
      DO 1101 LC=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK C
        LQN(3) = LC
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),IZ)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),IZ)
        ENDDO
C
C     LOOP OVER LQN(D) VALUES
      DO 1102 LD=0,(NKAP(IZ)-1)/2
C
C       QUANTUM NUMBERS FOR BLOCK D
        LQN(4) = LD
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),IZ)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),IZ)
        ENDDO
C
C       NUMBER OF BASIS FUNCTIONS IN (CD) BLOCK
        MAXCD = NBAS(3)*NBAS(4)
C
C       TRIANGLE RULE FOR LC <-> LD
        IF(PRM1KL) THEN
          IF(LC.GT.LD) GOTO 1200
        ENDIF
C
C       DETERMINE THE TENSOR ORDERS REQUIRED FOR THIS LQN BLOCK
        CALL SYSTEM_CLOCK(ICL1)
        CALL TNSBRT1(LQN,ISEL)
        CALL SYSTEM_CLOCK(ICL2)
        TB1A = TB1A + DFLOAT(ICL2-ICL1)/RATE
C
        IF(ISEL.EQ.0) GOTO 1200
C
C       BASIS SET INTERMEDIATES FOR THE DENSITY PAIRS
        CALL SYSTEM_CLOCK(ICL1)
        CALL IJSET1
        CALL KLSET1
        CALL SYSTEM_CLOCK(ICL2)
        TB1I = TB1I + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES FOR THESE LQNS (USE INDEX 2000) C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 NA=1,KRONECK(LA,0),-1
        KA = 2*LA+NA
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,IZ)
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 NB=1,KRONECK(LB,0),-1
        KB = 2*LB+NB
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,IZ)
C
C       TRIANGLE RULE FOR KA <-> KB
        IF(PRM1IJ) THEN
          IF(KA.GT.KB) GOTO 2100
        ENDIF
C
C     LOOP OVER KQN(C) VALUES
      DO 2101 NC=1,KRONECK(LC,0),-1
        KC = 2*LC+NC
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,IZ)
C
C     LOOP OVER KQN(D) VALUES
      DO 2102 ND=1,KRONECK(LD,0),-1
        KD = 2*LD+ND
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,IZ)
C
C       TRIANGLE RULE FOR KC <-> KD
        IF(PRM1KL) THEN
          IF(KC.GT.KD) GOTO 2200
        ENDIF
C
C     UNIQUE ADDRESS FOR THIS KQN COMBINATION WITHIN THE LQN BLOCK
      K4AD = 16 - (8*NA + 4*NB + 2*NC + ND)
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RKBRT1                      C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      CALL SYSTEM_CLOCK(ICL1)
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
      CALL SYSTEM_CLOCK(ICL2)
      TB1I = TB1I + DFLOAT(ICL2-ICL1)/RATE
C
C     ANGULAR COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL1)
      CALL ANGBRT1(BCOF,KQN,LQN,ISEL)
      CALL SYSTEM_CLOCK(ICL2)
      TB1A = TB1A + DFLOAT(ICL2-ICL1)/RATE
C
C     EXIT THIS COMBINATION IF IT VIOLATES A SELECTION RULE
      IF(ISEL.EQ.0) GOTO 2200
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 3000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(1,5) = N2EB(1,5)+1
C
      IJ = 0
      DO 3001 IBAS=1,NBAS(1)
      DO 3002 JBAS=1,NBAS(2)
        IJ = IJ+1
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        N2EI(1,5) = N2EI(1,5) + MAXCD
C
C       NEW SET OF BETA INTEGRALS FOR THIS LQN BLOCK
        CALL SYSTEM_CLOCK(ICL1)
        IF(K4AD.EQ.1) THEN
          CALL BTABRT1
C         CALL BETASET((NUF-NUI)/2+2,NUI  ,NUF+1)
        ENDIF
        CALL SYSTEM_CLOCK(ICL2)
        TB1B = TB1B + DFLOAT(ICL2-ICL1)/RATE
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL SYSTEM_CLOCK(ICL1)
        CALL RKBRT1(RJLSLS,RJSLSL,RJLSSL,RJSLLS)
        CALL SYSTEM_CLOCK(ICL2)
        TB1R = TB1R + DFLOAT(ICL2-ICL1)/RATE
C
C       CAN NOW CONTRACT THESE RADIAL INTEGRALS OVER ANGULAR COMPONENTS
C       OF G-SPINOR BASIS FUNCTIONS USING A TENSOR EXPANSION IN {L,Q}
C
C**********************************************************************C
C     LOOP OVER |KQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 4000)   C
C**********************************************************************C
C
      DO 4001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 4002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
CC
CC       TRIANGLE RULE FOR MA <-> MB
C        IF(PRM1IJ) THEN
C          IF(KA.EQ.KB.AND.MA.GT.MB) GOTO 4100
C        ENDIF
C
      DO 4101 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 4102 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
CC
CC       TRIANGLE RULE FOR MC <-> MD
C        IF(PRM1KL) THEN
C          IF(KC.EQ.KD.AND.MC.GT.MD) GOTO 4200
C        ENDIF
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        ISELM = 0
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4).AND.NOPN.NE.0) ISELM=1
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) ISELM = 1
        IF(ISELM.EQ.0) GOTO 4200
      ENDIF
C
C**********************************************************************C
C     LOOP OVER THE SIGNS OF |MQN| FOR A,B,C,D BLOCKS (USE INDEX 5000) C
C**********************************************************************C
C
      DO 5001 MMA=1,2
        MMJA = MQN(1)*((-1)**MMA)
        IMJA = MQN(1)+MMA-1
C
      DO 5002 MMB=1,2
        MMJB = MQN(2)*((-1)**MMB)
        IMJB = MQN(2)+MMB-1
C
C       TRIANGLE RULE FOR |MA| <-> |MB|
c        IF(PRM1IJ) THEN
c          IF(KA.EQ.KB.AND.MA.EQ.MB.AND.MMA.GT.MMB) GOTO 5100
c        ENDIF
C
      DO 5101 MMC=1,2
        MMJC = MQN(3)*((-1)**MMC)
        IMJC = MQN(3)+MMC-1
C
      DO 5102 MMD=1,2
        MMJD = MQN(4)*((-1)**MMD)
        IMJD = MQN(4)+MMD-1
C
C       TRIANGLE RULE FOR |MC| <-> |MD|
c        IF(PRM1KL) THEN
c          IF(KC.EQ.KD.AND.MC.EQ.MD.AND.MMC.GT.MMD) GOTO 5200
c        ENDIF
C
C     APPLY MORE MQN SELECTION RULES
      IF(ISYM.EQ.1.OR.ISYM.EQ.2) THEN
        ISELM = 0
        IF(MMJA-MMJB.EQ.MMJD-MMJC) then
          ISELM = 1
        ENDIF
        IF(ISELM.EQ.0) GOTO 5200
      ENDIF
C
C     PHASE FACTORS FOR PERMUTATION SWAPS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((MMJA-MMJB)/2))
      PCD =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((MMJC-MMJD)/2))
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LRGE(IZ,KA,2*MA-2+MMA)
      NBL = LRGE(IZ,KB,2*MB-2+MMB)
      NCL = LRGE(IZ,KC,2*MC-2+MMC)
      NDL = LRGE(IZ,KD,2*MD-2+MMD)
C
      NAS = NAL+NSKP
      NBS = NBL+NSKP
      NCS = NCL+NSKP
      NDS = NDL+NSKP
C
C     STARTING FOCK ADDRESS FOR KRAMERS COMPLEMENTS
      KAL = LRGE(IZ,KA,2*MA+1-MMA)
      KBL = LRGE(IZ,KB,2*MB+1-MMB)
      KCL = LRGE(IZ,KC,2*MC+1-MMC)
      KDL = LRGE(IZ,KD,2*MD+1-MMD)
C
      KAS = KAL+NSKP
      KBS = KBL+NSKP
      KCS = KCL+NSKP
      KDS = KDL+NSKP
C
C     RESET CONTRACTED RADIAL ARRAYS
      CALL SYSTEM_CLOCK(ICL1)
      DO M=1,MAXCD
        XLSLS(M) = 0.0D0
        XSLSL(M) = 0.0D0
        XLSSL(M) = 0.0D0
        XSLLS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       SKIP IF THIS LQN BLOCK TENSOR ORDER ISN'T IN THE KQN BLOCK
        IF(INU(LTEN,K4AD).EQ.0) GOTO 5201
C
C       ANGULAR COEFFICIENTS
        DO IMU=1,8
          ANGFAC(IMU) = BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
        ENDDO
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        ANGSUM = 0.0D0
        DO IMU=1,8
          ANGSUM = ANGSUM + DABS(ANGFAC(IMU))
        ENDDO
        IF(DABS(ANGSUM).LE.SENS) GOTO 5201
C
C       PRODUCT OF ANGULAR AND RADIAL INTEGRAL
        DO M=1,MAXCD
          XLSLS(M) = XLSLS(M) + ANGFAC(1)*RJLSLS(M,LTEN,1)
     &                        + ANGFAC(2)*RJLSLS(M,LTEN,2)
          XSLSL(M) = XSLSL(M) + ANGFAC(3)*RJSLSL(M,LTEN,1)
     &                        + ANGFAC(4)*RJSLSL(M,LTEN,2)
          XLSSL(M) = XLSSL(M) + ANGFAC(5)*RJLSSL(M,LTEN,1)
     &                        + ANGFAC(6)*RJLSSL(M,LTEN,2)
          XSLLS(M) = XSLLS(M) + ANGFAC(7)*RJSLLS(M,LTEN,1)
     &                        + ANGFAC(8)*RJSLLS(M,LTEN,2)
        ENDDO
C
C       SKIP POINT FOR ANGULAR SCREENING
5201    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL SYSTEM_CLOCK(ICL2)
      TB1F = TB1F + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL BREIT MATRIX       C
C -------------------------------------------------------------------- C
C          (NO BDIR CONTRIBUTIONS FOR CLOSED-SHELL SYSTEMS.)           C
C**********************************************************************C
C
      CALL SYSTEM_CLOCK(ICL1)
C
C     MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
      IF(ISYM.EQ.0) THEN
        CALL BRTMT1G(XLSLS,XSLSL,XLSSL,XSLLS)
      ELSE
        CALL BRTMT1Z(XLSLS,XSLSL,XLSSL,XSLLS)
      ENDIF
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL SYSTEM_CLOCK(ICL2)
      TB1M = TB1M + DFLOAT(ICL2-ICL1)/RATE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTRE CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
5200  CONTINUE
C     END LOOP OVER ALL |MQN|(CD) SIGNS
5102  CONTINUE
5101  CONTINUE
C     EARLY EXIT FOR MQN TRIANGLE RULES
5100  CONTINUE
C     END LOOP OVER ALL |MQN|(AB) SIGNS
5002  CONTINUE
5001  CONTINUE
C     EARLY EXIT FOR MQN TRIANGLE RULE
4200  CONTINUE
C     END LOOP OVER |MQN|(CD) MAGNITUDES
4102  CONTINUE
4101  CONTINUE
C     EARLY EXIT FOR MQN TRIANGLE RULE
4100  CONTINUE
C     END LOOP OVER |MQN|(AB) MAGNITUDES
4002  CONTINUE
4001  CONTINUE
C     END LOOP OVER IBAS AND JBAS
3002  CONTINUE
3001  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES/TRIANGLE RULE
2200  CONTINUE
C     END LOOP OVER KQN(CD)
2102  CONTINUE
2101  CONTINUE
C     EARLY EXIT FOR KQN TRIANGLE RULE
2100  CONTINUE
C     END LOOP OVER KQN(AB)
2002  CONTINUE
2001  CONTINUE
C     EARLY EXIT FOR LQN SELECTION RULES/TRIANGLE RULE
1200  CONTINUE
C     END LOOP OVER LQN(CD)
1102  CONTINUE
1101  CONTINUE
C     EARLY EXIT FOR LQN TRIANGLE RULE
1100  CONTINUE
C     END LOOP OVER LQN(AB)
1002  CONTINUE
1001  CONTINUE
C
C     MATRIX HERMITICITY (CLOSED-SHELL)
      CALL SYSTEM_CLOCK(ICL1)
      DO I=1,NDIM
        DO J=I+1,NDIM
          BXCH(J,I) = DCONJG(BXCH(I,J))
        ENDDO
      ENDDO
C
C     MATRIX HERMITICITY (OPEN-SHELL)
      IF(NOPN.NE.0) THEN
        DO I=1,NDIM
          DO J=I+1,NDIM
            BDIR(J,I) = DCONJG(BDIR(I,J))
            WDIR(J,I) = DCONJG(WDIR(I,J))
            WXCH(J,I) = DCONJG(WXCH(I,J))
          ENDDO
        ENDDO
      ENDIF
      CALL SYSTEM_CLOCK(ICL2)
      TB1M = TB1M + DFLOAT(ICL2-ICL1)/RATE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL SYSTEM_CLOCK(IBCH2)
      IF(INTSYM) THEN
        T2ES(1,5) = T2ES(1,5) + DFLOAT(IBCH2-IBCH1)/RATE
      ELSE
        T2ES(1,5) = T2ES(1,5) + 0.25D0*DFLOAT(IBCH2-IBCH1)/RATE
        T2ES(1,6) = T2ES(1,6) + 0.25D0*DFLOAT(IBCH2-IBCH1)/RATE
        T2ES(1,7) = T2ES(1,7) + 0.25D0*DFLOAT(IBCH2-IBCH1)/RATE
        T2ES(1,8) = T2ES(1,8) + 0.25D0*DFLOAT(IBCH2-IBCH1)/RATE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BRTMT1Z(XLSLS,XSLSL,XLSSL,XSLLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  RRRRRRR TTTTTTTT MM       MM TTTTTTTT 11  ZZZZZZZZ      C
C     BB    BB RR    RR   TT    MMM     MMM    TT   111       ZZ       C
C     BB    BB RR    RR   TT    MMMM   MMMM    TT    11      ZZ        C
C     BBBBBBB  RR    RR   TT    MM MM MM MM    TT    11     ZZ         C
C     BB    BB RRRRRRR    TT    MM  MMM  MM    TT    11    ZZ          C
C     BB    BB RR    RR   TT    MM   M   MM    TT    11   ZZ           C
C     BBBBBBB  RR    RR   TT    MM       MM    TT   1111 ZZZZZZZZ      C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMT1Z ASSEMBLES CONTRIBUTIONS TO THE MOLECULAR COULOMB MATRIX     C
C  WHICH ARISE FROM A SINGLE NUCLEAR CENTRE IN A GENERAL MOLECULE.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION XLSLS(MB2),XSLSL(MB2),XLSSL(MB2),XSLLS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MT1A/PAB,PCD,MMA,MMB,MMC,MMD,
     &            NAL,NBL,NCL,NDL,NAS,NBS,NCS,NDS,
     &            KAL,KBL,KCL,KDL,KAS,KBS,KCS,KDS
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.EQ.0) THEN
        WRITE(6,*) 'In BRTMT1Z: you probably should be using BRTMT1G.'
        WRITE(7,*) 'In BRTMT1Z: you probably should be using BRTMT1G.'
      ENDIF
C
C     VALUES WHICH REFLECT SIGN AND MAGNITUDE OF MQN
      MMJA = MQN(1)*((-1)**MMA)
      MMJB = MQN(2)*((-1)**MMB)
      MMJC = MQN(3)*((-1)**MMC)
      MMJD = MQN(4)*((-1)**MMD)
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C     BXCH: NO PERMUTATION SYMMETRY EMPLOYED                           C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C     CLOSED-SHELL EXCHANGE MATRIX BXCH
      IF(MMJA-MMJD.NE.MMJB-MMJC) GOTO 202
      IF(MMA.NE.MMD.OR.MMC.NE.MMB) GOTO 202
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LL)  --  (AD|CB)
      IF(NAL.LE.NDL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAL+IBAS,NDL+LBAS) = BXCH(NAL+IBAS,NDL+LBAS)
     &                +         XLSSL(M)*DREAL(DENT(NCS+KBAS,NBS+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LS)  --  (AD|CB)
      IF(NAL.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAL+IBAS,NDS+LBAS) = BXCH(NAL+IBAS,NDS+LBAS)
     &                +         XLSLS(M)*DREAL(DENT(NCL+KBAS,NBS+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
CC     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SL)  --  (AD|CB)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          BXCH(NAS+IBAS,NDL+LBAS) = BXCH(NAS+IBAS,NDL+LBAS)
C     &               +         XSLSL(M)*DREAL(DENT(NCS+KBAS,NBL+JBAS))
C        ENDDO
C      ENDDO
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SS)  --  (AD|CB)
      IF(NAS.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAS+IBAS,NDS+LBAS) = BXCH(NAS+IBAS,NDS+LBAS)
     &                +         XSLLS(M)*DREAL(DENT(NCL+KBAS,NBL+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
202   CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C     BXCH: PERMUTATION SYMMETRY I⇄J         ONLY                      C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C     MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
      IF(.NOT.PRM1IJ) GOTO 203
C
C     SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
      IF(KQN(1).EQ.KQN(2)) GOTO 203
C
C     MQN SIGN SELECTION RULE
      IF(-MMJB-MMJD.NE.-MMJA-MMJC) GOTO 203
      IF(MMB.EQ.MMD.OR.MMC.EQ.MMA) GOTO 203
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LL)  --  (AD|CB)
      IF(KBL.LE.NDL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(KBL+JBAS,NDL+LBAS) = BXCH(KBL+JBAS,NDL+LBAS)
     &                + PAB*    XSLSL(M)*DREAL(DENT(NCS+KBAS,KAS+IBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LS)  --  (AD|CB)
      IF(KBL.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(KBL+JBAS,NDS+LBAS) = BXCH(KBL+JBAS,NDS+LBAS)
     &                + PAB*    XSLLS(M)*DREAL(DENT(NCL+KBAS,KAS+IBAS))
          ENDDO
        ENDDO
      ENDIF
C
CC     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SL)  --  (AD|CB)
C      IF(KBS.LT.NDL) THEN
C        M = 0
C        DO KBAS=1,NBAS(3)
C          DO LBAS=1,NBAS(4)
C            M = M+1
C            BXCH(KBS+JBAS,NDL+LBAS) = BXCH(KBS+JBAS,NDL+LBAS)
C     &                   +      XLSSL(M)*DREAL(DENT(NCL+KBAS,KAS+IBAS))
C          ENDDO
C        ENDDO
C      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SS)  --  (AD|CB)
      IF(KBS.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(KBS+JBAS,NDS+LBAS) = BXCH(KBS+JBAS,NDS+LBAS)
     &                + PAB*    XLSLS(M)*DREAL(DENT(NCL+KBAS,KAL+IBAS))
          ENDDO
        ENDDO
      ENDIF
C
203   CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C     BXCH: PERMUTATION SYMMETRY         K⇄L ONLY                      C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C     MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
      IF(.NOT.PRM1KL) GOTO 204
C
C     SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
      IF(KQN(3).EQ.KQN(4)) GOTO 204
C
C     MQN SIGN SELECTION RULE
      IF(MMJA+MMJC.NE.MMJB+MMJD) GOTO 204
      IF(MMA.EQ.MMC.OR.MMD.EQ.MMB) GOTO 204
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LL)  --  (AC|DB)
      IF(NAL.LE.KCL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAL+IBAS,KCL+KBAS) = BXCH(NAL+IBAS,KCL+KBAS)
     &                +     PCD*XLSLS(M)*DREAL(DENT(KDS+LBAS,NBS+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LS)  --  (AC|DB)
      IF(NAL.LE.KCS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAL+IBAS,KCS+KBAS) = BXCH(NAL+IBAS,KCS+KBAS)
     &                +     PCD*XLSSL(M)*DREAL(DENT(KDL+LBAS,NBS+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
CC     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SL)  --  (AC|DB)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          BXCH(NAS+IBAS,KCL+KBAS) = BXCH(NAS+IBAS,KCL+KBAS)
C     &                +     PCD*XSLLS(M)*DREAL(DENT(KDS+LBAS,NBL+JBAS))
C        ENDDO
C      ENDDO
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SS)  --  (AC|DB)
      IF(NAS.LE.KCS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAS+IBAS,KCS+KBAS) = BXCH(NAS+IBAS,KCS+KBAS)
     &                +     PCD*XSLSL(M)*DREAL(DENT(KDL+LBAS,NBL+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
204   CONTINUE
C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C     BXCH: PERMUTATION SYMMETRY I⇄J AND K⇄L                         C
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
C
C     MATRIX CONTRIBUTIONS BY PERMUTATION OF INDICES
      IF(.NOT.PRM1IJ) GOTO 205
      IF(.NOT.PRM1KL) GOTO 205
C
C     SCREEN NON-RECYCLABLE BLOCKS FROM THE LOWER TRIANGLE
      IF(KQN(1).EQ.KQN(2)) GOTO 205
      IF(KQN(3).EQ.KQN(4)) GOTO 205
C
C     MQN SIGN SELECTION RULE
      IF(-MMJB+MMJC.NE.-MMJA+MMJD) GOTO 205
      IF(MMB.NE.MMC.OR.MMD.NE.MMA) GOTO 205
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LL)  --  (BC|DA)
      IF(KBL.LE.KCL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(KBL+JBAS,KCL+KBAS) = BXCH(KBL+JBAS,KCL+KBAS)
     &                + PAB*PCD*XSLLS(M)*DREAL(DENT(KDL+LBAS,KAL+IBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LS)  --  (BC|DA)
      IF(KBL.LE.KCS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(KBL+JBAS,KCS+KBAS) = BXCH(KBL+JBAS,KCS+KBAS)
     &                + PAB*PCD*XSLSL(M)*DREAL(DENT(KDS+LBAS,KAL+IBAS))
          ENDDO
        ENDDO
      ENDIF
C
CC     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SL)  --  (BC|DA)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          BXCH(KBS+JBAS,KCL+KBAS) = BXCH(KBS+JBAS,KCL+KBAS)
C     &                 + PAB*PCD*XLSLS(M)*DREAL(DENT(KDL+LBAS,KAS+IBAS))
C        ENDDO
C      ENDDO
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SS)  --  (BC|DA)
      IF(KBS.LE.KCS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(KBS+JBAS,KCS+KBAS) = BXCH(KBS+JBAS,KCS+KBAS)
     &                + PAB*PCD*XLSSL(M)*DREAL(DENT(KDS+LBAS,KAS+IBAS))
          ENDDO
        ENDDO
      ENDIF
C
205   CONTINUE
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL BREIT MATRIX.        C
C     THIS ALSO REQUIRES THE CLOSED-SHELL DIRECT MATRIX ELEMENTS.      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 6100
C
C     CLOSED-SHELL DIRECT MATRIX BDIR
      IF(MMA.NE.MMB.OR.MMC.NE.MMD) GOTO 6002
C
C     CLOSED-SHELL DIRECT MATRIX BLOCK BDIR(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          BDIR(NAL+IBAS,NBS+JBAS) = BDIR(NAL+IBAS,NBS+JBAS)
     &                   +      XLSLS(M)*DREAL(DENT(NCL+KBAS,NDS+LBAS))
     &                   +      XLSSL(M)*DREAL(DENT(NCS+KBAS,NDL+LBAS))
C
        ENDDO
      ENDDO
CC
CC     CLOSED-SHELL DIRECT MATRIX BLOCK BDIR(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          BDIR(NAS+IBAS,NBL+JBAS) = BDIR(NAS+IBAS,NBL+JBAS)
C     &                  +      XSLSL(M)*DREAL(DENT(NCS+KBAS,NDL+LBAS))
C     &                  +      XSLLS(M)*DREAL(DENT(NCL+KBAS,NDS+LBAS))
C        ENDDO
C      ENDDO
C
C     OPEN-SHELL DIRECT MATRIX WDIR
C
C     OPEN-SHELL DIRECT MATRIX BLOCK WDIR(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          WDIR(NAL+IBAS,NBS+JBAS) = WDIR(NAL+IBAS,NBS+JBAS)
     &                   + ACFF*XLSLS(M)*DREAL(DENO(NCL+KBAS,NDS+LBAS))
     &                   + ACFF*XLSSL(M)*DREAL(DENO(NCS+KBAS,NDL+LBAS))
        ENDDO
      ENDDO
CC
CC     OPEN-SHELL DIRECT MATRIX BLOCK WDIR(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          WDIR(NAS+IBAS,NBL+JBAS) = WDIR(NAS+IBAS,NBL+JBAS)
C     &                  + ACFF*XSLSL(M)*DREAL(DENO(NCS+KBAS,NDL+LBAS))
C     &                  + ACFF*XSLLS(M)*DREAL(DENO(NCL+KBAS,NDS+LBAS))
C        ENDDO
C      ENDDO
C
6002  CONTINUE
C
C     OPEN-SHELL DIRECT MATRIX WXCH
      IF(MMA.NE.MMD.OR.MMC.NE.MMB) GOTO 6003
C
C     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(LL)
      IF(NAL.LE.NDL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            WXCH(NAL+IBAS,NDL+LBAS) = WXCH(NAL+IBAS,NDL+LBAS)
     &                   + BCFF*XLSSL(M)*DREAL(DENO(NBS+JBAS,NCS+KBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          WXCH(NAL+IBAS,NDS+LBAS) = WXCH(NAL+IBAS,NDS+LBAS)
     &                   + BCFF*XLSLS(M)*DREAL(DENO(NBS+JBAS,NCL+KBAS))
        ENDDO
      ENDDO
CC
CC     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          WXCH(NAS+IBAS,NDL+LBAS) = WXCH(NAS+IBAS,NDL+LBAS)
C     &                  + BCFF*XSLSL(M)*DREAL(DENO(NBL+JBAS,NCS+KBAS))
C        ENDDO
C      ENDDO
C
C     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(SS)
      IF(NAS.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            WXCH(NAS+IBAS,NDS+LBAS) = WXCH(NAS+IBAS,NDS+LBAS)
     &                   + BCFF*XSLLS(M)*DREAL(DENO(NBL+JBAS,NCL+KBAS))
          ENDDO
        ENDDO
      ENDIF
6003  CONTINUE
C
6100  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BRTMT1G(XLSLS,XSLSL,XLSSL,XSLLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  RRRRRRR TTTTTTTT MM       MM TTTTTTTT 11   GGGGGG       C
C     BB    BB RR    RR   TT    MMM     MMM    TT   111  GG    GG      C
C     BB    BB RR    RR   TT    MMMM   MMMM    TT    11  GG            C
C     BBBBBBB  RR    RR   TT    MM MM MM MM    TT    11  GG            C
C     BB    BB RRRRRRR    TT    MM  MMM  MM    TT    11  GG   GGG      C
C     BB    BB RR    RR   TT    MM   M   MM    TT    11  GG    GG      C
C     BBBBBBB  RR    RR   TT    MM       MM    TT   1111  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMT1G ASSEMBLES CONTRIBUTIONS TO THE MOLECULAR COULOMB MATRIX     C
C  WHICH ARISE FROM A SINGLE NUCLEAR CENTRE IN A GENERAL MOLECULE.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION XLSLS(MB2),XSLSL(MB2),XLSSL(MB2),XSLLS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MT1A/PAB,PCD,MMA,MMB,MMC,MMD,
     &            NAL,NBL,NCL,NDL,NAS,NBS,NCS,NDS,
     &            KAL,KBL,KCL,KDL,KAS,KBS,KCS,KDS
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     PRINT A WARNING IF THE MOLECULE SYMMETRY TYPE IS INCOMPATIBLE
      IF(ISYM.NE.0) THEN
        WRITE(6,*) 'In BRTMT1G: you probably should be using BRTMT1Z.'
        WRITE(7,*) 'In BRTMT1G: you probably should be using BRTMT1Z.'
      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LL)
      IF(NAL.LE.NDL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAL+IBAS,NDL+LBAS) = BXCH(NAL+IBAS,NDL+LBAS)
     &                  +      XLSSL(M)*DCONJG(DENT(NBS+JBAS,NCS+KBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          BXCH(NAL+IBAS,NDS+LBAS) = BXCH(NAL+IBAS,NDS+LBAS)
     &                  +      XLSLS(M)*DCONJG(DENT(NBS+JBAS,NCL+KBAS))
        ENDDO
      ENDDO
C
CC     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          BXCH(NAS+IBAS,NDL+LBAS) = BXCH(NAS+IBAS,NDL+LBAS)
C     &                  +      XSLSL(M)*DCONJG(DENT(NBL+JBAS,NCS+KBAS))
C        ENDDO
C      ENDDO
C
C     CLOSED-SHELL EXCHANGE MATRIX BLOCK BXCH(SS)
      IF(NAS.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            BXCH(NAS+IBAS,NDS+LBAS) = BXCH(NAS+IBAS,NDS+LBAS)
     &                  +      XSLLS(M)*DCONJG(DENT(NBL+JBAS,NCL+KBAS))
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL BREIT MATRIX.        C
C     THIS ALSO REQUIRES THE CLOSED-SHELL DIRECT MATRIX ELEMENTS.      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 6100
C
C     CLOSED-SHELL DIRECT MATRIX BDIR
C
C     CLOSED-SHELL DIRECT MATRIX BLOCK BDIR(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          BDIR(NAL+IBAS,NBS+JBAS) = BDIR(NAL+IBAS,NBS+JBAS)
     &                  +      XLSLS(M)*DCONJG(DENT(NCL+KBAS,NDS+LBAS))
     &                  +      XLSSL(M)*DCONJG(DENT(NCS+KBAS,NDL+LBAS))
C
        ENDDO
      ENDDO
CC
CC     CLOSED-SHELL DIRECT MATRIX BLOCK BDIR(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          BDIR(NAS+IBAS,NBL+JBAS) = BDIR(NAS+IBAS,NBL+JBAS)
C     &                  +      XSLSL(M)*DCONJG(DENT(NCS+KBAS,NDL+LBAS))
C     &                  +      XSLLS(M)*DCONJG(DENT(NCL+KBAS,NDS+LBAS))
C        ENDDO
C      ENDDO
C
C     OPEN-SHELL DIRECT MATRIX WDIR
C
C     OPEN-SHELL DIRECT MATRIX BLOCK WDIR(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          WDIR(NAL+IBAS,NBS+JBAS) = WDIR(NAL+IBAS,NBS+JBAS)
     &                  + ACFF*XLSLS(M)*DCONJG(DENO(NCL+KBAS,NDS+LBAS))
     &                  + ACFF*XLSSL(M)*DCONJG(DENO(NCS+KBAS,NDL+LBAS))
        ENDDO
      ENDDO
CC
CC     OPEN-SHELL DIRECT MATRIX BLOCK WDIR(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          WDIR(NAS+IBAS,NBL+JBAS) = WDIR(NAS+IBAS,NBL+JBAS)
C     &                  + ACFF*XSLSL(M)*DCONJG(DENO(NCS+KBAS,NDL+LBAS))
C     &                  + ACFF*XSLLS(M)*DCONJG(DENO(NCL+KBAS,NDS+LBAS))
C        ENDDO
C      ENDDO
C
C     OPEN-SHELL DIRECT MATRIX WXCH
C
C     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(LL)
      IF(NAL.LE.NDL) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            WXCH(NAL+IBAS,NDL+LBAS) = WXCH(NAL+IBAS,NDL+LBAS)
     &                  + BCFF*XLSSL(M)*DCONJG(DENO(NBS+JBAS,NCS+KBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(LS)
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          WXCH(NAL+IBAS,NDS+LBAS) = WXCH(NAL+IBAS,NDS+LBAS)
     &                  + BCFF*XLSLS(M)*DCONJG(DENO(NBS+JBAS,NCL+KBAS))
        ENDDO
      ENDDO
CC
CC     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(SL)
C      M = 0
C      DO KBAS=1,NBAS(3)
C        DO LBAS=1,NBAS(4)
C          M = M+1
C          WXCH(NAS+IBAS,NDL+LBAS) = WXCH(NAS+IBAS,NDL+LBAS)
C     &                  + BCFF*XSLSL(M)*DCONJG(DENO(NBL+JBAS,NCS+KBAS))
C        ENDDO
C      ENDDO
C
C     OPEN-SHELL EXCHANGE MATRIX BLOCK WXCH(SS)
      IF(NAS.LE.NDS) THEN
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            WXCH(NAS+IBAS,NDS+LBAS) = WXCH(NAS+IBAS,NDS+LBAS)
     &                  + BCFF*XSLLS(M)*DCONJG(DENO(NBL+JBAS,NCL+KBAS))
          ENDDO
        ENDDO
      ENDIF
C
6100  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BTABRT1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        BBBBBBB TTTTTTTT   AA    BBBBBBB  RRRRRRR TTTTTTTT 11         C
C        BB    BB   TT     AAAA   BB    BB RR    RR   TT   111         C
C        BB    BB   TT    AA  AA  BB    BB RR    RR   TT    11         C
C        BBBBBBB    TT   AA    AA BBBBBBB  RR    RR   TT    11         C
C        BB    BB   TT   AAAAAAAA BB    BB RRRRRRR    TT    11         C
C        BB    BB   TT   AA    AA BB    BB RR    RR   TT    11         C
C        BBBBBBB    TT   AA    AA BBBBBBB  RR    RR   TT   1111        C
C                                                                      C
C -------------------------------------------------------------------- C
C  BTABRT1 EVALUATES A BATCH OF BETA INTEGRALS REQUIRED FOR THE        C
C  ONE-CENTRE RADIAL INTEGRALS OVER THE BREIT INTERACTION.             C
C -------------------------------------------------------------------- C
C  INDEX 1 FOR UPPER INTEGRALS, INDEX 2 FOR LOWER INTEGRALS.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
C
      DIMENSION RJLSLS(MB2,MNU,2),RJSLSL(MB2,MNU,2),
     &          RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BETA/BDU(MB2*MB2,MNU,MNU),BDL(MB2*MB2,MNU,MNU)
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI(IJ)+EJ(IJ)
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXCD
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL BETA INTEGRALS
      NVALS = (NUF-NUI)/2+2
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+NUI+2*NX
        IAA(2) = LQN(3)+LQN(4)+NUI+2*NX
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)-NUF+2*NY-1
          IBB(2) = LQN(1)+LQN(2)-NUF+2*NY-1
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXCD
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXCD
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXCD
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXCD
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXCD
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXCD
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXCD
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
C           ASSEMBLE A LIST OF UPPER AND LOWER BETA INTEGRALS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXCD
                BDU((IJ-1)*MAXCD+M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXCD
                BDL((IJ-1)*MAXCD+M,NX,NY) = BETA(M)
              ENDDO
            ENDIF

          ENDDO

        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RKBRT1(RJLSLS,RJSLSL,RJLSSL,RJSLLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            RRRRRRR  KK    KK BBBBBBB  RRRRRRR TTTTTTTT 11            C
C            RR    RR KK   KK  BB    BB RR    RR   TT   111            C
C            RR    RR KK  KK   BB    BB RR    RR   TT    11            C
C            RR    RR KKKKK    BBBBBBB  RR    RR   TT    11            C
C            RRRRRRR  KK  KK   BB    BB RRRRRRR    TT    11            C
C            RR    RR KK   KK  BB    BB RR    RR   TT    11            C
C            RR    RR KK    KK BBBBBBB  RR    RR   TT   1111           C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKBRT1 EVALUATES A BATCH OF GENERAL (OPEN-SHELL) ONE-CENTRE RADIAL  C
C  INTEGRALS OVER THE BREIT INTERACTION, SEPARATING RESULTS BY THE     C
C  ALLOWED TENSOR ORDERS RK(ABCD).                                     C
C -------------------------------------------------------------------- C
C  RJLSLS(MB2,MNU,IUL) - JLSLS INTEGRAL LIST OF TENSOR TYPE MNU        C
C  RJSLSL(MB2,MNU,IUL) - JSLSL INTEGRAL LIST OF TENSOR TYPE MNU        C
C  RJLSSL(MB2,MNU,IUL) - JLSSL INTEGRAL LIST OF TENSOR TYPE MNU        C
C  RJSLLS(MB2,MNU,IUL) - JSLLS INTEGRAL LIST OF TENSOR TYPE MNU        C
C -------------------------------------------------------------------- C
C  INDEX 1 FOR UPPER INTEGRALS, INDEX 2 FOR LOWER INTEGRALS.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RJLSLS(MB2,MNU,2),RJSLSL(MB2,MNU,2),
     &          RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BETA/BDU(MB2*MB2,MNU,MNU),BDL(MB2*MB2,MNU,MNU)
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXCD
        DO LTEN=1,NUNUM
          DO IUL=1,2
            RJLSLS(M,LTEN,IUL) = 0.0D0
            RJSLSL(M,LTEN,IUL) = 0.0D0
            RJLSSL(M,LTEN,IUL) = 0.0D0
            RJSLLS(M,LTEN,IUL) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI(IJ)
      E0100 = EJ(IJ)
      E1100 = EI(IJ)*EJ(IJ)
C
C     LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXCD
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI(IJ)*EK(M)
        E1001 = EI(IJ)*EL(M)
        E0110 = EJ(IJ)*EK(M)
        E0101 = EJ(IJ)*EL(M)
        E0011 = EK(M)*EL(M)
C
C       UNIQUE FIXED ADDRESS FOR THE IBAS,JBAS COMBINATION
        MIJKL = (IJ-1)*MAXCD + M
C
C       LOOP OVER THE TENSOR ORDERS OF THE BREIT INTERACTION
        DO LTEN=1,NUNUM
C
C         SCREEN LQN BLOCK TENSOR ORDERS THAT ARE NOT IN THIS KQN BLOCK
          IF(INU(LTEN,K4AD).EQ.0) GOTO 50
C
C         BACKWARDS COUNT
          NTEN = NUNUM-LTEN
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RJ(LTEN,M)
          B21L = EIJ(IJ,-NU+1)*EKL(M, NU+2)*BDL(MIJKL,LTEN  ,NTEN+1)
          B21U = EIJ(IJ, NU+2)*EKL(M,-NU+1)*BDU(MIJKL,LTEN  ,NTEN+1)
          B23L = EIJ(IJ,-NU+3)*EKL(M, NU+2)*BDL(MIJKL,LTEN  ,NTEN+2)
          B41U = EIJ(IJ, NU+4)*EKL(M,-NU+1)*BDU(MIJKL,LTEN+1,NTEN+1)
          B41L = EIJ(IJ,-NU+1)*EKL(M, NU+4)*BDL(MIJKL,LTEN+1,NTEN+1)
          B23U = EIJ(IJ, NU+2)*EKL(M,-NU+3)*BDU(MIJKL,LTEN  ,NTEN+2)
          B43L = EIJ(IJ,-NU+3)*EKL(M, NU+4)*BDL(MIJKL,LTEN+1,NTEN+2)
          B43U = EIJ(IJ, NU+4)*EKL(M,-NU+3)*BDU(MIJKL,LTEN+1,NTEN+2)
C
C         EFFECTIVE INTERACTION STRENGTH RJLSLS(M,LTEN)
          RJLSLS(M,LTEN,1) 
     &         = V4*T0000*E0101*C7*B43U - V2*T0001*E0100*C5*B41U
     &         - V2*T0100*E0001*C5*B23U + V1*T0101*E0000*C3*B21U
C
          RJLSLS(M,LTEN,2) 
     &         = V4*T0000*E0101*C7*B43L - V2*T0001*E0100*C5*B23L
     &         - V2*T0100*E0001*C5*B41L + V1*T0101*E0000*C3*B21L
C
C         EFFECTIVE INTERACTION STRENGTH RJSLSL(M,LTEN)
          RJSLSL(M,LTEN,1)
     &         = V4*T0000*E1010*C7*B43U - V2*T0010*E1000*C5*B41U
     &         - V2*T1000*E0010*C5*B23U + V1*T1010*E0000*C3*B21U
C
          RJSLSL(M,LTEN,2)
     &         = V4*T0000*E1010*C7*B43L - V2*T0010*E1000*C5*B23L
     &         - V2*T1000*E0010*C5*B41L + V1*T1010*E0000*C3*B21L
C
C         EFFECTIVE INTERACTION STRENGTH RJLSSL(M,LTEN)
          RJLSSL(M,LTEN,1) 
     &         = V4*T0000*E0110*C7*B43U - V2*T0010*E0100*C5*B41U
     &         - V2*T0100*E0010*C5*B23U + V1*T0110*E0000*C3*B21U
C
          RJLSSL(M,LTEN,2)
     &         = V4*T0000*E0110*C7*B43L - V2*T0010*E0100*C5*B23L
     &         - V2*T0100*E0010*C5*B41L + V1*T0110*E0000*C3*B21L
C
C         EFFECTIVE INTERACTION STRENGTH RJSLLS(M,LTEN)
          RJSLLS(M,LTEN,1) 
     &         = V4*T0000*E1001*C7*B43U - V2*T0001*E1000*C5*B41U
     &         - V2*T1000*E0001*C5*B23U + V1*T1001*E0000*C3*B21U
C
          RJSLLS(M,LTEN,2) 
     &         = V4*T0000*E1001*C7*B43L - V2*T0001*E1000*C5*B23L
     &         - V2*T1000*E0001*C5*B41L + V1*T1001*E0000*C3*B21L
C
50        CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      DO M=1,MAXCD
        RNLSLS = RNIJ(IJ,2)*RNKL(M,2)
        RNSLSL = RNIJ(IJ,3)*RNKL(M,3)
        RNSLLS = RNIJ(IJ,3)*RNKL(M,2)
        RNLSSL = RNIJ(IJ,2)*RNKL(M,3)
        DO LTEN=1,NUNUM
          IF(INU(LTEN,K4AD).NE.0) THEN
            DO IUL=1,2
              RJLSLS(M,LTEN,IUL) = RNLSLS*RJLSLS(M,LTEN,IUL)
              RJSLSL(M,LTEN,IUL) = RNSLSL*RJSLSL(M,LTEN,IUL)
              RJLSSL(M,LTEN,IUL) = RNLSSL*RJLSSL(M,LTEN,IUL)
              RJSLLS(M,LTEN,IUL) = RNSLLS*RJSLLS(M,LTEN,IUL)
            ENDDO
          ENDIF
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE TNSBRT1(LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       TTTTTTTT NN    NN  SSSSSS  BBBBBBB  RRRRRRR TTTTTTTT 11        C
C          TT    NNN   NN SS    SS BB    BB RR    RR   TT   111        C
C          TT    NNNN  NN SS       BB    BB RR    RR   TT    11        C
C          TT    NN NN NN  SSSSSS  BBBBBBB  RR    RR   TT    11        C
C          TT    NN  NNNN       SS BB    BB RRRRRRR    TT    11        C
C          TT    NN   NNN SS    SS BB    BB RR    RR   TT    11        C
C          TT    NN    NN  SSSSSS  BBBBBBB  RR    RR   TT   1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  TNSBRT1 PERFORMS THE TENSOR EXPANSION ANALYSIS FOR THE ONE-CENTRE   C
C  BREIT INTERACTION, FOR A GIVEN LQN COMBINATION BLOCK.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQN(4)
C
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     INITIALISE TENSOR EXPANSION ARRAY
      DO LTEN=1,MNU
        NUS(LTEN) = 0
        DO I=1,16
          INU(LTEN,I) = 0
        ENDDO
      ENDDO
      NUNUM = 0
C
C**********************************************************************C
C     LQN PARITY ANALYSIS: CHECK PARITY OF LQN COMBINATIONS.           C
C     EXIT IF THERE IS NO MULTIPOLE EXPANSION FOR THIS CASE.           C
C**********************************************************************C
C
C     A AND B: PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
      IPARAB = MOD(LQN(1)+LQN(2),2)
C
C     C AND D: PARITY OF 'LQN(3)+LQN(4)' (0 IF EVEN, 1 IF ODD)
      IPARCD = MOD(LQN(3)+LQN(4),2)
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.NE.IPARCD) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     TENSOR LIMITS BY TRIANGLE RULE
      NUI = MAX0(IABS(LQN(1)-LQN(2)),IABS(LQN(3)-LQN(4)))
      NUF = MIN0(    (LQN(1)+LQN(2)),    (LQN(3)+LQN(4)))
C
C     TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     CALCULATE COMPONENT-TYPE OVERLAP COEFFICIENTS FOR TENSOR ORDERS  C
C     NU (AND NU±1 WHERE APPLICABLE), COUPLING IN ANGULAR FACTORS.     C
C**********************************************************************C
C
      ISEL = 0
      LTEN = 1
      DO NU=NUI,NUF
C
C       A AND B: PARITY OF 'LA+LB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C       C AND D: PARITY OF 'LC+LD+NU' (0 IF EVEN, 1 IF ODD)
        IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C       CASE 1: LA+LB+NU AND LC+LD+NU ARE BOTH ODD (AND NU=/=0)
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(LTEN) = NU
C
        ENDIF
C
C       CASE 2: LA+LB+NU AND LC+LD+NU ARE BOTH EVEN
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          NUS(LTEN) = NU-1
C
C         INCREASE TENSOR LIST LENGTH IF ENTRIES ARE NON-ZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          NUS(LTEN) = NU+1
C
        ENDIF
C
      ENDDO
C
C     RESET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(1)
      NUF = NUS(LTEN)
      NUNUM = LTEN
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT1(BCOF,KQN,LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 11        C
C         AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   111        C
C        AA  AA  NNNN  NN GG       BB    BB RR    RR   TT    11        C
C       AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT    11        C
C       AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT    11        C
C       AA    AA NN   NNN GG    GG BB    BB RR    RR   TT    11        C
C       AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT   1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C -------------------------------------------------------------------- C
C  WE USE TEMPORARY COUNTERS FOR TENSOR ORDERS AND TRANSFER AT THE END.C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION KQN(4),LQN(4),JQN(4)
      DIMENSION SCOEFF(8,2)
      DIMENSION DKAB(0:MNU,MKP+1,MKP+1),DKCD(0:MNU,MKP+1,MKP+1)
      DIMENSION AJJN(MKP+1,MKP+1,MKP+1,MKP+1)
      DIMENSION BCOF(MNU,8,MKP+1,MKP+1,MKP+1,MKP+1)
C
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     INITIALISE BREIT COEFFICIENTS
      DO K=1,MNU
        DO IMU=1,8
          DO IMJA=1,2*IABS(KQN(1))
            DO IMJB=1,2*IABS(KQN(2))
              DO IMJC=1,2*IABS(KQN(3))
                DO IMJD=1,2*IABS(KQN(4))
                  BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD) = 0.0D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
C     TENSOR LIMITS BY TRIANGLE RULE
      NUIT = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUFT = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUIT.GT.NUFT) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     LQN PARITY ANALYSIS: CHECK PARITY OF LQN COMBINATIONS.           C
C     EXIT IF THERE IS NO MULTIPOLE EXPANSION FOR THIS CASE.           C
C**********************************************************************C
C
C     A AND B: PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
      IPARAB = MOD(LQN(1)+LQN(2),2)
C
C     C AND D: PARITY OF 'LQN(3)+LQN(4)' (0 IF EVEN, 1 IF ODD)
      IPARCD = MOD(LQN(3)+LQN(4),2)
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     WIGNER-ECKART: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|        C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS FOR THIS KQN BLOCK
          DO NU=NUIT,NUFT
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(NU,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(NU,MJA+1,MJB  ) = DK(JQN(1), MJA,JQN(2),-MJB,NU)
            DKAB(NU,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2), MJB,NU)
            DKAB(NU,MJA+1,MJB+1) = DK(JQN(1), MJA,JQN(2), MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J',M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS FOR THIS KQN BLOCK
          DO NU=NUIT,NUFT
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(NU,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(NU,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3), MJC,NU)
            DKCD(NU,MJC  ,MJD+1) = DK(JQN(4), MJD,JQN(3),-MJC,NU)
            DKCD(NU,MJC+1,MJD+1) = DK(JQN(4), MJD,JQN(3), MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATE COMPONENT-TYPE OVERLAP COEFFICIENTS FOR TENSOR ORDERS  C
C     NU (AND NU±1 WHERE APPLICABLE), COUPLING IN ANGULAR FACTORS.     C
C**********************************************************************C
C
      ISEL = 0
      DO NU=NUIT,NUFT
C
C       A AND B: PARITY OF 'LA+LB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C       C AND D: PARITY OF 'LC+LD+NU' (0 IF EVEN, 1 IF ODD)
        IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C       JQN AND NU ANGULAR FACTORS FOR THIS COMBINATION
        DO IMJA=1,2*IABS(KQN(1))
          DO IMJB=1,2*IABS(KQN(2))
            DO IMJC=1,2*IABS(KQN(3))
              DO IMJD=1,2*IABS(KQN(4))
                AJJN(IMJA,IMJB,IMJC,IMJD)
     &           = DKAB(NU,IMJA,IMJB)*DKCD(NU,IMJC,IMJD)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
C
C       CASE 1: LA+LB+NU AND LC+LD+NU ARE BOTH ODD (AND NU=/=0)
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         FIND THE APPROPRIATE INDEX K FOR THIS NU
          K = KFIND(NU)
          INU(K,K4AD) = 1
C
C         INTERMEDIATE (KQN,NU) COEFFICIENTS
          RNU    = DFLOAT(NU*(NU+1))
          RCOEFF =-DFLOAT((KQN(1)+KQN(2))*(KQN(3)+KQN(4)))/RNU
C
C         CONTRIBUTIONS TO TENSOR ORDER "NU"
          DO IMU=1,8
C
            DO IMJA=1,2*IABS(KQN(1))
              DO IMJB=1,2*IABS(KQN(2))
                DO IMJC=1,2*IABS(KQN(3))
                  DO IMJD=1,2*IABS(KQN(4))
                    BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD)
     &               = BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD)
     &               +          AJJN(IMJA,IMJB,IMJC,IMJD)*RCOEFF
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
C
        ENDIF
C
C       CASE 2: LA+LB+NU AND LC+LD+NU ARE BOTH EVEN
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         CALCULATE BREIT COEFFICIENTS WITH CALL TO BRCOEF1
          CALL BRCOEF1(SCOEFF,KQN,NU)
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          IF(NU.GT.0) THEN
            K = KFIND(NU-1)
            INU(K,K4AD) = 1
          ENDIF
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          DO IMU=1,8
C
            DO IMJA=1,2*IABS(KQN(1))
              DO IMJB=1,2*IABS(KQN(2))
                DO IMJC=1,2*IABS(KQN(3))
                  DO IMJD=1,2*IABS(KQN(4))
                    BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD)
     &               = BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD)
     &               +          AJJN(IMJA,IMJB,IMJC,IMJD)*SCOEFF(IMU,1)
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          K = KFIND(NU+1)
          INU(K,K4AD) = 1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          DO IMU=1,8
C
            DO IMJA=1,2*IABS(KQN(1))
              DO IMJB=1,2*IABS(KQN(2))
                DO IMJC=1,2*IABS(KQN(3))
                  DO IMJD=1,2*IABS(KQN(4))
                    BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD)
     &               = BCOF(K,IMU,IMJA,IMJB,IMJC,IMJD)
     &         +                AJJN(IMJA,IMJB,IMJC,IMJD)*SCOEFF(IMU,2)
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
C
        ENDIF
C
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION KFIND(NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               KK    KK FFFFFFFF IIII NN    NN DDDDDDD                C
C               KK   KK  FF        II  NNN   NN DD    DD               C
C               KK  KK   FF        II  NNNN  NN DD    DD               C
C               KKKKK    FFFFFF    II  NN NN NN DD    DD               C
C               KK  KK   FF        II  NN  NNNN DD    DD               C
C               KK   KK  FF        II  NN   NNN DD    DD               C
C               KK    KK FF       IIII NN    NN DDDDDDD                C
C                                                                      C
C -------------------------------------------------------------------- C
C  KFIND DETERMINES THE TENSOR INDEX FOR A GIVEN VALUE N (LQN BLOCK).  C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 STRING
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
      KFIND = 0
      DO K=1,NUNUM
        IF(NU.EQ.NUS(K)) THEN
          KFIND = K
          GOTO 50
        ENDIF
      ENDDO
      WRITE(6, *) 'In KFIND: could not find tensor index.',NU
      WRITE(7, *) 'In KFIND: could not find tensor index.',NU
50    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF1(SCOEFF,KQN,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF      111        C
C      BB    BB RR    RR CC       OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF   11        C
C      BB    BB RRRRRRR  CC       OO    OO EE       FF       11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF      1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF1 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION IN THE GENERAL CASE (TABLE 2 OF GRANT AND PYPER 1976).  C
C  COEFFICIENTS WE CONFIRMED BY REFERENCING (CHEN AND JOHNSON 1993).   C
C -------------------------------------------------------------------- C
C  MAPPING OF SCOEFF ADDRESSES TO BREIT INTEGRALS (NU±1)               C
C   1: LSLS (UPPER)    2: LSLS (LOWER)                                 C
C   3: SLSL (UPPER)    4: SLSL (LOWER)                                 C
C   5: LSSL (UPPER)    6: LSSL (LOWER)                                 C
C   7: SLLS (UPPER)    8: SLLS (LOWER)                                 C
C**********************************************************************C
      DIMENSION SCOEFF(8,2),KQN(4)
C
      KCA = KQN(2)-KQN(1)
      KDB = KQN(4)-KQN(3)
C
      IF(NU.GE.1) THEN
        B1 = DFLOAT(NU*(NU+1))/DFLOAT(2*NU*(2*NU-1))
        C1 = DFLOAT(   (NU-2))/DFLOAT(2*NU*(2*NU-1))
        SCOEFF(1,1) = DFLOAT(NU  +KCA)*(B1-C1*KDB)
        SCOEFF(2,1) = DFLOAT(NU  +KDB)*(B1-C1*KCA)
        SCOEFF(3,1) = DFLOAT(NU  -KCA)*(B1+C1*KDB)
        SCOEFF(4,1) = DFLOAT(NU  -KDB)*(B1+C1*KCA)
        SCOEFF(5,1) =-DFLOAT(NU  +KCA)*(B1+C1*KDB)
        SCOEFF(6,1) =-DFLOAT(NU  -KDB)*(B1-C1*KCA)
        SCOEFF(7,1) =-DFLOAT(NU  -KCA)*(B1-C1*KDB)
        SCOEFF(8,1) =-DFLOAT(NU  +KDB)*(B1+C1*KCA)
      ELSE
        DO I=1,8
          SCOEFF(I,1) = 0.0D0
        ENDDO
      ENDIF
C
      IF(NU.GE.0) THEN
        B2 = DFLOAT(NU*(NU+1))/DFLOAT((2*NU+2)*(2*NU+3))
        C2 = DFLOAT(    NU+3 )/DFLOAT((2*NU+2)*(2*NU+3))
        SCOEFF(1,2) =-DFLOAT(NU+1-KDB)*(B2+C2*KCA)
        SCOEFF(2,2) =-DFLOAT(NU+1-KCA)*(B2+C2*KDB)
        SCOEFF(3,2) =-DFLOAT(NU+1+KDB)*(B2-C2*KCA)
        SCOEFF(4,2) =-DFLOAT(NU+1+KCA)*(B2-C2*KDB)
        SCOEFF(5,2) = DFLOAT(NU+1+KDB)*(B2+C2*KCA)
        SCOEFF(6,2) = DFLOAT(NU+1-KCA)*(B2-C2*KDB)
        SCOEFF(7,2) = DFLOAT(NU+1-KDB)*(B2-C2*KCA)
        SCOEFF(8,2) = DFLOAT(NU+1+KCA)*(B2+C2*KDB)
      ELSE
        DO I=1,8
          SCOEFF(I,2) = 0.0D0
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION DK(JA,MA,JB,MB,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          DDDDDDD  KK    KK                           C
C                          DD    DD KK   KK                            C
C                          DD    DD KK  KK                             C
C                          DD    DD KKKKK                              C
C                          DD    DD KK  KK                             C
C                          DD    DD KK   KK                            C
C                          DDDDDDD  KK    KK                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  DK CALCULATES THE APPROPRIATE TENSOR COEFFICIENT FOR A 2-SPINOR     C
C  EVEN OPERATOR EXPANSION OF ORDER NU (DEFINED AS IN GRANT 6.2.12.)   C
C  IT EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB INTERACTION,   C
C  ABSORBING THE ANGULAR DIAGRAM AND ANGULAR PARTS OF THE EFFECTIVE    C
C  INTERACTION STRENGTH TOGETHER. IT EVALUATES ALL PARTS THAT DEPEND   C
C  ON THE ANGULAR FACTOR AT THE INTERACTION VERTEX, ASSUMING THAT THE  C
C  PRIMITIVE RK-RADIAL INTEGRAL (AND NOT XK) IS THE REMAINDER.         C
C -------------------------------------------------------------------- C
C  INPUT CONVENTION: THE ANGULAR MOMENTA (JA,JB,MA,MB) SHOULD BE       C
C  SUPPLIED AS TWICE THEIR ACTUAL VALUES (THESE ARE ODD-HALF-INTEGER   C
C  ELECTRONIC VALUES) WHILE NU AND IQ ARE THE **ACTUAL** VALUES OF THE C
C  PHOTON PARAMETERS. THE SELECTION RULE IS THAT (MA+MB)/2+IQ=0.       C
C  THIS METHOD CAN ALSO BE USED FOR OPEN-SHELL ATOMIC BREIT INTEGRALS. C
C**********************************************************************C
C
C      CHOOSE IQ IN ACCORDANCE WITH PHOTON SELECTION RULE
       IQ = (MA-MB)/2
C
C      MQN PHASE TERM
       PHS = DFLOAT((-1)**((MA+1)/2))
C
C      CONVENTIONAL JQN SQUARE ROOT TERMS
       RTJ = DSQRT(DFLOAT((JA+1)*(JB+1)))
C
C      3J SYMBOL ASSOCIATED WITH ANGULAR MOMENTUM CONSERVATION
       SEL = SYM3J(JA,NU,JB,+1,0,-1)
C
C      3J SYMBOL CONTAINING SPIN TERMS
       QMM = SYM3J(JA,NU,JB,-MA,IQ,MB)
C
C      FINAL ANGULAR FACTOR
       DK = PHS*RTJ*SEL*QMM
C
       RETURN
       END
C
C
      FUNCTION SYM3J(JA,L,JB,MA,M,MB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            SSSSSS  YY    YY MM       MM  333333      JJJJJ           C
C           SS    SS YY    YY MMM     MMM 33    33       JJ            C
C           SS       YY    YY MMMM   MMMM       33       JJ            C
C            SSSSSS   YY  YY  MM MM MM MM    3333        JJ            C
C                 SS   YYYY   MM  MMM  MM       33       JJ            C
C           SS    SS    YY    MM   M   MM  33   33 JJ    JJ            C
C            SSSSSS     YY    MM       MM   33333   JJJJJJ             C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3J EVALUATES A WIGNER 3-J SYMBOL,               / j  L  j'\      C
C  WHERE j=JA/2, j'=JB/2, m=MA/2 AND m'=MB/2,         \ m  M  m'/      C
C  BUT L AND M ARE THE ACTUAL VALUES. (BRINK AND SATCHLER {2.34}.)     C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(IABS(M).GT.L) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(2*M+MA+MB.NE.0) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(IABS(MA).GT.JA.OR.IABS(MB).GT.JB) THEN
        SYM3J = 0.0D0
        RETURN
      ENDIF
C
C     OVERALL PHASE FACTOR (CONVERSION FROM CG-COEFF TO 3J-SYMBOL)
      IPS = (JA-MB)/2 - L
      PHS = DFLOAT((-1)**(IPS))
C
C     SYMMETRIC FACTOR INVOLVING VERTICAL PAIRS (j,m), (L,M), (j',m')
      SM1 = RFACT((JA+MA)/2)
      SM2 = RFACT((JA-MA)/2)
      SM3 = RFACT((JB-MB)/2)
      SM4 = RFACT((JB+MB)/2)
      SM5 = RFACT(  L +M   )
      SM6 = RFACT(  L -M   )
      SYM = DSQRT(SM1*SM2*SM3*SM4*SM5*SM6)
C
C     TRIANGULAR FACTOR, DELTA (j, L, j')
      TR1 = RFACT((JA-JB)/2+L  )
      TR2 = RFACT((JA+JB)/2-L  )
      TR3 = RFACT((JB-JA)/2+L  )
      TR4 = RFACT((JA+JB)/2+L+1)
      TRP = DSQRT(TR1*TR2*TR3/TR4)
C
C     LIMITS IN THE SUM OVER TENSOR ORDERS NU
      NUI = MAX0(L-(JB+MA)/2,M+(JA-JB)/2,  0)
      NUF = MIN0(  (JA-MA)/2,L+(JA-JB)/2,L+M)
C
C     SUM OVER ALLOWED TENSOR ORDERS NU
      XNU = 0.0D0
      DO NU=NUI,NUF
C
C       PHASE TERM FROM TENSOR ORDER
        PTN = DFLOAT((-1)**NU)
C
C       FACTORS INVOLVING TENSOR ORDER
        RD1 = RFACT((JA-MA)/2    -NU)
        RD2 = RFACT((JB+MA)/2-L  +NU)
        RD3 = RFACT((JB-JA)/2  -M+NU)
        RD4 = RFACT((JA-JB)/2+L  -NU)
        RD5 = RFACT(          L+M-NU)
        RD6 = RFACT(              NU)
        RDP = RD1*RD2*RD3*RD4*RD5*RD6
C
C       ADD THIS CONTRIBUTION TO THE 3J-SYMBOL
        XNU = XNU + PTN/RDP
C
      ENDDO
C
C     3-J SYMBOL IS A PRODUCT OF PHASE, SYMMETRIC FACTOR, TRIANGULAR
C     FACTOR AND THE SUM OVER ALLOWED NU TERMS
      SYM3J = PHS*TRP*SYM*XNU
C
      RETURN
      END
C
C
      SUBROUTINE IJSET1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              IIII     JJJJ SSSSSS  EEEEEEEE TTTTTTTT 11              C
C               II       JJ SS    SS EE          TT   111              C
C               II       JJ SS       EE          TT    11              C
C               II       JJ  SSSSSS  EEEEEE      TT    11              C
C               II       JJ       SS EE          TT    11              C
C               II JJ    JJ SS    SS EE          TT    11              C
C              IIII JJJJJJ   SSSSSS  EEEEEEEE    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  IJSET1 PREPARES BASIS SET INTERMEDIATES FOR ALL IJ-PAIRS OF BASIS   C
C  FUNCTIONS, FOR USE IN ROUTINES RKCLM1/RKBRT1.                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RNLA(MBS),RNSA(MBS),RNLB(MBS),RNSB(MBS)
      DIMENSION EIJ0(MB2)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST A
      RL = DFLOAT(LQN(1))
      G1 = TWLG-GAMLOG(2*LQN(1)+3)
      G2 = TWLG-GAMLOG(2*LQN(1)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO IBAS=1,NBAS(1)
        EIV        = EXL(IBAS,1)
        ELOG       = DLOG(2.0D0*EIV)
        RNLA(IBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSA(IBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST B
      RL = DFLOAT(LQN(2))
      G1 = TWLG-GAMLOG(2*LQN(2)+3)
      G2 = TWLG-GAMLOG(2*LQN(2)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO JBAS=1,NBAS(2)
        EJV        = EXL(JBAS,2)
        ELOG       = DLOG(2.0D0*EJV)
        RNLB(JBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSB(JBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     LIST OF EXPONENTS AND NORMALISATION COEFFICIENTS IN THE BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EI(M)     = EXL(IBAS,1)
          EJ(M)     = EXL(JBAS,2)
          EIJ0(M)   = EI(M)+EJ(M)
          RNIJ(M,1) = RNLA(IBAS)*RNLB(JBAS)
          RNIJ(M,2) = RNLA(IBAS)*RNSB(JBAS)
          RNIJ(M,3) = RNSA(IBAS)*RNLB(JBAS)
          RNIJ(M,4) = RNSA(IBAS)*RNSB(JBAS)
        ENDDO
      ENDDO
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     LOWEST EXPONENT POWER
      IPOWER = LQN(1)+LQN(2)-NUF
C
C     GAUSSIAN OVERLAPS TO ALL REQUIRED POWERS
      DO M=1,MAXAB
C
C       SEED GAUSSIAN EXPONENT VALUE
        EIJR = DSQRT(EIJ0(M))
        EIJ(M,-NUF) = EIJR**(-IPOWER)
C
C       LOOP OVER ALL TENSOR ORDERS AND DIVIDE
        DO IPOW=-NUF+1,NUF+5
          EIJ(M,IPOW) = EIJ(M,IPOW-1)/EIJR
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KLSET1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            KK    KK LL       SSSSSS  EEEEEEEE TTTTTTTT 11            C
C            KK   KK  LL      SS    SS EE          TT   111            C
C            KK  KK   LL      SS       EE          TT    11            C
C            KKKKK    LL       SSSSSS  EEEEEE      TT    11            C
C            KK  KK   LL            SS EE          TT    11            C
C            KK   KK  LL      SS    SS EE          TT    11            C
C            KK    KK LLLLLLLL SSSSSS  EEEEEEEE    TT   1111           C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLSET1 PREPARES BASIS SET INTERMEDIATES FOR ALL IJ-PAIRS OF BASIS   C
C  FUNCTIONS, FOR USE IN ROUTINES RKCLM1/RKBRT1.                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RNLC(MBS),RNSC(MBS),RNLD(MBS),RNSD(MBS)
      DIMENSION EKL0(MB2)
C
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/XNUS/INU(MNU,16),NUS(MNU),NUI,NUF,NUNUM,K4AD
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST C
      RL = DFLOAT(LQN(3))
      G1 = TWLG-GAMLOG(2*LQN(3)+3)
      G2 = TWLG-GAMLOG(2*LQN(3)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO KBAS=1,NBAS(3)
        EKV        = EXL(KBAS,3)
        ELOG       = DLOG(2.0D0*EKV)
        RNLC(KBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSC(KBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST D
      RL = DFLOAT(LQN(4))
      G1 = TWLG-GAMLOG(2*LQN(4)+3)
      G2 = TWLG-GAMLOG(2*LQN(4)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO LBAS=1,NBAS(4)
        ELV        = EXL(LBAS,4)
        ELOG       = DLOG(2.0D0*ELV)
        RNLD(LBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSD(LBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     LIST OF EXPONENTS AND NORMALISATION COEFFICIENTS IN THE BLOCK
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          EK(M)     = EXL(KBAS,3)
          EL(M)     = EXL(LBAS,4)
          EKL0(M)   = EK(M)+EL(M)
          RNKL(M,1) = RNLC(KBAS)*RNLD(LBAS)
          RNKL(M,2) = RNLC(KBAS)*RNSD(LBAS)
          RNKL(M,3) = RNSC(KBAS)*RNLD(LBAS)
          RNKL(M,4) = RNSC(KBAS)*RNSD(LBAS)
        ENDDO
      ENDDO
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     LOWEST EXPONENT POWER
      IPOWER = LQN(3)+LQN(4)-NUF
C
C     GAUSSIAN OVERLAPS TO ALL REQUIRED POWERS
      DO M=1,MAXCD
C
C       SEED GAUSSIAN EXPONENT VALUE
        EKLR = DSQRT(EKL0(M))
        EKL(M,-NUF) = EKLR**(-IPOWER)
C
C       LOOP OVER ALL TENSOR ORDERS AND DIVIDE
        DO IPOW=-NUF+1,NUF+5
          EKL(M,IPOW) = EKL(M,IPOW-1)/EKLR
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BETASET(NVALS,NTENX,NTENY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB  EEEEEEEE TTTTTTTT   AA     SSSSSS  EEEEEEEE TTTTTTTT     C
C    BB    BB EE          TT     AAAA   SS    SS EE          TT        C
C    BB    BB EE          TT    AA  AA  SS       EE          TT        C
C    BBBBBBB  EEEEEE      TT   AA    AA  SSSSSS  EEEEEE      TT        C
C    BB    BB EE          TT   AAAAAAAA       SS EE          TT        C
C    BB    BB EE          TT   AA    AA SS    SS EE          TT        C
C    BBBBBBB  EEEEEEEE    TT   AA    AA  SSSSSS  EEEEEEEE    TT        C
C                                                                      C
C -------------------------------------------------------------------- C
C  BETASET EVALUATES A SET OF BETA INTEGRALS REQUIRED FOR THE          C
C  ONE-CENTRE RADIAL INTEGRALS OVER THE COULOMB/BREIT INTERACTIONS.    C
C -------------------------------------------------------------------- C
C  INDEX 1 FOR UPPER INTEGRALS, INDEX 2 FOR LOWER INTEGRALS.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
C
      COMMON/B0IJ/EIJ(MB2,-MTN:MTN),RNIJ(MB2,4),EI(MB2),EJ(MB2),MAXAB
      COMMON/B0KL/EKL(MB2,-MTN:MTN),RNKL(MB2,4),EK(MB2),EL(MB2),MAXCD
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),IBAS,JBAS,IJ
      COMMON/BETA/BDU(MB2*MB2,MNU,MNU),BDL(MB2*MB2,MNU,MNU)
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI(IJ)+EJ(IJ)
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXCD
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+2*NX+NTENX
        IAA(2) = LQN(3)+LQN(4)+2*NX+NTENX
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)+2*NY-NTENY
          IBB(2) = LQN(1)+LQN(2)+2*NY-NTENY
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXCD
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXCD
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXCD
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXCD
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXCD
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXCD
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXCD
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXCD
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
C           ASSEMBLE A LIST OF UPPER AND LOWER BETA INTEGRALS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXCD
                BDU((IJ-1)*MAXCD+M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXCD
                BDL((IJ-1)*MAXCD+M,NX,NY) = BETA(M)
              ENDDO
            ENDIF
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE TESTANG(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     TTTTTTTT EEEEEEEE SSSSSS TTTTTTTT   AA    NN    NN  GGGGGG       C
C        TT    EE      SS    SS   TT     AAAA   NNN   NN GG    GG      C
C        TT    EE      SS         TT    AA  AA  NNNN  NN GG            C
C        TT    EEEEEE   SSSSSS    TT   AA    AA NN NN NN GG            C
C        TT    EE            SS   TT   AAAAAAAA NN  NNNN GG   GGG      C
C        TT    EE      SS    SS   TT   AA    AA NN   NNN GG    GG      C
C        TT    EEEEEEEE SSSSSS    TT   AA    AA NN    NN  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  TESTANG IS A ROUTINE THAT PRINTS A TABLE OF ANGULAR COEFFICIENTS,   C
C  DK(J M ,J'M') FOR AN ALLOWED NUMBER OF TENSOR POWERS K, AND ALL     C
C  COMBINATIONS OF JA, JB, MA, MB FOR GIVEN SYMMETRY TYPES KA, KB.     C
C -------------------------------------------------------------------- C
C  TODO: MUST CALL 'FACTRL' ROUTINE AT SOME POINT BEFORE THIS.         C
C        FACTORS ARE PRESENTED AS THEIR SQUARES (SIGNS RETAINED), WITH C
C        AN EXTRA OPTION TO MULTIPLY THEM AGAIN BY A FACTOR F(NU).     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION KQN(2),JQN(2),LQN(2)
      DIMENSION NUS(MNU),FMLT(MNU)
      DIMENSION BK(MNU)
      DIMENSION ELL(MNU),ESL(MNU),ESS(MNU),GSL(MNU)
      DIMENSION DKAB(MNU,MKP+1,MKP+1)
C
C     OVER-RIDE INPUT KQN VALUES
      KQN(1) =-1
      KQN(2) =-1
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE LQN VALUES
      DO I=1,2
        LQN(I) = LVAL(KQN(I))
      ENDDO
C
C     ALLOWED TENSOR POWERS
      NUI = IABS(JQN(1)-JQN(2))/2
      NUF =     (JQN(1)+JQN(2))/2
      NUNUM = NUF-NUI+1
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, QUIT PROCEDURE
      IF(NUNUM.EQ.0) RETURN
C
C**********************************************************************C
C     CLOSED-SHELL COULOMB EXCHANGE TERMS, BK(JJ').                    C
C**********************************************************************C
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 0
      DO NU=NUI,NUF
C
C       PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
C
        IF(IPARAB.EQ.0) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN = LTEN+1
          NUS(LTEN) = NU
C
          IF(HMLT.EQ.'NORL') THEN
            BK(LTEN) = 0.5D0*ANGSQLS(LQN(1),LQN(2),NU)
          ELSE
            BK(LTEN) =       ANGSQJJ(JQN(1),JQN(2),NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6, *) ' CLOSED COULOMB EXCHANGE COEFFICIENTS:'
      WRITE(7, *) ' CLOSED COULOMB EXCHANGE COEFFICIENTS:'
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(6,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(6,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(6,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(6,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(6,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(6,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(6,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(6,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(6,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(6,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(6,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(6,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(6,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(6,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
C
301   FORMAT(1X,A, 1(1X,F13.9))
302   FORMAT(1X,A, 2(1X,F13.9))
303   FORMAT(1X,A, 3(1X,F13.9))
304   FORMAT(1X,A, 4(1X,F13.9))
305   FORMAT(1X,A, 5(1X,F13.9))
306   FORMAT(1X,A, 6(1X,F13.9))
307   FORMAT(1X,A, 7(1X,F13.9))
308   FORMAT(1X,A, 8(1X,F13.9))
309   FORMAT(1X,A, 9(1X,F13.9))
310   FORMAT(1X,A,10(1X,F13.9))
311   FORMAT(1X,A,11(1X,F13.9))
312   FORMAT(1X,A,12(1X,F13.9))
313   FORMAT(1X,A,13(1X,F13.9))
314   FORMAT(1X,A,14(1X,F13.9))
C
      IF(NUNUM.EQ.1) THEN
        WRITE(6,301) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,301) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(6,302) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,302) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(6,303) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,303) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(6,304) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,304) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(6,305) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,305) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(6,306) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,306) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(6,307) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,307) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(6,308) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,308) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(6,309) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,309) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(6,310) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,310) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(6,311) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,311) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(6,312) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,312) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(6,313) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,313) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(6,314) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
        WRITE(7,314) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
C
C**********************************************************************C
C     CLOSED-SHELL BREIT EXCHANGE TERMS, EK(JJ') AND GK(JJ').          C
C**********************************************************************C
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,NUF-NUI+1
        ELL(LTEN) = 0.0D0
        ESL(LTEN) = 0.0D0
        ESS(LTEN) = 0.0D0
        GSL(LTEN) = 0.0D0
      ENDDO
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = ANGSQJJ(JQN(1),JQN(2),NU)
C
C       FLOATING-POINT VERSIONS OF TENSOR ORDER AND KQN DIFFERENCE
        RU  = DFLOAT(NU)
        RK  = DFLOAT(KQN(2)-KQN(1))
        RP  = DFLOAT(KQN(1)+KQN(2))
C
C       A AND B: PARITY OF 'LQN(1)+LQN(2)+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
        IF(IPARAB.EQ.1.AND.NU.NE.0) THEN
C       ANGULAR COEFFICIENTS OF ODD PARITY
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN) = ELL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESS(LTEN) = ESS(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESL(LTEN) = ESL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
C
        ELSEIF(IPARAB.EQ.0) THEN
C       ANGULAR COEFFICIENTS OF EVEN PARITY
C
C         DOWN-LADDER ENTRIES...
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 0
          IF(NU-1.GE.0) THEN
            B1 = DFLOAT(NU+1)/DFLOAT(2*(2*NU-1))
            C1 =-DFLOAT(NU-2)/DFLOAT(2*(2*NU-1)*NU)
            ELL(LTEN) = ELL(LTEN) + RAW*((RU+RK)*(B1+C1*RK))
            ESL(LTEN) = ESL(LTEN) - RAW*((B1*RU)-(C1*RK*RK))
            ESS(LTEN) = ESS(LTEN) + RAW*((RU-RK)*(B1-C1*RK))
            GSL(LTEN) = GSL(LTEN) - RAW*(    RK *(B1-C1*RU))
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         UP-LADDER ENTRIES...
          NUS(LTEN) = NU+1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 1
          IF(NU+1.GE.1) THEN
            B2 = DFLOAT(NU  )/DFLOAT(2*(2*NU+3))
            C2 = DFLOAT(NU+3)/DFLOAT(2*(NU+1)*(2*NU+3))
            ELL(LTEN) = ELL(LTEN) + RAW*((RK-RU-1.0D0)*( B2+C2*RK))
            ESL(LTEN) = ESL(LTEN) + RAW*((B2*(RU+1.0D0))+C2*RK*RK)
            ESS(LTEN) = ESS(LTEN) - RAW*((RK+RU+1.0D0)*( B2-C2*RK))
            GSL(LTEN) = GSL(LTEN) + RAW*(C2*RK*(RU+1.0D0)+B2*RK)
          ENDIF
C
        ENDIF
C
      ENDDO
      
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6, *) ' CLOSED BREIT EXCHANGE COEFFICIENTS:'
      WRITE(7, *) ' CLOSED BREIT EXCHANGE COEFFICIENTS:'
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(6,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(6,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(6,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(6,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(6,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(6,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(6,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(6,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(6,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(6,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(6,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(6,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(6,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(6,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
C
      IF(NUNUM.EQ.1) THEN
        WRITE(6,301) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,301) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,301) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,301) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,301) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,301) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,301) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,301) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(6,302) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,302) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,302) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,302) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,302) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,302) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,302) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,302) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(6,303) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,303) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,303) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,303) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,303) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,303) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,303) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,303) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(6,304) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,304) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,304) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,304) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,304) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,304) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,304) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,304) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(6,305) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,305) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,305) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,305) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,305) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,305) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,305) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,305) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(6,306) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,306) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,306) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,306) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,306) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,306) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,306) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,306) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(6,307) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,307) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,307) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,307) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,307) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,307) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,307) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,307) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(6,308) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,308) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,308) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,308) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,308) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,308) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,308) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,308) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(6,309) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,309) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,309) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,309) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,309) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,309) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,309) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,309) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(6,310) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,310) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,310) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,310) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,310) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,310) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,310) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,310) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(6,311) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,311) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,311) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,311) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,311) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,311) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,311) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,311) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(6,312) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,312) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,312) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,312) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,312) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,312) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,312) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,312) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(6,313) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,313) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,313) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,313) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,313) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,313) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,313) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,313) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(6,314) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(7,314) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(6,314) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(7,314) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(6,314) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(7,314) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(6,314) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
        WRITE(7,314) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
C
C**********************************************************************C
C     GENERAL COULOMB TERMS, DK(J M ;J'M').                            C
C**********************************************************************C
C
C     RESTORE ORIGINAL TENSOR ORDER RANGE
      NUNUM = NUF-NUI+1
C
C     ASSIGN THE TENSOR POWERS TO A LIST
      LTEN = 0
      DO NU=NUI,NUF
        LTEN      = LTEN+1
        NUS(LTEN) = NU
      ENDDO
C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.
C     REVERSE (JA,MA) WITH (JB,MB) INPUTS TO ACCOMMODATE THE RELATION:
C                DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     ASSIGN PRE-FACTORS TO TENSOR POWERS
      DO LTEN=1,NUNUM
        FMLT(LTEN) = 1.0D0
      ENDDO
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(2),-MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(2),-MJB,JQN(1),+MJA,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(2),+MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(2),+MJB,JQN(1),+MJA,NU)
C
          ENDDO
C
C       END THE LOOP OVER MQN(A)
        ENDDO
C     END THE LOOP OVER MQN(B)
      ENDDO
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6, *) ' GENERAL COULOMB COEFFICIENTS D^K(JA,MA;JB,MB):'
      WRITE(7, *) ' GENERAL COULOMB COEFFICIENTS D^K(JA,MA;JB,MB):'
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(6,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(6,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(6,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(6,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(6,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(6,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(6,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(6,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(6,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(6,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(6,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(6,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(6,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(6,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
        WRITE(7,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
C
101   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 1(9X,'K =',I2))
102   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 2(9X,'K =',I2))
103   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 3(9X,'K =',I2))
104   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 4(9X,'K =',I2))
105   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 5(9X,'K =',I2))
106   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 6(9X,'K =',I2))
107   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 7(9X,'K =',I2))
108   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 8(9X,'K =',I2))
109   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 9(9X,'K =',I2))
110   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',10(9X,'K =',I2))
111   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',11(9X,'K =',I2))
112   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',12(9X,'K =',I2))
113   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',13(9X,'K =',I2))
114   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',14(9X,'K =',I2))
C
C     LOOP OVER POSITIVE MQN(B) VALUES -- DESCENDING ORDER OF MAGNITUDE
      DO MB=IABS(KQN(2)),1,-1
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(6,201) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,201) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(6,202) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,202) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(6,203) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,203) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(6,204) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,204) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(6,205) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,205) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(6,206) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,206) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(6,207) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,207) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(6,208) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,208) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(6,209) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,209) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(6,210) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,210) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(6,211) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,211) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(6,212) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,212) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(6,213) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,213) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(6,214) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
            WRITE(7,214) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(6,201)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,201)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(6,202)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,202)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(6,203)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,203)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(6,204)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,204)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(6,205)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,205)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(6,206)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,206)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(6,207)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,207)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(6,208)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,208)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(6,209)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,209)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(6,210)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,210)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(6,211)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,211)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(6,212)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,212)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(6,213)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,213)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(6,214)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
            WRITE(7,214)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.1) WRITE(6, *) REPEAT('-',NLNES)
        IF(MB.NE.1) WRITE(7, *) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(6, *) REPEAT('-',NLNES)
      WRITE(7, *) REPEAT('-',NLNES)
C     LOOP OVER NEGATIVE MQN(B) VALUES -- ASCENDING ORDER OF MAGNITUDE
      DO MB=1,IABS(KQN(2))
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(6,201) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,201) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(6,202) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,202) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(6,203) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,203) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(6,204) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,204) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(6,205) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,205) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(6,206) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,206) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(6,207) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,207) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(6,208) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,208) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(6,209) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,209) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(6,210) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,210) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(6,211) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,211) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(6,212) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,212) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(6,213) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,213) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(6,214) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
            WRITE(7,214) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(6,201)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,201)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(6,202)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,202)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(6,203)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,203)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(6,204)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,204)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(6,205)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,205)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(6,206)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,206)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(6,207)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,207)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(6,208)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,208)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(6,209)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,209)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(6,210)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,210)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(6,211)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,211)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(6,212)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,212)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(6,213)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,213)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(6,214)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
            WRITE(7,214)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.IABS(KQN(2))) WRITE(6, *) REPEAT('-',NLNES)
        IF(MB.NE.IABS(KQN(2))) WRITE(7, *) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(6, *) REPEAT('=',NLNES)
      WRITE(7, *) REPEAT('=',NLNES)
C
201   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 1(1X,F13.9))
202   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 2(1X,F13.9))
203   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 3(1X,F13.9))
204   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 4(1X,F13.9))
205   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 5(1X,F13.9))
206   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 6(1X,F13.9))
207   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 7(1X,F13.9))
208   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 8(1X,F13.9))
209   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 9(1X,F13.9))
210   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',10(1X,F13.9))
211   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',11(1X,F13.9))
212   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',12(1X,F13.9))
213   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',13(1X,F13.9))
214   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',14(1X,F13.9))
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [B] VMOMNT0: ZEROTH MOMENT INTEGRALS OVER σ_Q AND TT'.             C
C   [L] VNCOLAP: NUCLEAR CHARGE INTEGRALS OVER σ_Q, TT' AND IZ.        C
C**********************************************************************C
C
C
      SUBROUTINE VMOMNT0(VIJ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 000000   C
C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   00   000  C
C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT   00  0000  C
C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT   00 00 00  C
C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT   0000  00  C
C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   000   00  C
C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT    000000   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT0 CONSTRUCTS A MATRIX OF (μ,T|σ_Q|ν,T') ZEROTH MOMENT         C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS.                            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     GENERATE ELLQ COEFFICIENTS (IPHS = +1)
      IF(ITT.EQ.1) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C     GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELS = TELS + DFLOAT(ICL2-ICL1)/RATE
C     GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESL = TESL + DFLOAT(ICL2-ICL1)/RATE
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
      ELSE
        WRITE(6, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
          ERT = DSQRT(PI/EIJ)**3
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*E11(M,1)
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*E21(M,1)
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
C      IF(ITT.EQ.2) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) = CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
CC
CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
C      IF(ITT.EQ.3) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) =-CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VNCOLAP(VIJ,IZ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
C    VV    VV NNN   NN CC    CC OO    OO LL         AAAA   PP    PP    C
C    VV    VV NNNN  NN CC       OO    OO LL        AA  AA  PP    PP    C
C    VV    VV NN NN NN CC       OO    OO LL       AA    AA PP    PP    C
C     VV  VV  NN  NNNN CC       OO    OO LL       AAAAAAAA PPPPPPP     C
C      VVVV   NN   NNN CC    CC OO    OO LL       AA    AA PP          C
C       VV    NN    NN  CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCOLAP CONSTRUCTS A MATRIX OF (μ,T|ϱ_nuc|ν,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RNTT(MBS,MBS)
      DIMENSION EX2(MBS,2),LQ2(2),NBS2(2)
C
      COMPLEX*16 TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INTEGRATION GRID DETAILS
      NLIN = 6000
      RMAX = 6.0D0*RNUC(IZ)
      ELIN = RMAX/DFLOAT(NLIN)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE NUCLEAR OVERLAP MATRICES (ONE-CENTRE ONLY)              C
C**********************************************************************C
C
C     REASONS THAT QUADRATURE IS NOT NECESSARY
      IF(IZ.NE.ICNTA.OR.IZ.NE.ICNTB) GOTO 3500
      IF(NMDL(IZ).EQ.'POINT'.OR.NMDL(IZ).EQ.'GAUSS') GOTO 3500
C
C     ATOM-CENTRED SELECTION RULES
      IF(KQN(1).NE.KQN(2)) GOTO 3600
      IF(MQN(1).NE.MQN(2)) GOTO 3600
C
C     KQN+LQN+1 IN EACH CASE
      T1 = DFLOAT(KQN(1)+LQN(1)+1)
      T2 = DFLOAT(KQN(2)+LQN(2)+1)
C
C     SMOOSH BASIS FUNCTION DETAILS INTO APPROPRIATE ARRAYS
      LQ2(1) = LQN(1)
      NBS2(1) = NBAS(1)
      DO IBAS=1,NBS2(1)
        EX2(IBAS,1) = EXL(IBAS,1)
      ENDDO
C
      LQ2(2) = LQN(2)
      NBS2(2) = NBAS(2)
      DO JBAS=1,NBS2(2)
        EX2(JBAS,2) = EXL(JBAS,2)
      ENDDO
      
C     RADIAL NORMALISATION FACTORS
      CALL RNORM1(RNTT,EX2,LQ2,NBS2,ITT)
C
C     CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         EXPONENT AND NORMALISATION COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         NUMERICALLY INTEGRATE (LINEAR GRID) FROM 0 TO RNUC
          X0I = 0.0D0
          DO N=0,NLIN
            RI = ELIN*DFLOAT(N)
            IF(ITT.EQ.1) THEN
              RT1 = RI**(LQN(1)+1)
              RT2 = RI**(LQN(2)+1)
            ELSEIF(ITT.EQ.2) THEN
              RT1 = RI**(LQN(1)+1)
              RT2 = RI**(LQN(2)  )*(T2-2.0D0*EJ*RI*RI)
            ELSEIF(ITT.EQ.3) THEN
              RT1 = RI**(LQN(1)  )*(T1-2.0D0*EI*RI*RI)
              RT2 = RI**(LQN(2)+1)
            ELSEIF(ITT.EQ.4) THEN
              RT1 = RI**(LQN(1)  )*(T1-2.0D0*EI*RI*RI)
              RT2 = RI**(LQN(2)  )*(T2-2.0D0*EJ*RI*RI)
            ENDIF
            RSM = DEXP(-EIJ*RI*RI)
            PZR = RHONUC(NMDL(IZ),IZ,RI)
            X0I = X0I + EXTINT11(RT1*RT2*RSM*PZR,N,NLIN)
          ENDDO
          X0I = 5.0D0*ELIN*X0I/299376.0D0
C
          VIJ(NA1+IBAS,NB1+JBAS) = RNTT(IBAS,JBAS)*X0I
          VIJ(NA2+IBAS,NB2+JBAS) = RNTT(IBAS,JBAS)*X0I
C
        ENDDO
      ENDDO
C
C     BATCH FINISHED
      GOTO 3600
C
C     CONTINUATION POINT FOR MANY-CENTRE MATRIX ELEMENTS
3500  CONTINUE
C
C**********************************************************************C
C     GENERATE NUCLEAR OVERLAP MATRICES (MANY-CENTRE/ANALYTIC)         C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELS = TELS + DFLOAT(ICL2-ICL1)/RATE
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESL = TESL + DFLOAT(ICL2-ICL1)/RATE
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
      ELSE
        WRITE(6, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
      IF(NMDL(IZ).EQ.'POINT') THEN
C     POINT-NUCLEUS APPROXIMATION
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI  = EXL(IBAS,1)
            EJ  = EXL(JBAS,2)
            EIJ = EI+EJ
C
C           GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
            PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
            PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
            PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-EIJ*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER ALL {A,B,C}
            DO IAB=1,NTUV
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HALPH = HERMITE(EIJ,RPX,IA(IAB))
              HBETA = HERMITE(EIJ,RPY,IB(IAB))
              HGAMA = HERMITE(EIJ,RPZ,IC(IAB))
C
C             HGTF IS A PRODUCT OF THESE
              HABC = HALPH*HBETA*HGAMA*GSS
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + E11(M,IAB)*HABC
              TA2 = TA2 + E21(M,IAB)*HABC
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + TA2
C
C           OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
            VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
            VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
          ENDDO
        ENDDO
C
      ELSE
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI  = EXL(IBAS,1)
            EJ  = EXL(JBAS,2)
            EIJ = EI+EJ
C
C           GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
            PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
            PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
            PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           GAUSSIAN NUCLEAR CHARGE OVERLAP
            XI = XNUC(IZ,0)
            FC = FNUC(IZ,0)
C
C           INCLUDE NUCLEAR EXPONENT
            ESM = EIJ+XI
            ECP = EIJ*XI/ESM
            E12 = DSQRT(XI/ESM)
            E32 = E12*E12*E12
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C           LOOP OVER ALL {A,B,C}
            DO IAB=1,NTUV
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HALPH = HERMITE(ECP,RPX,IA(IAB))
              HBETA = HERMITE(ECP,RPY,IB(IAB))
              HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C             HGTF IS A PRODUCT OF THESE
              HABC = HALPH*HBETA*HGAMA*GSS
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + FC*E11(M,IAB)*HABC
              TA2 = TA2 + FC*E21(M,IAB)*HABC
C
            ENDDO
C
C           LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
            IF(NNUC(IZ).LE.0) GOTO 100
            DO IFT=1,NNUC(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XNUC(IZ,IFT)
              FC = FNUC(IZ,IFT)
C
C             INCLUDE NUCLEAR EXPONENT
              ESM = EIJ+XI
              ECP = EIJ*XI/ESM
              AMP =-0.5D0*XI/PI
C
C             GAUSSIAN COMPONENT OF HGTF
              GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C             INITIALISE TEMPORARY STORAGE ARRAYS
              TA1 = DCMPLX(0.0D0,0.0D0)
              TA2 = DCMPLX(0.0D0,0.0D0)
C
C             LOOP OVER ALL {A,B,C}
              DO IAB=1,NTUV
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(IAB))
                HBETA = HERMITE(ECP,RPY,IB(IAB))
                HGAMA = HERMITE(ECP,RPZ,IC(IAB))
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH2 = HERMITE(ECP,RPX,IA(IAB)+2)
                HBETA2 = HERMITE(ECP,RPY,IB(IAB)+2)
                HGAMA2 = HERMITE(ECP,RPZ,IC(IAB)+2)
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH2*HBETA *HGAMA *GSS
     &               + HALPH *HBETA2*HGAMA *GSS
     &               + HALPH *HBETA *HGAMA2*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + FC*E11(M,IAB)*HABC
                TA2 = TA2 + FC*E21(M,IAB)*HABC
C
              ENDDO
C
C             MATRIX ELEMENTS
              VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + AMP*TA1
              VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + AMP*TA2
C
            ENDDO
100         CONTINUE
C
C           OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
            VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
            VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
          ENDDO
        ENDDO
C
      ENDIF
C
3600  CONTINUE
C
C     END LOOP OVER CENTRES A AND B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VNCELEC(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC  EEEEEEEE LL       EEEEEEEE  CCCCCC     C
C    VV    VV NNN   NN CC    CC EE       LL       EE       CC    CC    C
C    VV    VV NNNN  NN CC       EE       LL       EE       CC          C
C    VV    VV NN NN NN CC       EEEEEE   LL       EEEEEE   CC          C
C     VV  VV  NN  NNNN CC       EE       LL       EE       CC          C
C      VVVV   NN   NNN CC    CC EE       LL       EE       CC    CC    C
C       VV    NN    NN  CCCCCC  EEEEEEEE LLLLLLLL EEEEEEEE  CCCCCC     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCELEC CONSTRUCTS A MATRIX OF (NORMALISED) NUCLEAR ELECTRIC FIELD  C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS: (μ,T|σ_Q.X/R^3|ν,T').      C
C -------------------------------------------------------------------- C
C  DFNOTE: THE ONE-CENTRE `QUADRATURE' OPTION TAKES A WHILE. TO AVOID  C
C          UNNECESSARY COMPUTATION TIME, REPORT THE FULL VALUE IN THE  C
C          CASE IX=1, AND NOTHING IN THE CASES IX=2 AND IX=3.          C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ      = NUCLEUS UNDER CONSIDERATION.                            C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z} ELECTRIC FIELD CARTESIAN INDEX.    C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
C
      DIMENSION IVCT(3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
      DIMENSION RNTT(MBS,MBS)
      DIMENSION EX2(MBS,2),LQ2(2),NBS2(2)
C
      COMPLEX*16 CONE,PHTT,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     COMPLEX FACTOR
      IF(ITT.EQ.1) THEN
        PHTT = DCMPLX(1.0D0,0.0D0)
      ELSEIF(ITT.EQ.2) THEN
        PHTT = CONE
      ELSEIF(ITT.EQ.3) THEN
        PHTT =-CONE
      ELSEIF(ITT.EQ.4) THEN
        PHTT = DCMPLX(1.0D0,0.0D0)
      ENDIF
C
C     TURN IX INTO A VECTOR
      CALL NCART(IVCT,IX)
C
C     INTEGRATION GRID DETAILS (WHEN QUADRATURE IS INVOKED)
      NLIN = 100
      NEXP = 5000
      RMAX = 25.0D0
      ELIN = RNUC(IZ)/DFLOAT(NLIN)
      EEXP = DLOG(RMAX/RNUC(IZ))/DFLOAT(NEXP)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE ELECTRIC FIELD OVERLAP MATRICES (ONE-CENTRE ONLY)       C
C**********************************************************************C
C
C     REASONS THAT QUADRATURE IS NOT NECESSARY
      IF(IZ.NE.ICNTA.OR.IZ.NE.ICNTB) GOTO 3500
      IF(NMDL(IZ).EQ.'POINT'.OR.NMDL(IZ).EQ.'GAUSS') GOTO 3500
C
C     CHEAT'S RECIPE: DUMP THE FULL INTEGRAL INTO THE IX= CASE
      IF(IX.NE.1) GOTO 3600
C
C     ATOM-CENTRED SELECTION RULES
      IF(KQN(1).NE.KQN(2)) GOTO 3600
      IF(MQN(1).NE.MQN(2)) GOTO 3600
C
C     KQN+LQN+1 IN EACH CASE
      T1 = DFLOAT(KQN(1)+LQN(1)+1)
      T2 = DFLOAT(KQN(2)+LQN(2)+1)
C
C     SMOOSH BASIS FUNCTION DETAILS INTO APPROPRIATE ARRAYS
      LQ2(1) = LQN(1)
      LQ2(2) = LQN(2)
      NBS2(1) = NBAS(1)
      NBS2(2) = NBAS(2)
      DO IBAS=1,NBS2(1)
        EX2(IBAS,1) = EXL(IBAS,1)
      ENDDO
      DO JBAS=1,NBS2(2)
        EX2(JBAS,2) = EXL(JBAS,2)
      ENDDO
      
C     RADIAL NORMALISATION FACTORS
      CALL RNORM1(RNTT,EX2,LQ2,NBS2,ITT)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      DO IBAS=1,NBAS(1)
        EI = EXL(IBAS,1)
        DO JBAS=1,NBAS(2)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         NUMERICALLY INTEGRATE (LINEAR GRID) FROM 0 TO RNUC
          XTT = 0.0D0
          DO N=0,NLIN
            RI  = ELIN*DFLOAT(N)
C           RADIAL FUNCTION FOR EXPONENT EI (FACTOR OF RI MISSING)
            IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
              RT1 = RI**(LQN(1)  )
            ELSEIF(ITT.EQ.3.OR.ITT.EQ.4) THEN
              IF(KQN(1).LT.0) THEN
                RT1 = RI**(LQN(1)  )*(  -2.0D0*EI*RI   )
              ELSEIF(KQN(1).GT.0) THEN
                RT1 = RI**(LQN(1)-1)*(T1-2.0D0*EI*RI*RI)
              ENDIF
            ENDIF
C           RADIAL FUNCTION FOR EXPONENT EJ (FACTOR OF RI MISSING)
            IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
              RT2 = RI**(LQN(2)  )
            ELSEIF(ITT.EQ.2.OR.ITT.EQ.4) THEN
              IF(KQN(2).LT.0) THEN
                RT2 = RI**(LQN(2)  )*(  -2.0D0*EJ*RI   )
              ELSEIF(KQN(2).GT.0) THEN
                RT2 = RI**(LQN(2)-1)*(T2-2.0D0*EJ*RI*RI)
              ENDIF
            ENDIF
            RSM = DEXP(-EIJ*RI*RI)
            EZR = ERNUCDNS(NMDL(IZ),IZ,RI)
            XTT = XTT + EXTINT11(RT1*RT2*RSM*EZR,N,NLIN)
          ENDDO
C         NUMERICALLY INTEGRATE (EXPONENTIAL GRID) FROM RNUC TO RMAX
          YTT = 0.0D0
          DO N=0,NEXP
            TI  = EEXP*DFLOAT(N)
            RI  = RNUC(IZ)*DEXP(TI)
C           RADIAL FUNCTION FOR EXPONENT EI (FACTOR OF RI MISSING)
            IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
              RT1 = RI**(LQN(1)  )
            ELSEIF(ITT.EQ.3.OR.ITT.EQ.4) THEN
              IF(KQN(1).LT.0) THEN
                RT1 = RI**(LQN(1)  )*(  -2.0D0*EI*RI   )
              ELSEIF(KQN(1).GT.0) THEN
                RT1 = RI**(LQN(1)-1)*(T1-2.0D0*EI*RI*RI)
              ENDIF
            ENDIF
C           RADIAL FUNCTION FOR EXPONENT EJ (FACTOR OF RI MISSING)
            IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
              RT2 = RI**(LQN(2)  )
            ELSEIF(ITT.EQ.2.OR.ITT.EQ.4) THEN
              IF(KQN(2).LT.0) THEN
                RT2 = RI**(LQN(2)  )*(  -2.0D0*EJ*RI   )
              ELSEIF(KQN(2).GT.0) THEN
                RT2 = RI**(LQN(2)-1)*(T2-2.0D0*EJ*RI*RI)
              ENDIF
            ENDIF
            RSM = RI*DEXP(-EIJ*RI*RI)
            EZR = ERNUCDNS(NMDL(IZ),IZ,RI)
            YTT = YTT + EXTINT11(RT1*RT2*RSM*EZR,N,NEXP)
          ENDDO
          UTT =-5.0D0*RNTT(IBAS,JBAS)*(ELIN*XTT + EEXP*YTT)/299376.0D0
C
C         CONTRIBUTION TO MOLECULAR MATRIX ELEMENT
          VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + UTT
          VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + UTT
C
        ENDDO
      ENDDO
C
C     BATCH FINISHED
      GOTO 3600
C
C     CONTINUATION POINT FOR MANY-CENTRE MATRIX ELEMENTS
3500  CONTINUE
C
C**********************************************************************C
C     GENERATE ELECTRIC FIELD OVERLAP MATRICES (MANY-CENTRE/ANALYTIC)  C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TELS = TELS + DFLOAT(ICL2-ICL1)/RATE
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESL = TESL + DFLOAT(ICL2-ICL1)/RATE
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL SYSTEM_CLOCK(ICL2)
        TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
      ELSE
        WRITE(6, *) 'In VNCELEC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCELEC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     NUCLEAR COORDINATES
      CX = BXYZ(1,IZ)
      CY = BXYZ(2,IZ)
      CZ = BXYZ(3,IZ)
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M   = M+1
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
          PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
          CP(M,1) = CX-PX
          CP(M,2) = CY-PY
          CP(M,3) = CZ-PZ
        ENDDO
      ENDDO
C
      IF(NMDL(IZ).EQ.'POINT') THEN
C     POINT-NUCLEUS APPROXIMATION
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           POINT-NUCLEUS EFFECTIVE PARAMETERS
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
        CALL SYSTEM_CLOCK(ICL2)
C
C       ADD TO RELEVANT TIME COUNTER
        IF(ITT.EQ.1) THEN
          TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
        ELSEIF(ITT.EQ.2) THEN
          TRLS = TRLS + DFLOAT(ICL2-ICL1)/RATE
        ELSEIF(ITT.EQ.3) THEN
          TRSL = TRSL + DFLOAT(ICL2-ICL1)/RATE
        ELSEIF(ITT.EQ.4) THEN
          TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
        ENDIF
C
C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE SUM COUNTERS FOR FINITE EXPANSION
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FINITE EXPANSION ADDRESSES
            DO IAB=1,NTUV
C
C             PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
              IT = IA(IAB)
              IU = IB(IAB)
              IV = IC(IAB)
C
C             ADD CARTESTIAN COMPONENT IX TO OVERALL ADDRESS (R-INTS)
              ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
C
C             DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
              TA1 = TA1 - E11(M,IAB)*RC(M,ITV1)
              TA2 = TA2 - E21(M,IAB)*RC(M,ITV1)
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = PHTT*PNC(M)*TA1
            VIJ(NA2+IBAS,NB1+JBAS) = PHTT*PNC(M)*TA2
            VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
            VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
          ENDDO
        ENDDO
C
      ELSE
C     FINITE NUCLEAR CHARGE DISTRIBUTIONS
C
C       GAUSSIAN CHARGE MODEL COMPONENTS
        XI = XNUC(IZ,0)
        FC = FNUC(IZ,0)
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
            ESM    = EIJ+XI
            APH(M) = EIJ*XI/ESM
            PNC(M) = 2.0D0*PI*FC*DSQRT(XI/ESM)/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL SYSTEM_CLOCK(ICL1,RATE)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
        CALL SYSTEM_CLOCK(ICL2)
C
C       ADD TO RELEVANT TIME COUNTER
        IF(ITT.EQ.1) THEN
          TRLL = TRLL + DFLOAT(ICL2-ICL1)/RATE
        ELSEIF(ITT.EQ.2) THEN
          TRLS = TRLS + DFLOAT(ICL2-ICL1)/RATE
        ELSEIF(ITT.EQ.3) THEN
          TRSL = TRSL + DFLOAT(ICL2-ICL1)/RATE
        ELSEIF(ITT.EQ.4) THEN
          TRSS = TRSS + DFLOAT(ICL2-ICL1)/RATE
        ENDIF
C
C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE SUM COUNTERS FOR FINITE EXPANSION
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FINITE EXPANSION ADDRESSES
            DO IAB=1,NTUV
C
C             PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
              IT = IA(IAB)
              IU = IB(IAB)
              IV = IC(IAB)
C
C             CARTESTIAN ADDERSS OF THIS R-INT TERM
              ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
C
C             DETERMINE FINITE SUM FOR THIS MATRIX ELEMENT
              TA1 = TA1 - E11(M,IAB)*RC(M,ITV1)
              TA2 = TA2 - E21(M,IAB)*RC(M,ITV1)
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS)
     &                                              + PHTT*PNC(M)*TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS)
     &                                              + PHTT*PNC(M)*TA2
C
          ENDDO
        ENDDO
C
C       LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
        IF(NNUC(IZ).LE.0) GOTO 100
        DO IFT=1,NNUC(IZ)
C
C         GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
          XI = XNUC(IZ,IFT)
          FC = FNUC(IZ,IFT)
C
C         INCLUDE NUCLEAR EXPONENT
          ESM = EIJ+XI
          ECP = EIJ*XI/ESM
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER ALL {A,B,C}
          DO IAB=1,NTUV
C
C           CARTESIAN HERMITE POLYNOMIAL VALUES
            HALPH = HERMITE(ECP,RPX,IA(IAB)+IVCT(1))
            HBETA = HERMITE(ECP,RPY,IB(IAB)+IVCT(2))
            HGAMA = HERMITE(ECP,RPZ,IC(IAB)+IVCT(3))
C
C           HGTF IS A PRODUCT OF THESE
            HABC = HALPH*HBETA*HGAMA*GSS
C
C           MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
            TA1 = TA1 + FC*E11(M,IAB)*HABC
            TA2 = TA2 + FC*E21(M,IAB)*HABC
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + PHTT*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + PHTT*TA2
C
        ENDDO
100     CONTINUE
C
C       FINISH MATRIX ELEMENT CONSTRUCTION BY MQN SYMMETRY
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
            VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
          ENDDO
        ENDDO
C
      ENDIF
C
3600  CONTINUE
C
C     END LOOP OVER CENTRES A AND B
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] FIELDS: CALCULATE AMPLITUDES, FIELDS AND POTENTIALS.           C
C   [B] DGNUMAP: EXPORT AND PLOT A SQUARE ARRAY OF DOUBLES.            C
C   [C] ZGNUMAP: EXPORT AND PLOT A SQUARE ARRAY OF COMPLEX DOUBLES.    C
C   [D] ORBCOEF: PRINT LIST OF EXPANSION COEFFICIENTS FOR AN ORBITAL.  C
C   [E] AMPLTDE: PLOT A DIRAC SPINOR AMPLITUDE ALONG ONE DIRECTION.    C
C   [F] DENSMAP: HEAT MAP OF ELECTRONIC CHARGE DENSITY (ON A 2D GRID). C
C   [G] J4CRRNT: PLOT 4-CURRENT ALONG ONE DIRECTION.                   C
C   [H] POTENTL: PLOT 4-POTENTIAL ALONG ONE DIRECTION.                 C
C   [I] ELCTRCF: PLOT E FIELD ALONG ONE DIRECTION.                     C
C   [J] MAGNTCF: PLOT B FIELD ALONG ONE DIRECTION.                     C
C   [K] FRMFCTR: PLOT THE ELECTRON SCATTERING FORM FACTOR.             C
C   [L] GNULINE: GENERATE A GNUPLOT LINE PLOT MAKE FILE FOR DATA SET.  C
C   [M] GNUDENS: GENERATE A GNUPLOT MATRIX PLOT MAKE FILE FOR DENSITY. C
C   [N] CLEBSCH: CLEBSCH-GORDAN COEFFICIENT FOR KQN,MQN.               C
C**********************************************************************C
C
C
      SUBROUTINE GNULINE(XOUT,TITLE,XAXIS,YAXIS,NDAT,KEY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG  NN    NN UU    UU LL       IIII NN    NN EEEEEEEE      C
C      GG    GG NNN   NN UU    UU LL        II  NNN   NN EE            C
C      GG       NNNN  NN UU    UU LL        II  NNNN  NN EE            C
C      GG       NN NN NN UU    UU LL        II  NN NN NN EEEEEE        C
C      GG   GGG NN  NNNN UU    UU LL        II  NN  NNNN EE            C
C      GG    GG NN   NNN UU    UU LL        II  NN   NNN EE            C
C       GGGGGG  NN    NN  UUUUUU  LLLLLLLL IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNULINE IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A SET OF DATA POINTS.                                           C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(NDAT)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot raw data'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ENDIF
      ENDDO
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf enhance font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/plotstyles.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "'//TRIM(XAXIS)//'"'
      WRITE(9,'(A)') 'set ylabel "'//TRIM(YAXIS)//'"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting range'
      WRITE(9,'(A)') 'xmin = GPVAL_X_MIN'
      WRITE(9,'(A)') 'xmax = GPVAL_X_MAX'
      WRITE(9,'(A)') 'ymin = GPVAL_Y_MIN'
      WRITE(9,'(A)') 'ymax = GPVAL_Y_MAX'
      WRITE(9,'(A)') 'set xrange [xmin:xmax] noreverse nowriteback'
      WRITE(9,'(A)') 'set yrange [ymin:ymax] noreverse nowriteback'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ENDIF
      ENDDO
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END
C
C
      SUBROUTINE GNUDENS(XOUT,TITLE,NHRZ,NVTC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     GGGGGG  NN    NN UU    UU DDDDDDD  EEEEEEEE NN    NN  SSSSSS     C
C    GG    GG NNN   NN UU    UU DD    DD EE       NNN   NN SS    SS    C
C    GG       NNNN  NN UU    UU DD    DD EE       NNNN  NN SS          C
C    GG       NN NN NN UU    UU DD    DD EEEEEE   NN NN NN  SSSSSS     C
C    GG   GGG NN  NNNN UU    UU DD    DD EE       NN  NNNN       SS    C
C    GG    GG NN   NNN UU    UU DD    DD EE       NN   NNN SS    SS    C
C     GGGGGG  NN    NN  UUUUUU  DDDDDDD  EEEEEEEE NN    NN  SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNUDENS IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A DENSITY MAP.                                                  C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE
C
      RATIO = DFLOAT(NVTC)/DFLOAT(NHRZ)
      SZHRZ = 10.0D0
      SZVTC = 10.0D0*RATIO
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A,F5.2)') 'set size ratio ',RATIO
      WRITE(9,'(A,F5.2,A,F5.2,A)') 'set terminal pdf size ',SZHRZ,'cm,',
     &                                     SZVTC,'cm font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/pals/jet.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "NHRZ"'
      WRITE(9,'(A)') 'set ylabel "NVTC"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting options'
      WRITE(9,'(A)') 'set view map'
      WRITE(9,'(A)') 'set palette model RGB'
      WRITE(9,'(A)') 'set palette defined'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2)') 'splot "plots/'//TRIM(XOUT)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] RMAKE: BATCH OF R-INTEGRALS FOR BASIS FUNCTION OVERLAPS.       C
C   [B] FUNFM: LIST OF BOYS INTEGRALS FOR USE IN RMAKE.                C
C   [C] BOYSGEN: OUTPUT DATA FILE WITH FAMILY OF BOYS FUNCTIONS.       C
C   [D] HGTFS: BATCH OF HGTF AMPLITUDES EVALUATED AT (X,Y,Z).          C
C   [E] HERMITE: EVALUATION OF H_I (P,X) BY RECURRENCE.                C
C   [F] HTFRMS: BATCH OF HGTF FOURIER TRANSFORMS AT (QX,QY,QZ).        C
C**********************************************************************C
C
C
      SUBROUTINE RMAKE(RC,QP,APH,MAXCD,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           RRRRRRR  MM       MM    AA    KK    KK EEEEEEEE            C
C           RR    RR MMM     MMM   AAAA   KK   KK  EE                  C
C           RR    RR MMMM   MMMM  AA  AA  KK  KK   EE                  C
C           RR    RR MM MM MM MM AA    AA KKKKK    EEEEEE              C
C           RRRRRRR  MM  MMM  MM AAAAAAAA KK  KK   EE                  C
C           RR    RR MM   M   MM AA    AA KK   KK  EE                  C
C           RR    RR MM       MM AA    AA KK    KK EEEEEEEE            C
C                                                                      C
C -------------------------------------------------------------------- C
C  RMAKE GENERATES A COMPLETE SET OF R-INTEGRALS REQUIRED IN THE       C
C  FINITE SUM REPRESENTATION OF A MULTI-CENTRE GAUSSIAN OVERLAP.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FS(MB2,ML4),APH(MB2),QP(MB2,3),RC(MB2,MRC),RC2(MB2,MRC)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),F4(MB2,ML4)
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2),
     &          I1(MB2),I2(MB2),I3(MB2),I4(MB2)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     VALUES WHICH DETERMINE EVALUATION METHOD
      EPSZR = 1.0D-11
      EPSPL = 1.7D+01
      EPSAS = 3.0D+01
C
C**********************************************************************C
C     THE FIRST STEP OF THIS ROUTINE IS TO EVALUATE THE REQUIRED       C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
C     INITIALISE COUNTERS FOR EVALUATION METHODS IN BATCH
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
C
C     FOR EACH PAIR OF BASIS FUNCTIONS (EXPONENTS EI AND EJ IN 'M'),
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      DO M=1,MAXCD
C
        X = QP(M,1)*QP(M,1) + QP(M,2)*QP(M,2) + QP(M,3)*QP(M,3)
        X = X*APH(M)
C
C       CASE 1: IF X=0.0D0 USE EXACT FORMULA
        IF(X.LE.EPSZR) THEN
C
          N1     = N1+1
          X1(N1) = X
          I1(N1) = M
C
C       CASE 2: IF X<EPSPL USE A POLYNOMIAL EXPANSION
        ELSEIF(X.GT.EPSZR.AND.X.LE.EPSPL) THEN
C
          N2     = N2+1
          X2(N2) = X
          I2(N2) = M
C
C       CASE 3: IF X<EPSAS USE ASYMPTOIC FORMULA WITH EXPONENTIAL
        ELSEIF(X.GT.EPSPL.AND.X.LE.EPSAS) THEN
C
          N3     = N3+1
          X3(N3) = X
          I3(N3) = M
C
C       CASE 4: IF X>EPSAS USE ASYMPTOIC FORMULA WITHOUT EXPONENTIAL
        ELSE
C
          N4     = N4+1
          X4(N4) = X
          I4(N4) = M
C
        ENDIF
C
      ENDDO
C
C     EVALUATE THE BOYS INTEGRALS -- A BATCH FOR EACH ITYPE
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS X=0.0D0.
C     THE VALUE OF THIS FUNCTION IS 2N+1 (DONE IN FUNFM).
      IF(N1.GT.0) THEN
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO K=1,LAM+1
          DO M=1,N1
            FS(I1(M),K) = F1(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=EPSPL.
C     EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C     AND RECURRENCE IN DIRECTION OF DECREASING M.
      IF(N2.GT.0) THEN
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO K=1,LAM+1
          DO M=1,N2
            FS(I2(M),K) = F2(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=EPSAS.
C     EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      IF(N3.GT.0) THEN
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO K=1,LAM+1
          DO M=1,N3
            FS(I3(M),K) = F3(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 4: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=EPSAS.
C     EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      IF(N4.GT.0) THEN
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO K=1,LAM+1
          DO M=1,N4
            FS(I4(M),K) = F4(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     WITH THE FULL SET OF BOYS' INTEGRALS WE NOW APPLY RECURRENCE     C
C     RELATIONS TO F_N (X) AND EVALUATE THE R-INTEGRALS.               C
C**********************************************************************C
C
C     CONSTRUCT TOP LEVEL (FOR MAXIMUM LAM VALUE)
      DO M=1,MAXCD
        RC(M,1)= (-2.0D0*APH(M))**LAM
        RC(M,1) = RC(M,1)*FS(M,LAM+1)
      ENDDO
C
C     MINIMUM LEVEL ILV BASED ON LAM VALUE
      IF(MOD(LAM,2).EQ.0) THEN
       ITUVMIN = 1
      ELSE
       ITUVMIN = 2
      ENDIF
C
C     INITIALISE ITUV COUNTER (RELATES TO # CARTESIAN INDICES FOR lam)
      ITUV=-1
C
C     MAIN LOOP: LEVEL 'ILV' STARTING AT LAM-1 AND WORKING BACKWARDS
      DO ILV=LAM-1,ITUVMIN,-2
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU = DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV = DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
        DO M=1,MAXCD
          RC2(M,1) = (-2.0D0*APH(M))**ILV
          RC2(M,1) = RC2(M,1)*FS(M,ILV+1)
        ENDDO
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU = DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV = DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXCD
                 RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                 RC(M,N2) =-QP(M,2)*RC2(M,K1)
                 RC(M,N3) =-QP(M,3)*RC2(M,K1)
               ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXCD
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXCD
          RC(M,1) = (-2.0D0*APH(M))**(ILV-1)
          RC(M,1) = RC(M,1)*FS(M,ILV)
        ENDDO
C
      ENDDO
C
C
C     AN ADDITIONAL LOOP OVER ADDRESSES (WHEN LAM IS ODD)
      IF(MOD(LAM,2).EQ.1) THEN
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXCD
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXCD
          RC2(M,1) = FS(M,1)
        ENDDO
C
C       MOVE THE RC2 ARRAY INTO RC
C
        ITMAX = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO IT=1,ITMAX
          DO M=1,MAXCD
            RC(M,IT) = RC2(M,IT)
          ENDDO
        ENDDO
C
C     END IF STATEMENT FOR THE ODD LAM CASE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FUNFM(FM,T,N,LAM,ITYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           FFFFFFFF UU    UU NN    NN FFFFFFFF MM       MM            C
C           FF       UU    UU NNN   NN FF       MMM     MMM            C
C           FF       UU    UU NNNN  NN FF       MMMM   MMMM            C
C           FFFFFF   UU    UU NN NN NN FFFFFF   MM MM MM MM            C
C           FF       UU    UU NN  NNNN FF       MM  MMM  MM            C
C           FF       UU    UU NN   NNN FF       MM   M   MM            C
C           FF        UUUUUU  NN    NN FF       MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  FUNFM EVALUATES INTEGRAL [INT_{0}^{1} U^{2M} EXP(-T*U^{2}) dU]      C
C  FOR VARIABLE T > 0 FOR ALL ORDERS 0 < M < LAM.                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITYPE = 1 - SPECIAL CASE X = 0.0D0.                               C
C  ▶ ITYPE = 2 - POWER SERIES AND REVERSE RECURRENCE.                  C
C                (60 TERMS WILL BE USED, SO USE MUST SUPPLY A VALUE    C
C                 APPROPRIATE TO THE MAX VALUE OF X IN BATCH).         C
C  ▶ ITYPE = 3 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C  ▶ ITYPE = 4 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C                ALL TERMS DEPENDING ON EXP(-X) ARE OMITTED TO AVOID   C
C                NUMERICAL UNDERFLOW PROBLEMS.                         C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FM(MB2,ML4),T(MB2),TLAM(MB2),TT2(MB2),
     &          TXP(MB2),TRT(MB2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      DATA A0,B0/4.994501191201870D-1,4.551838436668326D-1/
C
C**********************************************************************C
C     ITYPE = 1: SPECIAL CASE FOR T = 0.0D0                            C
C**********************************************************************C
C
      IF(ITYPE.EQ.1) THEN
C
        DO K=1,LAM+1
          MVAL  = K-1
          VALUE = 1.0D0/DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,K) = VALUE
          ENDDO
        ENDDO
        RETURN
C
C**********************************************************************C
C     ITYPE = 2: POWER SERIES EVALUATION                               C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.2) THEN
C
C       INITIALISE THE POWER SERIES FOR M = LAM
        DO M=1,N
          TXP(M)      = DEXP(-T(M))
          TT2(M)      = 2.0D0*T(M)
          TLAM(M)     = 1.0D0
          FM(M,LAM+1) = 1.0D0
        ENDDO
C
C       LOOP OVER TERMS IN THE POWER SERIES
        DO K=1,60
          DLAM = DFLOAT(2*LAM+2*K+1)
          DO M=1,N
            TLAM(M)     = TLAM(M)*TT2(M)/DLAM
            FM(M,LAM+1) = FM(M,LAM+1) + TLAM(M)
          ENDDO
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DEN = DFLOAT(2*LAM+1)
        DO M=1,N
          FM(M,LAM+1) = FM(M,LAM+1)*TXP(M)/DEN
        ENDDO
C
C       NOW COMPLETE TABLE BY BACKWARDS RECURRENCE
        DO I=1,LAM
          MIND  = LAM-I+1
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND) = (TT2(M)*FM(M,MIND+1) + TXP(M))/COEFF
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 3: ASYMPTOTIC EXPANSION WITH EXPONENTIAL ARGUMENT.       C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.3) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TXP(M) = DEXP(-T(M))
          TT2(M) = 2.0D0*T(M)
          TRT(M) = DSQRT(T(M))
        ENDDO
C
C       SEED VALUES
        DO M=1,N
          FM(M,1) = A0/(B0+T(M))
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DO M=1,N
          FM(M,1) = 0.5D0*PI12/TRT(M) - TXP(M)*FM(M,1)
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = (COEFF*FM(M,MIND) - TXP(M))/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 4: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT         C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.4) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TT2(M)  = 2.0D0*T(M)
          FM(M,1) = 0.5D0*PI12/DSQRT(T(M))
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = COEFF*FM(M,MIND)/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE OUT OF RANGE: INVALID INPUT TO FUNFM                       C
C**********************************************************************C
C
      ELSE
91      FORMAT(2X,'In FUNFM: invalid type (must be 1-4)',I4)
        WRITE(6,91) ITYPE
        WRITE(7,91) ITYPE
        STOP
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BOYSGEN(LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB   OOOOOO  YY    YY  SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C    BB    BB OO    OO YY    YY SS    SS GG    GG EE       NNN   NN    C
C    BB    BB OO    OO  YY  YY  SS       GG       EE       NNNN  NN    C
C    BBBBBBB  OO    OO   YYYY    SSSSSS  GG       EEEEEE   NN NN NN    C
C    BB    BB OO    OO    YY          SS GG   GGG EE       NN  NNNN    C
C    BB    BB OO    OO    YY    SS    SS GG    GG EE       NN   NNN    C
C    BBBBBBB   OOOOOO     YY     SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  BOYSGEN PRODUCES A DATA FILE WHICH CONTAINS A FAMILY OF BOYS        C
C  FUNCTIONS OVER A SPECIFIED REGION, GIVEN A MAXIMUM FAMILY           C
C  PARAMETER DETERMINED BY LAM.                                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),
     &          F4(MB2,ML4),FS(MB2,ML4)
C
C     EVALUATION PARAMETERS
      NTOT = 400
      XMIN = 0.00D0
      XMAX = 4.00D1
      HSTP = (XMAX-XMIN)/NTOT
C
C     VALUES WHICH DETERMINE EVALUATION METHOD
      EPSZR = 1.0D-11
      EPSPL = 1.7D+01
      EPSAS = 3.0D+01
C
C**********************************************************************C
C     THE FIRST STEP OF THIS SUBROUTINE IS TO EVALUATE THE REQUIRED    C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      OPEN(UNIT=8,FILE='plots/boysfunction.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO NX=0,NTOT
C
      X = XMIN + HSTP*NX
C
C     CASE 0: ARGUMENT OF THE BOYS FUNCTION IS X = 0.
C             THE VALUE OF THIS FUNCTION IS (2N+1).
      IF(X.LE.EPSZR) THEN
C
        N1     = 1
        X1(N1) = X
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO JJ=1,LAM+1
          FS(N1,JJ) = F1(N1,JJ)
        ENDDO
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.
C             EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C             AND RECURRENCE IN DIRECTION OF DECREASING M.
      ELSEIF(X.GT.EPSZR.AND.X.LE.EPSPL) THEN
C
        N2     = 1
        X2(N2) = X
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO JJ=1,LAM+1
          FS(N2,JJ) = F2(N2,JJ)
        ENDDO
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      ELSEIF(X.GT.EPSPL.AND.X.LE.EPSAS) THEN
C
        N3     = 1
        X3(N3) = X
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO JJ=1,LAM+1
          FS(N3,JJ) = F3(N3,JJ)
        ENDDO
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      ELSE
C
        N4     = 1
        X4(N4) = X
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO JJ=1,LAM+1
          FS(N4,JJ) = F4(N4,JJ)
        ENDDO
C
      ENDIF
C
      WRITE(8, *) X,(FS(1,L),L=1,LAM+1)
C
      ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH  GGGGGG TTTTTTTT FFFFFFFF SSSSSS               C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH GG         TT    FF      SS                    C
C              HHHHHHHH GG         TT    FFFFFF   SSSSSS               C
C              HH    HH GG   GGG   TT    FF            SS              C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH  GGGGGG    TT    FF       SSSSSS               C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FUNCTIONS EVALUATED AT A SET OF    C
C  COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM TO       C
C  TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A        C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXL(MBS,2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXL(IBAS,1)+EXL(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          RPX = XYZEVAL(1)-PX
          RPY = XYZEVAL(2)-PY
          RPZ = XYZEVAL(3)-PZ
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-PAB*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            HALPH = HERMITE(PAB,RPX,IA(ITUV))
            HBETA = HERMITE(PAB,RPY,IB(ITUV))
            HGAMA = HERMITE(PAB,RPZ,IC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = HALPH*HBETA*HGAMA*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION HERMITE(P,X,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    HH    HH EEEEEEEE RRRRRRR  MM       MM IIII TTTTTTTT EEEEEEEE     C
C    HH    HH EE       RR    RR MMM     MMM  II     TT    EE           C
C    HH    HH EE       RR    RR MMMM   MMMM  II     TT    EE           C
C    HHHHHHHH EEEEEE   RR    RR MM MM MM MM  II     TT    EEEEEE       C
C    HH    HH EE       RRRRRRR  MM  MMM  MM  II     TT    EE           C
C    HH    HH EE       RR    RR MM   M   MM  II     TT    EE           C
C    HH    HH EEEEEEEE RR    RR MM       MM IIII    TT    EEEEEEEE     C
C                                                                      C
C -------------------------------------------------------------------- C
C  HERMITE EVALUATES HERMITE POLYNOMIAL H_I (P,X) BY RECURRENCE.       C
C**********************************************************************C
C
      IF(I.LT.0) THEN
        WRITE(6, *) 'In HERMITE: index less than zero. I = ',I
        WRITE(7, *) 'In HERMITE: index less than zero. I = ',I
        STOP
      ENDIF
C
      IF(I.GT.40) THEN
        WRITE(6, *) 'In HERMITE: index greater than 40. I = ',I
        WRITE(7, *) 'In HERMITE: index greater than 40. I = ',I
        STOP
      ENDIF
C
C     NEED FIRST TWO VALUES TO ESTABLISH RECURRENCE RELATION
      TEMP1 = 1.0D0
      TEMP2 = 2.0D0*P*X
C
      IF(I.EQ.0) THEN
        HERMITE = TEMP1
      ELSEIF(I.EQ.1) THEN
        HERMITE = TEMP2
      ELSEIF(I.GT.1) THEN
        DO N=2,I
          TEMP3 = 2.0D0*P*(X*TEMP2 - (N-1)*TEMP1)
          TEMP1 = TEMP2
          TEMP2 = TEMP3
        ENDDO
        HERMITE = TEMP2
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE HTFRMS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       HH    HH TTTTTTTT FFFFFFFF RRRRRRR  MM       MM  SSSSSS        C
C       HH    HH    TT    FF       RR    RR MMM     MMM SS    SS       C
C       HH    HH    TT    FF       RR    RR MMMM   MMMM SS             C
C       HHHHHHHH    TT    FFFFFF   RR    RR MM MM MM MM  SSSSSS        C
C       HH    HH    TT    FF       RRRRRRR  MM  MMM  MM       SS       C
C       HH    HH    TT    FF       RR    RR MM   M   MM SS    SS       C
C       HH    HH    TT    FF       RR    RR MM       MM  SSSSSS        C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FOURIER TRANSFORMS EVALUATED AT A  C
C  SET OF COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM   C
C  TO TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A     C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMPLEX*16 CONE,PHS,PHSQP
      COMPLEX*16 HABC(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXL(IBAS,1)+EXL(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          QPX = XYZEVAL(1)*PX
          QPY = XYZEVAL(2)*PY
          QPZ = XYZEVAL(3)*PZ
C
C         DOT PRODUCT FACTOR (COMPLEX WITH UNIT MAGNITUDE)
          QPVEC = QPX+QPY+QPZ
C         PHSQP = DEXP(-CONE*QPVEC)
          PHSQP = DCOS(QPVEC) + CONE*DSIN(QPVEC)
C
C         GAUSSIAN COMPONENT OF HTFRM
          QX2 = XYZEVAL(1)*XYZEVAL(1)
          QY2 = XYZEVAL(2)*XYZEVAL(2)
          QZ2 = XYZEVAL(3)*XYZEVAL(3)
          GSS = DEXP(-0.75D0*(QX2*QX2+QY2*QY2+QZ2*QZ2)/PAB)
C
C         INTEGRAL TRANSFORM TERM
          PRT = PAB*DSQRT(PAB)
          SCL = PI*PI12/PRT
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           TEST TO DETERMINE MULTIPLICATIVE FACTOR
            IF(MOD(ILAM(ITUV),4).EQ.0) THEN
              PHS = DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.1) THEN
              PHS =-DCMPLX(0.0D0,1.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.2) THEN
              PHS =-DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.3) THEN
              PHS = DCMPLX(0.0D0,1.0D0)
            ENDIF
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            QXA = XYZEVAL(1)**(IA(ITUV))
            QXB = XYZEVAL(2)**(IB(ITUV))
            QXC = XYZEVAL(3)**(IC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = SCL*PHS*QXA*QXB*QXC*PHSQP*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [12] EQ-COEFFS: BASIS FUNCTION OVERLAP SPIN-STRUCTURE FACTORS.      C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] EQSAVE: MAIN ROUTINE FOR BUILDING A GLOBAL FILE OF EQ-COEFFS.  C
C   [B] E0LLGN: GENERATE FULL SET OF E0LL COEFFICIENTS AND SAVE.       C
C   [C] E0SSGN: GENERATE FULL SET OF E0SS COEFFICIENTS AND SAVE.       C
C   [D] EILSGN: GENERATE FULL SET OF EILS COEFFICIENTS AND SAVE.       C
C   [E] EISLGN: GENERATE FULL SET OF EISL COEFFICIENTS AND SAVE.       C
C -------------------------------------------------------------------- C
C   [A] EQLLMK: GENERATE A BATCH OF EQLL COEFFICIENTS: (--) AND (+-).  C
C   [B] EQLSMK: GENERATE A BATCH OF EQLS COEFFICIENTS: (--) AND (+-).  C
C   [C] EQSLMK: GENERATE A BATCH OF EQSL COEFFICIENTS: (--) AND (+-).  C
C   [D] EQSSMK: GENERATE A BATCH OF EQSS COEFFICIENTS: (--) AND (+-).  C
C   [E] EILSB3: GENERATE A VECTOR BATCH OF EILS COEFFICIENTS FOR BREIT.C
C   [F] EISLB3: GENERATE A VECTOR BATCH OF EISL COEFFICIENTS FOR BREIT.C
C   [G] EQLL: A RAW BLOCK OF EQLL COEFFICIENTS FOR EQLLMK.             C
C   [H] EQLS: A RAW BLOCK OF EQLS COEFFICIENTS FOR EQLSMK.             C
C   [I] EQSL: A RAW BLOCK OF EQSL COEFFICIENTS FOR EQSLMK.             C
C   [J] EQSS: A RAW BLOCK OF EQSS COEFFICIENTS FOR EQSSMK.             C
C   [K] ESGTF: SET OF ES-COEFFS OVER SPHERICAL HARMONICS AND HGTFS.    C
C   [L] EVRS: EXPANSION COEFFS IN HGTF OVERLAPS, CALLED IN ESGTF.      C
C   [M] ESTEPLM: SIMULTANEOUS INCREASE IN (L,M) FOR USE IN EVRS.       C
C   [N] ESTEPL: INCREMENT IN L FOR USE IN EVRS.                        C
C   [O] ESTEPN: INCREMENT IN N FOR USE IN EVRS.                        C
C -------------------------------------------------------------------- C
C   [A] RNORM1: A BLOCK OF TT' NORMALISATION COEFFS.                   C
C   [B] DNORM: NORM FOR A REAL OR COMPLEX PART OF EQ-COEFF LIST.       C
C**********************************************************************C
C
C
      SUBROUTINE EQSAVE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        EEEEEEEE  QQQQQQ    SSSSSS     AA    VV    VV EEEEEEEE        C
C        EE       QQ    QQ  SS    SS   AAAA   VV    VV EE              C
C        EE      QQ      QQ SS        AA  AA  VV    VV EE              C
C        EEEEEE  QQ      QQ  SSSSSS  AA    AA VV    VV EEEEEE          C
C        EE      QQ      QQ       SS AAAAAAAA  VV  VV  EE              C
C        EE       QQ    QQ  SS    SS AA    AA   VVVV   EE              C
C        EEEEEEEE  QQQQQQ QQ SSSSSS  AA    AA    VV    EEEEEEEE        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSAVE CONSTRUCTS A SET OF COMMON ARRAYS FOR ALL REQUIRED EQTT'     C
C  COEFFICIENTS IN A CALCULATION THAT RESTS WITHIN QED.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION NTUV(0:MKP+1,4),NTRM(0:MKP+1,4),NWRD(0:MKP+1,4),
     &          SPCE(0:MKP+1,4)
      DIMENSION NTUVT(4),NTRMT(4),NWRDT(4),SPCET(4)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     MAXIMUM REQUIRED COMPONENT TYPES
      IF(HMLT.EQ.'NORL') THEN
        ITTMAX = 1
      ELSEIF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') THEN
        ITTMAX = 2
      ELSEIF(TREE.EQ.'HFSCF'.AND.INTSYM) THEN
        ITTMAX = 3
      ELSE
        ITTMAX = 4
      ENDIF
C
C**********************************************************************C
C     LOOP OVER FOCK BLOCK AND COUNT ALL REQUIRED EQ-WORDS.            C
C**********************************************************************C
C
C     INITIALISE MAXIMUM LAMBDA
      LAMMX = 0
C
C     INITIALISE TOTAL COEFFICIENT COUNTERS
      DO ITT=1,4
        DO LAM=0,MKP+1
          NTUV(LAM,ITT) = 0
          NTRM(LAM,ITT) = 0
          NWRD(LAM,ITT) = 0
          SPCE(LAM,ITT) = 0.0D0
        ENDDO
        NTUVT(ITT) = 0
        NTRMT(ITT) = 0
        NWRDT(ITT) = 0
        SPCET(ITT) = 0.0D0
      ENDDO
C
C     LOOP OVER CENTRES A AND B
      DO ICNTA=1,NCNT
        DO ICNTB=1,NCNT
C
C         LOOP OVER KQNA VALUES
          DO KA=1,NKAP(ICNTA)
C
C           QUANTUM NUMBERS FOR BLOCK A
            IF(KAPA(KA,ICNTA).LT.0) THEN
              LQNA =-KAPA(KA,ICNTA)-1
            ELSE
              LQNA = KAPA(KA,ICNTA)
            ENDIF
            NBASA = NFNC(LQNA,ICNTA)
C
C           LOOP OVER KQNB VALUES
            DO KB=1,NKAP(ICNTB)
C
C             QUANTUM NUMBERS FOR BLOCK B
              IF(KAPA(KB,ICNTB).LT.0) THEN
                LQNB =-KAPA(KB,ICNTB)-1
              ELSE
                LQNB = KAPA(KB,ICNTB)
              ENDIF
              NBASB = NFNC(LQNB,ICNTB)
C
C             LOOP OVER |MQNA| VALUES
              DO MA=1,IABS(KAPA(KA,ICNTA))
                MJA = 2*MA-1
C
C               LOOP OVER |MQNB| VALUES
                DO MB=1,IABS(KAPA(KB,ICNTB))
                  MJB = 2*MB-1
C
C                 NUMBER OF BASIS FUNCTION OVERLAPS
                  MAXAB = NBASA*NBASB
C
C                 CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
                  LAM  = LQNA+LQNB
C
C                 NUMBER OF TERMS IN EXPANSIONS OF THIS LENGTH
                  NTUV(LAM  ,1) = (LAM+1)*(LAM+2)*(LAM+3)/6
                  NTUV(LAM+2,2) = (LAM+3)*(LAM+4)*(LAM+5)/6
                  NTUV(LAM+1,3) = (LAM+2)*(LAM+3)*(LAM+4)/6
                  NTUV(LAM+1,4) = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C                 INCREASE NUMBER OF WORDS FOR THIS LAMBDA VALUE
                  NTRM(LAM  ,1) = NTRM(LAM  ,1) + NTUV(LAM  ,1)*MAXAB
                  NTRM(LAM+2,2) = NTRM(LAM+2,2) + NTUV(LAM+2,2)*MAXAB
                  NTRM(LAM+1,3) = NTRM(LAM+1,3) + NTUV(LAM+1,3)*MAXAB
                  NTRM(LAM+1,4) = NTRM(LAM+1,4) + NTUV(LAM+1,4)*MAXAB
C
C                 UPDATE LARGEST LAMBDA VALUE
                  IF(LAM.GT.LAMMX) THEN
                    LAMMX = LAM
                  ENDIF
C
C               END LOOPS OVER |MQNA| AND |MQNB|
                ENDDO
              ENDDO
C
C           END LOOPS OVER KQNA AND KQNB
            ENDDO
          ENDDO
C
C       END LOOPS OVER ICNTA AND ICNTB
        ENDDO
      ENDDO
C
C     NUMBER OF WORDS IN SET AND SPACE REQUIRED
      DO LAM=0,LAMMX+2
        NWRD(LAM,1) =  4*NTRM(LAM,1)
        NWRD(LAM,2) =  4*NTRM(LAM,2)
        NWRD(LAM,3) = 12*NTRM(LAM,3)
        NWRD(LAM,4) = 12*NTRM(LAM,4)
        DO ITT=1,ITTMAX
          SPCE(LAM,ITT) = 8.0D-6*NWRD(LAM,ITT)
        ENDDO
      ENDDO
C
C     CALCULATE TOTALS
      DO ITT=1,ITTMAX
        DO LAM=0,LAMMX+2
          NTUVT(ITT) = NTUVT(ITT) + NTUV(LAM,ITT)
          NTRMT(ITT) = NTRMT(ITT) + NTRM(LAM,ITT)
          NWRDT(ITT) = NWRDT(ITT) + NWRD(LAM,ITT)
          SPCET(ITT) = SPCET(ITT) + SPCE(LAM,ITT)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     SUMMARY OF WORD ANALYSIS                                         C
C**********************************************************************C
C
C     SECTION TITLE
20    FORMAT(1X,A,9X,A,4X,A,6X,A,8X,A,8X,A,6X,A)
21    FORMAT(1X,A,8X,I2,4X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
22    FORMAT(1X,A,13X,I10,7X,I2,3X,I10,5X,F10.3)
23    FORMAT(1X,A,9X,I2,3X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
24    FORMAT(1X,A,5X,A,3X,A,6X,A,8X,A,8X,A,6X,A)
25    FORMAT(1X,A,40X,I10,5X,F10.3)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',22),'Eq-coefficient word analysis'
      WRITE(7, *) REPEAT(' ',22),'Eq-coefficient word analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Type','Λ','Terms','Length','#','Words','Size (MB)'
      WRITE(7,20) 'Type','Λ','Terms','Length','#','Words','Size (MB)'
C
C     E0LL ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=0,LAMMX
        IF(LAM.EQ.0) THEN
          WRITE(6,21) 'E0LL',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
          WRITE(7,21) 'E0LL',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
          WRITE(7,21) '    ',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
        ENDIF
      ENDDO
C
      IF(HMLT.EQ.'NORL') GOTO 100
C
C     E0SS ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=2,LAMMX+2
        IF(LAM.EQ.2) THEN
          WRITE(6,21) 'E0SS',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
          WRITE(7,21) 'E0SS',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
          WRITE(7,21) '    ',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
        ENDIF
      ENDDO
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 100
C
C     E0SS ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=1,LAMMX+1
        IF(LAM.EQ.1) THEN
          WRITE(6,21) 'EILS',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
          WRITE(7,21) 'EILS',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
          WRITE(7,21) '    ',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
        ENDIF
      ENDDO
C
      IF(TREE.EQ.'HFSCF'.AND.INTSYM) GOTO 100
C
C     EISL ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=1,LAMMX+1
        IF(LAM.EQ.1) THEN
          WRITE(6,21) 'EISL',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
          WRITE(7,21) 'EISL',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
          WRITE(7,21) '    ',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
        ENDIF
      ENDDO
C
100   CONTINUE
C
C     SUMMARY OF TOTALS
      NWRDNET = 0
      SPCENET = 0.0D0
      DO ITT=1,ITTMAX
        NWRDNET = NWRDNET + NWRDT(ITT)
        SPCENET = SPCENET + SPCET(ITT)
      ENDDO
C
C     FIGURE OUT HOW MUCH SPACE IS ALLOWED BY PARAMETERS
      IF(HMLT.EQ.'NORL') THEN
        MWRD = 4
        MARR = 1
      ENDIF
      IF(HMLT.EQ.'DHFR') THEN
        MWRD = 8
        MARR = 2
      ENDIF
      IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
        MWRD = 20
        MARR = 3
      ENDIF
      IF(TREE.NE.'HFSCF'.OR..NOT.INTSYM) THEN
        IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
          MWRD = 32
          MARR = 4
        ENDIF
      ENDIF
      SPCEMFL = 8.0D-6*MWRD*MFL
C
C     SUMMARISE TOTALS BY OVERLAP TYPE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,24) 'Total','Λ_max','Terms','Length','#',
     &                                              'Words','Size (MB)'
      WRITE(7,24) 'Total','Λ_max','Terms','Length','#',
     &                                              'Words','Size (MB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'E0LL',LAMMX  ,NTUVT(1),NTRMT(1), 4,NWRDT(1),SPCET(1)
      WRITE(7,23) 'E0LL',LAMMX  ,NTUVT(1),NTRMT(1), 4,NWRDT(1),SPCET(1)
      IF(HMLT.EQ.'NORL') GOTO 200
      WRITE(6,23) 'E0SS',LAMMX+2,NTUVT(2),NTRMT(2), 4,NWRDT(2),SPCET(2)
      WRITE(7,23) 'E0SS',LAMMX+2,NTUVT(2),NTRMT(2), 4,NWRDT(2),SPCET(2)
      IF(HMLT.EQ.'DHFR') GOTO 200
      WRITE(6,23) 'EILS',LAMMX+1,NTUVT(3),NTRMT(3),12,NWRDT(3),SPCET(3)
      WRITE(7,23) 'EILS',LAMMX+1,NTUVT(3),NTRMT(3),12,NWRDT(3),SPCET(3)
      IF(TREE.EQ.'HFSCF'.AND.INTSYM) GOTO 200
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 200
      WRITE(6,23) 'EISL',LAMMX+1,NTUVT(4),NTRMT(4),12,NWRDT(4),SPCET(4)
      WRITE(7,23) 'EISL',LAMMX+1,NTUVT(4),NTRMT(4),12,NWRDT(4),SPCET(4)
200   CONTINUE
C      
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,25) '       ',NWRDNET,SPCENET
      WRITE(7,25) '       ',NWRDNET,SPCENET
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'parameters.h',MFL,MWRD,MWRD*MFL,SPCEMFL
      WRITE(7,22) 'parameters.h',MFL,MWRD,MWRD*MFL,SPCEMFL
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     OPTION WHEN NUMBER OF WORDS EXCEEDS ALLOCATED SIZE LIMIT
      IF(NTRMT(1).GT.MFL) THEN
        WRITE(6, *) 'In EQSAVE: E0LL words exceed allocated limit.'
        WRITE(7, *) 'In EQSAVE: E0LL words exceed allocated limit.'
        GOTO 150
      ENDIF
C
      IF(HMLT.NE.'NORL') THEN
        IF(NTRMT(2).GT.MFL) THEN
          WRITE(6, *) 'In EQSAVE: E0SS words exceed allocated limit.'
          WRITE(7, *) 'In EQSAVE: E0SS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF
C     NO NEED TO ASK ABOUT EILS OR EISL! E0SS IS LARGER THAN EITHER.
C
C     SIZE LIMITS ARE ALL OK -- SKIP TO BATCH GENERATION
      GOTO 250
C
C     ONE OF THE CLASSES EXCEEDS WORD LIMIT
150   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     HAVE TO GENERATE E COEFFICIENTS BY BATCH
      WRITE(6, *) 'In EQSAVE: Eq-coefficients to be generated by batch.'
      WRITE(7, *) 'In EQSAVE: Eq-coefficients to be generated by batch.'
C
C     FLIP THE EQ-GENERATION TOGGLE AND EXIT
      EQFILE = .FALSE.
      GOTO 300
C
250   CONTINUE
C
C**********************************************************************C
C     GENERATE COMPLETE BATCHES OF EQ-COEFFS                           C
C**********************************************************************C
C
C     SECTION TITLE
      WRITE(6, *) REPEAT(' ',18),'Generating Eq-coefficient data files'
      WRITE(7, *) REPEAT(' ',18),'Generating Eq-coefficient data files'
C
C     E0LL COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL1,RATE)
      CALL E0LLGN
      CALL SYSTEM_CLOCK(ICL2)
      TELL = TELL + DFLOAT(ICL2-ICL1)/RATE
C
      IF(HMLT.EQ.'NORL') GOTO 300
C
C     E0SS COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL1,RATE)
      CALL E0SSGN
      CALL SYSTEM_CLOCK(ICL2)
      TESS = TESS + DFLOAT(ICL2-ICL1)/RATE
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 300
C
C     EILS COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL1,RATE)
      CALL EILSGN
      CALL SYSTEM_CLOCK(ICL2)
      TELS = TELS + DFLOAT(ICL2-ICL1)/RATE
C
      IF(TREE.EQ.'HFSCF'.AND.INTSYM) GOTO 300
C
C     EISL COEFFICIENTS
      CALL SYSTEM_CLOCK(ICL1,RATE)
      CALL EISLGN
      CALL SYSTEM_CLOCK(ICL2)
      TESL = TESL + DFLOAT(ICL2-ICL1)/RATE
C
300   CONTINUE
C
C     END OF SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE E0LLGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE 000000  LL       LL       GGGGGG  NN    NN          C
C         EE      00   000 LL       LL      GG    GG NNN   NN          C
C         EE      00  0000 LL       LL      GG       NNNN  NN          C
C         EEEEEE  00 00 00 LL       LL      GG       NN NN NN          C
C         EE      0000  00 LL       LL      GG   GGG NN  NNNN          C
C         EE      000   00 LL       LL      GG    GG NN   NNN          C
C         EEEEEEEE 000000  LLLLLLLL LLLLLLLL GGGGGG  NN    NN          C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0LLGN GENERATES A FULL SET OF E0LL COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY E0LL, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)
      NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELL0(AB) COEFFICIENTS
      CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ELL0(AB) TO THE MAIN ARRAY
      DO IAB=1,NTUVLL
        IAD = ICOUNT + (IAB-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,1) = DREAL(E11(M,IAB))
          E0LLFL(IAD+M,2) = DIMAG(E11(M,IAB))
          E0LLFL(IAD+M,3) = DREAL(E21(M,IAB))
          E0LLFL(IAD+M,4) = DIMAG(E21(M,IAB))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE E0SSGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE 000000   SSSSSS   SSSSSS   GGGGGG  NN    NN         C
C         EE      00   000 SS    SS SS    SS GG    GG NNN   NN         C
C         EE      00  0000 SS       SS       GG       NNNN  NN         C
C         EEEEEE  00 00 00  SSSSSS   SSSSSS  GG       NN NN NN         C
C         EE      0000  00       SS       SS GG   GGG NN  NNNN         C
C         EE      000   00 SS    SS SS    SS GG    GG NN   NNN         C
C         EEEEEEEE 000000   SSSSSS   SSSSSS   GGGGGG  NN    NN         C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0SSGN GENERATES A FULL SET OF E0SS COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY E0SS, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ESS0(AB) COEFFICIENTS
      CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ESS0(AB) TO THE MAIN ARRAY
      DO IAB=1,NTUVSS
        IAD = ICOUNT + (IAB-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,1) = DREAL(E11(M,IAB))
          E0SSFL(IAD+M,2) = DIMAG(E11(M,IAB))
          E0SSFL(IAD+M,3) = DREAL(E21(M,IAB))
          E0SSFL(IAD+M,4) = DIMAG(E21(M,IAB))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EILSGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII LL       SSSSSS   GGGGGG  NN    NN           C
C           EE        II  LL      SS    SS GG    GG NNN   NN           C
C           EE        II  LL      SS       GG       NNNN  NN           C
C           EEEEEE    II  LL       SSSSSS  GG       NN NN NN           C
C           EE        II  LL            SS GG   GGG NN  NNNN           C
C           EE        II  LL      SS    SS GG    GG NN   NNN           C
C           EEEEEEEE IIII LLLLLLLL SSSSSS   GGGGGG  NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSGN GENERATES A FULL SET OF EILS COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY EILS, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVLS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADILS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE EILS(AB) COEFFICIENTS
      CALL EQLSMK(E11X,E21X,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQLSMK(E11Y,E21Y,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQLSMK(E11Z,E21Z,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
C
C     WRITE EILS(AB) TO THE MAIN ARRAY
      DO IAB=1,NTUVLS
        IAD = ICOUNT + (IAB-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M, 1) = DREAL(E11X(M,IAB))
          EILSFL(IAD+M, 2) = DIMAG(E11X(M,IAB))
          EILSFL(IAD+M, 3) = DREAL(E21X(M,IAB))
          EILSFL(IAD+M, 4) = DIMAG(E21X(M,IAB))
          EILSFL(IAD+M, 5) = DREAL(E11Y(M,IAB))
          EILSFL(IAD+M, 6) = DIMAG(E11Y(M,IAB))
          EILSFL(IAD+M, 7) = DREAL(E21Y(M,IAB))
          EILSFL(IAD+M, 8) = DIMAG(E21Y(M,IAB))
          EILSFL(IAD+M, 9) = DREAL(E11Z(M,IAB))
          EILSFL(IAD+M,10) = DIMAG(E11Z(M,IAB))
          EILSFL(IAD+M,11) = DREAL(E21Z(M,IAB))
          EILSFL(IAD+M,12) = DIMAG(E21Z(M,IAB))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EISLGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII  SSSSSS  LL       GGGGGG  NN    NN           C
C           EE        II  SS    SS LL      GG    GG NNN   NN           C
C           EE        II  SS       LL      GG       NNNN  NN           C
C           EEEEEE    II   SSSSSS  LL      GG       NN NN NN           C
C           EE        II        SS LL      GG   GGG NN  NNNN           C
C           EE        II  SS    SS LL      GG    GG NN   NNN           C
C           EEEEEEEE IIII  SSSSSS  LLLLLLLL GGGGGG  NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLGN GENERATES A FULL SET OF EISL COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY EISL, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     LOOPS OVER BASIS FUNCTION BLOCKS A AND B                         C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVSL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADISL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE EISL(AB) COEFFICIENTS
      CALL EQSLMK(E11X,E21X,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQSLMK(E11Y,E21Y,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQSLMK(E11Z,E21Z,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
C
C     WRITE EISL(AB) TO THE MAIN ARRAY
      DO IAB=1,NTUVSL
        IAD = ICOUNT + (IAB-1)*MAXAB
        DO M=1,MAXAB
          EISLFL(IAD+M, 1) = DREAL(E11X(M,IAB))
          EISLFL(IAD+M, 2) = DIMAG(E11X(M,IAB))
          EISLFL(IAD+M, 3) = DREAL(E21X(M,IAB))
          EISLFL(IAD+M, 4) = DIMAG(E21X(M,IAB))
          EISLFL(IAD+M, 5) = DREAL(E11Y(M,IAB))
          EISLFL(IAD+M, 6) = DIMAG(E11Y(M,IAB))
          EISLFL(IAD+M, 7) = DREAL(E21Y(M,IAB))
          EISLFL(IAD+M, 8) = DIMAG(E21Y(M,IAB))
          EISLFL(IAD+M, 9) = DREAL(E11Z(M,IAB))
          EISLFL(IAD+M,10) = DIMAG(E11Z(M,IAB))
          EISLFL(IAD+M,11) = DREAL(E21Z(M,IAB))
          EISLFL(IAD+M,12) = DIMAG(E21Z(M,IAB))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
3002  CONTINUE
3001  CONTINUE
2002  CONTINUE
2001  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    LL       LL       MM       MM KK    KK      C
C      EE       QQ    QQ   LL       LL       MMM     MMM KK   KK       C
C      EE      QQ      QQ  LL       LL       MMMM   MMMM KK  KK        C
C      EEEEEE  QQ      QQ  LL       LL       MM MM MM MM KKKKK         C
C      EE      QQ      QQ  LL       LL       MM  MMM  MM KK  KK        C
C      EE       QQ    QQ   LL       LL       MM   M   MM KK   KK       C
C      EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLLMK GENERATES A BATCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLL  = LA+LB
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLL BY PHASE TERM IF EQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLL BY PHASE TERM IF EQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    LL       SSSSSS  MM       MM KK    KK       C
C      EE       QQ    QQ   LL      SS    SS MMM     MMM KK   KK        C
C      EE      QQ      QQ  LL      SS       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  LL       SSSSSS  MM MM MM MM KKKKK          C
C      EE      QQ      QQ  LL            SS MM  MMM  MM KK  KK         C
C      EE       QQ    QQ   LL      SS    SS MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS  MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLSMK GENERATES A BATCH OF EQLS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    SSSSSS  LL       MM       MM KK    KK       C
C      EE       QQ    QQ  SS    SS LL       MMM     MMM KK   KK        C
C      EE      QQ      QQ SS       LL       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  SSSSSS  LL       MM MM MM MM KKKKK          C
C      EE      QQ      QQ       SS LL       MM  MMM  MM KK  KK         C
C      EE       QQ    QQ  SS    SS LL       MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSLMK GENERATES A BATCH OF EQSL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS  MM       MM KK    KK       C
C      EE       QQ    QQ  SS    SS SS    SS MMM     MMM KK   KK        C
C      EE      QQ      QQ SS       SS       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  SSSSSS   SSSSSS  MM MM MM MM KKKKK          C
C      EE      QQ      QQ       SS       SS MM  MMM  MM KK  KK         C
C      EE       QQ    QQ  SS    SS SS    SS MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS  MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSSMK GENERATES A BATCH OF EQSS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+2 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSS  = LA+LB+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSS BY PHASE TERM IF EQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSS BY PHASE TERM IF EQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY SIMPLE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EILSB3(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII LL       SSSSSS  BBBBBBB   333333            C
C           EE        II  LL      SS    SS BB    BB 33    33           C
C           EE        II  LL      SS       BB    BB       33           C
C           EEEEEE    II  LL       SSSSSS  BBBBBBB    33333            C
C           EE        II  LL            SS BB    BB       33           C
C           EE        II  LL      SS    SS BB    BB 33    33           C
C           EEEEEEEE IIII LLLLLLLL SSSSSS  BBBBBBB   333333            C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSB3 GENERATES A BATCH OF EILS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C  THIS ACTUALLY MAKES A VECTOR LIST OF THE EQLS NEEDED FOR BREIT.     C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQLS(E11Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQLS(E11Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV,1) = PHS*E11X(M,ITUV)
          E11(M,ITUV,2) = PHS*E11Y(M,ITUV)
          E11(M,ITUV,3) = PHS*E11Z(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)

C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQLS(E21Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQLS(E21Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV,1) = PHS*E21X(M,ITUV)
          E21(M,ITUV,2) = PHS*E21Y(M,ITUV)
          E21(M,ITUV,3) = PHS*E21Z(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EISLB3(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          EEEEEEEE IIII  SSSSSS  LL       BBBBBBB   333333            C
C          EE        II  SS    SS LL       BB    BB 33    33           C
C          EE        II  SS       LL       BB    BB       33           C
C          EEEEEE    II   SSSSSS  LL       BBBBBBB    33333            C
C          EE        II        SS LL       BB    BB       33           C
C          EE        II  SS    SS LL       BB    BB 33    33           C
C          EEEEEEEE IIII  SSSSSS  LLLLLLLL BBBBBBB   333333            C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLB3 GENERATES A BATCH OF EISL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C  THIS ACTUALLY MAKES A VECTOR LIST OF EQSL NEEDED FOR BREIT (MBPT).  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQSL(E11Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQSL(E11Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV,1) = PHS*E11X(M,ITUV)
          E11(M,ITUV,2) = PHS*E11Y(M,ITUV)
          E11(M,ITUV,3) = PHS*E11Z(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)

C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQSL(E21Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQSL(E21Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV,1) = PHS*E21X(M,ITUV)
          E21(M,ITUV,2) = PHS*E21Y(M,ITUV)
          E21(M,ITUV,3) = PHS*E21Z(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ELSQ FROM ESLQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQLL(ELL,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EEEEEE  QQ      QQ  LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLL GENERATES A BLOCK OF RAW EQLL/GQLL-COEFFICIENTS FOR A GIVEN    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQLLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ELL  - RAW EQLL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNLL(MBS,MBS)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELL(MB2,MEQ),ESG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO ITUV=1,MEQ
        DO M=1,MB2
          ELL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     BASIS FUNCTION OVERLAP LIST LENGTH
      MAXAB = NBS(1)*NBS(2)
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: ALL KQN(1) AND KQN(2) TYPES.                             C
C**********************************************************************C
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELL0 AND ELLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXAB
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +     CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXAB
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELLX AND ELLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXAB
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXAB
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +     CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LAM0  = LQLAB(1)+LQLAB(2)
      NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C     GENERATE RNLL NORMALISATION CONSTANTS
      CALL RNORM1(RNLL,EXL,LQN,NBS,1)
C
C     NORMALISE THE ELLQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = RNLL(IBAS,JBAS)*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXAB
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = CONE*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQLS(ELS,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    LL       SSSSSS                  C
C                 EE       QQ    QQ   LL      SS    SS                 C
C                 EE      QQ      QQ  LL      SS                       C
C                 EEEEEE  QQ      QQ  LL       SSSSSS                  C
C                 EE      QQ      QQ  LL            SS                 C
C                 EE       QQ    QQ   LL      SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS GENERATES A BLOCK OF RAW EQLS-COEFFICIENTS FOR A GIVEN         C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQLSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ELS  - RAW EQLS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNLS(MBS,MBS)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ELS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXAB = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(JBAS,2)
          T0(M) = DFLOAT(2*LQN(2)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-EXL(IBAS,1)*EXL(JBAS,2)*AB2/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+2
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNLS NORMALISATION CONSTANTS
      CALL RNORM1(RNLS,EXL,LQN,NBS,2)
C
C     NORMALISE THE ELSQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*RNLS(IBAS,JBAS)*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXAB
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSL(ESL,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS  LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EE      QQ      QQ SS       LL                       C
C                 EEEEEE  QQ      QQ  SSSSSS  LL                       C
C                 EE      QQ      QQ       SS LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSL GENERATES A BLOCK OF RAW EQSL-COEFFICIENTS FOR A GIVEN         C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQSLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ESL  - RAW EQSL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNSL(MBS,MBS)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESL(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXAB = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(IBAS,1)
          T0(M) = DFLOAT(2*LQN(1)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXAB
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+2
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNSL NORMALISATION CONSTANTS
      CALL RNORM1(RNSL,EXL,LQN,NBS,3)
C
C     NORMALISE THE ESLQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR -i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV2
            ESL(M,ITUV) =-CONE*RNSL(IBAS,JBAS)*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXAB
          DO ITUV=1,NTUV2
            ESL(M,ITUV) = CONE*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSS(ESS,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS                  C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EE      QQ      QQ SS       SS                       C
C                 EEEEEE  QQ      QQ  SSSSSS   SSSSSS                  C
C                 EE      QQ      QQ       SS       SS                 C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSS GENERATES A BLOCK OF RAW EQSS-COEFFICIENTS FOR A GIVEN         C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQSSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ESS  - RAW EQSS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNSS(MBS,MBS)
      DIMENSION T22(MB2),T20(MB2),T02(MB2),T00(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXAB = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      RL1 = DFLOAT(2*LQN(1)+1)
      RL2 = DFLOAT(2*LQN(2)+1)
C
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T22(M) = 4.0D0*EXL(IBAS,1)*EXL(JBAS,2)
          T20(M) =-2.0D0*RL2*EXL(IBAS,1)
          T02(M) =-2.0D0*RL1*EXL(JBAS,2)
          T00(M) = RL1*RL2
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(1).LT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).LT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     CASE 3: KQN(1).GT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).GT.0) GOTO 300
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

300   CONTINUE      
C
C**********************************************************************C
C     CASE 4: KQN(1).GT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).LT.0) GOTO 400
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXAB)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXAB
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXAB
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXAB,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXAB
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXAB,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXAB
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
400   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE RNSS NORMALISATION CONSTANTS
      CALL RNORM1(RNSS,EXL,LQN,NBS,4)
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM4  = LQN(1)+LQN(2)+4
      NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C     NORMALISE THE ESSQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = RNSS(IBAS,JBAS)*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXAB
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = CONE*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ESGTF(ESG,LQN,MQN,MAXAB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              EEEEEEEE SSSSSS   GGGGGG TTTTTTTT FFFFFFFF              C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EE      SS       GG         TT    FF                    C
C              EEEEEE   SSSSSS  GG         TT    FFFFFF                C
C              EE            SS GG   GGG   TT    FF                    C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EEEEEEEE SSSSSS   GGGGGG    TT    FF                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESGTF CONSTRUCTS THE EXPANSION COEFFICIENTS OF THE OVERLAP DENSITY  C
C  OF TWO SPHERICAL HARMONIC FUNCTIONS IN AN AUXILIARY HGTF BASIS.     C
C                                                                      C
C  THE OVERLAP DENSITY IS DEFINED BY Y*[L,M]Y[L',M'], WHERE Y[L,M] ARE C
C  SPHERICAL HARMONICS FOLLOWING THE CONDON-SHORTLEY PHASE CONVENTION. C
C                                                                      C
C  THE REQUIRED COEFFICIENTS ARE GENERATED BY A CALL TO EVRS, WHICH IS C
C  CONSTRUCTED ACCORDING TO THE RECURRENCE RELATIONS DEFINED BY        C
C  V.R.SAUNDERS. THE OUTPUT OF EVRS IS THEN ADJUSTED TO INCLUDE THE    C
C  ANGULAR NORMALISATION CONSTANTS, AS WELL AS A PHASE FACTOR TO       C
C  CONVERT FROM THE SCHIFF TO THE CONDON-SHORTLEY PHASE CONVENTION.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN   - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                C
C  ▶ MQN   - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.          C
C  ▶ MAXAB - SIZE OF THIS BLOCK.                                       C
C  OUTPUT:                                                             C
C  ▶ ESG  - EXPANSION COEFFICIENTS FOR EACH OVERLAP IN THE BLOCK.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQN(2),MQN(2),MQNLAB(2)
C
      COMPLEX*16 ESG(MB2,MEQ)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     EVRS IS CALLED WITH THE SIGN OF MQN(1) REVERSED
C     TO AFFECT COMPLEX CONJUGATION, ALONG WITH THE REQUISITE
C     PHASE, WHICH IS CALCULATED LATER.
      MQNLAB(1) =-MQN(1)
      MQNLAB(2) = MQN(2)
C
C     GENERATE RAW COEFFICIENTS WITH EVRS
      CALL EVRS(ESG,LQN,MQNLAB,MAXAB)
C
C     MQN PHASES
      PHS1 = (-1.0D0)**((MQN(1)+IABS(MQN(1)))/2)
      PHS2 = (-1.0D0)**((MQN(2)+IABS(MQN(2)))/2)
C
C     CG COEFFICIENTS
      PI4 = 0.25D0/PI
      DGL = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))
      CG1 = RFACT(LQN(1)-IABS(MQN(1)))/RFACT(LQN(1)+IABS(MQN(1)))
      CG2 = RFACT(LQN(2)-IABS(MQN(2)))/RFACT(LQN(2)+IABS(MQN(2)))
C
C     ANGULAR NORMALISATION CONSTANT
      ANG = PHS1*PHS2*PI4*DSQRT(DGL*CG1*CG2)
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LAM  = LQN(1)+LQN(2)
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     APPLY ANGULAR FACTOR TO RAW COEFFICIENTS
      DO M=1,MAXAB
        DO ITUV=1,NTUV
          ESG(M,ITUV) = ANG*ESG(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE EVRS(ESG,LQN,MQN,MAXAB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE VV    VV RRRRRRR   SSSSSS                   C
C                 EE       VV    VV RR    RR SS    SS                  C
C                 EE       VV    VV RR    RR SS                        C
C                 EEEEEE   VV    VV RR    RR  SSSSSS                   C
C                 EE        VV  VV  RRRRRRR        SS                  C
C                 EE         VVVV   RR    RR SS    SS                  C
C                 EEEEEEEE    VV    RR    RR  SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  EVRS EVALUATES THE EXPANSION COEFFICIENTS OF THE OVERLAP CHARGE     C
C  DENSITY OF SGTFS IN AN AUXILIARY HGTF. COEFFICIENTS ARE EVALUATED   C
C  USING THE RECURRENCE RELATIONS DEFINED BY VIC SAUNDERS IN:          C
C                                                                      C
C  V.R.SAUNDERS, "MOLECULAR INTEGRALS FOR GAUSSIAN-TYPE FUNCTIONS",    C
C  METHODS OF COMPUTATIONAL MOLECULAR PHYSICS, DIERCKSEN AND WILSON,   C
C  pp 1-26, REIDEL PUBLISHING, DORDRECHT (1983).                       C
C                                                                      C
C  THE EQ-COEFFS IN THIS PROCEDURE ARE FOR AN UN-NORMALISED SGTF.      C
C  THE COEFFICIENTS ARE DETERMINED ACCORDING TO THE SAME RULES AS      C
C  DEFINED IN THE ABOVE ARTICLE. CONSEQUENTLY, IT SHOULD BE NOTED THAT C
C  THE COEFFICIENTS ARE THOSE OF SPHERICAL HARMONIC FUNCTIONS THAT ARE C
C   ▶ UN-NORMALISED                                                    C
C   ▶ SATISFY THE SCHIFF PHASE CONVENTION.                             C
C                                                                      C
C  THE OUTLINE FOR THE GENERATION OF EQ-COEFFICIENTS IS TAKEN FROM p16 C
C  OF THE ABOVE ARTICLE. EQUATION NUMBERS ARE GIVEN IN COMMENTS.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN   - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                C
C  ▶ MQN   - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.          C
C  ▶ MAXAB - SIZE OF THIS BLOCK.                                       C
C  OUTPUT:                                                             C
C  ▶ ESG  - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION NBAS(2),LQN(2),MQN(2)
C
      COMPLEX*16 ESG(MB2,MEQ),ETEMP(MB2*MRC)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     IMPORT LQN AND BASIS PAIR MQNS FOR LOCAL USE
      LQNA = LQN(1)
      LQNB = LQN(2)
      MQNA = MQN(1)
      MQNB = MQN(2)
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LMAX = LQN(1)+LQN(2)
      NTUV = (LMAX+1)*(LMAX+2)*(LMAX+3)/6
C
C     INITIALISE ESG AND ARRAY
      DO M=1,MAXAB
        DO ITUV=1,NTUV
          ESG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     EXIT IF LQN,MQN ORDERS YIELD ZERO CG-COEFFICIENTS
      IF(IABS(MQN(1)).GT.LQN(1).OR.IABS(MQN(2)).GT.LQN(2)) RETURN
C
C     CHECK THAT LMAX IS WITHIN THE BOUNDS OF MKP
      IF(LMAX.GT.MKP+1) THEN
        WRITE(6, *) 'In EVRS: LMAX exceeds MKP+1 parameter.',LMAX,MKP+1
        WRITE(7, *) 'In EVRS: LMAX exceeds MKP+1 parameter.',LMAX,MKP+1
        STOP
      ENDIF
C
c     INITIALISE TEMPORARY ARRAY
      DO M=1,MB2*MRC
        ETEMP(M) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     SET INITIAL VALUES TO E[0,0;0,0;0,0,0,0] = RKAB
      DO M=1,MAXAB
        ETEMP(M) = DCMPLX(RKAB(M),0.0D0)
      ENDDO
C
C     STEP 1:
C     GENERATE E[|MQNA|,MQNA;0,0] FROM E[0,0;0,0] USING
C     SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE A
      ISTART = 0
      LAM    = 0
      CALL ESTEPLM(ETEMP,LAM,ISTART,MQNA,MAXAB,1)
C
C     STEP 2:
C     GENERATE E[LQNA,MQNA;0,0] FROM E[|MQNA|,MQNA;0,0]
C     USING THE STEP OF LQN ONLY ON CENTRE A
      CALL ESTEPL(ETEMP,LAM,ISTART,LQNA,MQNA,MAXAB,1)
C
C     STEP 3:
C     GENERATE E[LQNA,MQNA;|MQNB|,MQNB] FROM E[LQNA,MQNA;0,0]
C     USING SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE B
      CALL ESTEPLM(ETEMP,LAM,ISTART,MQNB,MAXAB,2)
C
C     STEP 4:
C     GENERATE E[LQNA,MQNA;LQNB,MQNB] FROM E[LQNA,MQNA;|MQNB|,MQNB]
C     USING THE STEP OF LQN ONLY ON CENTRE B
      CALL ESTEPL(ETEMP,LAM,ISTART,LQNB,MQNB,MAXAB,2)
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     STEP 5:
C     COPY FINAL BLOCK OF ENTRIES AS THE REQUIRED OUTPUT
      K = 0
      DO ITUV=1,NTUV
        DO M=1,MAXAB
          K = K+1
          ESG(M,ITUV) = ETEMP(ISTART+K)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESTEPLM(ETEMP,LAM,ISTART,MQN,MAXAB,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL       MM       MM    C
C   EE      SS    SS   TT    EE       PP    PP LL       MMM     MMM    C
C   EE      SS         TT    EE       PP    PP LL       MMMM   MMMM    C
C   EEEEEE   SSSSSS    TT    EEEEEE   PP    PP LL       MM MM MM MM    C
C   EE            SS   TT    EE       PPPPPPP  LL       MM  MMM  MM    C
C   EE      SS    SS   TT    EE       PP       LL       MM   M   MM    C
C   EEEEEEEE SSSSSS    TT    EEEEEEEE PP       LLLLLLLL MM       MM    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SIMULTANEOUSLY INCREMENT THE QUANTUM NUMBERS LQN & MQN, STARTING    C
C  WITH E[0,0], USING THE RECURSION ALGORITHM OF V.R.SAUNDERS IN       C
C  `MOLECULAR INTEGRALS FOR GAUSSIAN TYPE FUNCTIONS' 1983.             C
C -------------------------------------------------------------------- C
C       E[0,0;IT,IU,IV] -> E[|MQN|+1,±(|MQN|+1);IT,IU,IV]  Eq.(64)     C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM    - LENGTH OF THE INPUT HGTF EXPANSION.                      C
C  ▶ ISTART - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST.  C
C  ▶ MQN    - MAGNETIC QUANTUM NUMBER.                                 C
C  ▶ MAXAB  - NUMBER OF EXPONENT/DENSITY PAIRS.                        C
C  ▶ IZ     - CENTRE TO STEP UP.                                       C
C  OUTPUT:                                                             C
C  ▶ ETEMP  - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PX(MB2),PY(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IF |MQN|.EQ.0 THEN NO INCREMENT IN (LQN,MQN) IS REQUIRED
      IF(IABS(MQN).EQ.0) RETURN
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXAB
        IF(IZ.EQ.1) THEN
          PX(M) = PAX(M)
          PY(M) = PAY(M)
        ELSEIF(IZ.EQ.2) THEN
          PX(M) = PBX(M)
          PY(M) = PBY(M)
        ENDIF
      ENDDO
C
C     PHASE TERM FOR SIGN OF MQN
      PHM = DFLOAT(ISIGN(1,MQN))
C
C     LOOP OVER ALL MAGNETIC NUMBERS UP TO THIS MQN (USE LQN AS COUNTER)
      DO LQN=0,IABS(MQN)-1
C
C       DEGENERACY COUNTER 2*LQN+1
        R2L1 = DFLOAT(2*LQN+1)
C
C       NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C       ISTART LABELS THE PREVIOUS LQN VALUE
C       JSTART LABELS THE CURRENT  LQN VALUE
C       KSTART LABELS THE NEXT     LQN VALUE
        JSTART = ISTART
        KSTART = JSTART + NTUV*MAXAB
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       J0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                               C
C       K0-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                               C
C       K1-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                               C
C       K2-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                               C
C       K3-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                               C
C       K4-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                               C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN)
              J0 = JSTART + (IABC(IT  ,IU  ,IV)-1)*MAXAB
              K0 = KSTART + (IABC(IT  ,IU  ,IV)-1)*MAXAB
              K1 = KSTART + (IABC(IT+1,IU  ,IV)-1)*MAXAB
              K2 = KSTART + (IABC(IT  ,IU+1,IV)-1)*MAXAB
              IF(IT.NE.0) K3 = KSTART + (IABC(IT-1,IU  ,IV  )-1)*MAXAB
              IF(IU.NE.0) K4 = KSTART + (IABC(IT  ,IU-1,IV  )-1)*MAXAB
C
C             INVOKE RECURRENCE RELATIONS ON LAYER (LQN+1)
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXAB
                T1 = R2L1/P2(M)
                TX = R2L1*PX(M)
                TY = R2L1*PY(M)
                ETEMP(K0+M) = ETEMP(K0+M) +          TX*ETEMP(J0+M)
     &                                    + PHM*CONE*TY*ETEMP(J0+M)
                ETEMP(K1+M) = ETEMP(K1+M) +          T1*ETEMP(J0+M)
                ETEMP(K2+M) = ETEMP(K2+M) + PHM*CONE*T1*ETEMP(J0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                FC = R2L1*DFLOAT(IT)
                DO M=1,MAXAB
                  ETEMP(K3+M) = ETEMP(K3+M) +          FC*ETEMP(J0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                FC = R2L1*DFLOAT(IU)
                DO M=1,MAXAB
                  ETEMP(K4+M) = ETEMP(K4+M) + PHM*CONE*FC*ETEMP(J0+M)
                ENDDO
              ENDIF
C
C           END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
C
C       UPDATE 'PREVIOUS' START VALUE
        ISTART = ISTART + NTUV*MAXAB
C
C       UPDATE LAMBDA VALUE
        LAM = LAM+1
C
C     END OF LOOP OVER MQN COUNTER
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESTEPL(ETEMP,LAM,ISTART0,LQN,MQN,MAXAB,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL                C
C         EE      SS    SS   TT    EE       PP    PP LL                C
C         EE      SS         TT    EE       PP    PP LL                C
C         EEEEEE   SSSSSS    TT    EEEEEE   PP    PP LL                C
C         EE            SS   TT    EE       PPPPPPP  LL                C
C         EE      SS    SS   TT    EE       PP       LL                C
C         EEEEEEEE SSSSSS    TT    EEEEEEEE PP       LLLLLLLL          C
C                                                                      C
C -------------------------------------------------------------------- C
C  DECREMENT THE LQN, STARTING WITH E[MQN,±|MQN|], USING THE RECURSION C
C  ALGORITHM OF V.R.SAUNDERS IN `MOLECULAR INTEGRALS FOR GAUSSIAN TYPE C
C  FUNCTIONS' 1983 (EDITED BY G.H.F. DIERCKSEN AND S. WILSON).         C
C -------------------------------------------------------------------- C
C (1)  E[|MQN|,±MQN;IT,IU,IV] -> E[LQN+1,±MQN;IT,IU,IV]    Eq.(64)     C
C (2)  E[LQN  ,±MQN;IT,IU,IV] -> E[LQN+1,±MQN;IT,IU,IV]                C
C (3)  E[LQN-1,±MQN;IT,IU,IV] -> E[LQN+1,±MQN;IT,IU,IV]                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM     - LENGTH OF THE INPUT HGTF EXPANSION.                     C
C  ▶ ISTART0 - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST. C
C  ▶ LQN     - ORBITAL QUANTUM NUMBER.                                 C
C  ▶ MQN     - MAGNETIC QUANTUM NUMBER.                                C
C  ▶ MAXAB   - NUMBER OF EXPONENT/DENSITY PAIRS.                       C
C  ▶ IZ      - CENTRE TO STEP UP.                                      C
C  OUTPUT:                                                             C
C  ▶ ETEMP   - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IF LQN.LE.|MQN| THEN NO INCREMENT IN LQN IS REQUIRED
      IF(LQN.LE.IABS(MQN)) RETURN
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXAB
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     STEP (1): E[|MQN|,MQN;IT,IU,IV] -> E[|MQN|+1,MQN;IT,IU,IV].      C
C               IT MAPS SOME INDEX SETS FROM DATA OBTAINED IN ESTEPLM. C
C -------------------------------------------------------------------- C
C     INDEX MAPPINGS: J0-> E[MQN  ,MQN;IT  ,IU  ,IV  ]                 C
C                     K0-> E[MQN+1,MQN;IT  ,IU  ,IV  ]                 C
C                     K6-> E[MQN+1,MQN;IT  ,IU  ,IV+1]                 C
C                     K9-> E[MQN+1,MQN;IT  ,IU  ,IV-1]                 C
C**********************************************************************C
C
C     ISTART0 LABELS THE GLOBAL STARTING VALUE
C     ISTART  LABELS THE PREVIOUS LQN VALUE
C     JSTART  LABELS THE CURRENT  LQN VALUE
C     KSTART  LABELS THE NEXT     LQN VALUE
      JSTART = ISTART0
      KSTART = JSTART + NTUV*MAXAB
C
C     OVERALL LQN/MQN FACTOR SIMPLIFIES WHEN LQN = |MQN|
      RLM  = DFLOAT(2*IABS(MQN)+1)
C
C     LOOP OVER THE HGTF INDICES OF THE SEED LAYER
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
C           STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN+1)
            J0 = JSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXAB
            K0 = KSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXAB
            K6 = KSTART + (IABC(IT  ,IU  ,IV+1)-1)*MAXAB
            IF(IV.NE.0) K9 = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXAB
C
C           INVOKE RECURRENCE RELATIONS ON LAYER (LQN+1)
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            DO M=1,MAXAB
              TZ = RLM*PZ(M)
              TP = RLM/P2(M)
              ETEMP(K0+M) = ETEMP(K0+M) + TZ*ETEMP(J0+M)
              ETEMP(K6+M) = ETEMP(K6+M) + TP*ETEMP(J0+M)
            ENDDO
C
C           SPECIAL CASE EXCLUDES IV=0
            IF(IV.GE.1) THEN
              FC = RLM*DFLOAT(IV)
              DO M=1,MAXAB
                ETEMP(K9+M) = ETEMP(K9+M) + FC*ETEMP(J0+M)
              ENDDO
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     UPDATE BLOCK LOCATORS
      ISTART  = ISTART0
      ISTART0 = ISTART0 + NTUV*MAXAB
C
C     UPDATE LAMBDA VALUE
      LAM = LAM+1
C
C     IF LQN=|MQN|+1 THEN SET IS FINISHED
      IF(LQN.EQ.IABS(MQN)+1) RETURN
C
C**********************************************************************C
C   THIS AND SUBSEQUENT STEPS IN RECURRENCE INVOLVE THREE LAYERS:      C
C            E[LQN  ,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV]            C
C            E[LQN-1,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV]            C
C -------------------------------------------------------------------- C
C   INDEX MAPPINGS: I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                  C
C                   J0 -> E[LQN  ,MQN;IT  ,IU  ,IV  ]                  C
C                   K0 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                  C
C                   K1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                  C
C                   K2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                  C
C                   K3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                  C
C                   K4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                  C
C                   K5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                  C
C                   K6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                  C
C                   K7 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                  C
C                   K8 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                  C
C                   K9 -> E[LQN+1,MQN;IT  ,IU  ,IV-1]                  C
C                   K10-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                  C
C                   K11-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                  C
C                   K12-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                  C
C**********************************************************************C
C
C     LOOP OVER LSTP FOR FIXED MQN DOWN TO LQN-1
      DO LSTP=IABS(MQN)+1,LQN-1

C       OVERALL LSTP/MQN FACTORS
        RLM1 = DFLOAT(2*LSTP+1)/DFLOAT(LSTP-IABS(MQN)+1)
        RLM2 =-DFLOAT(LSTP+IABS(MQN))/DBLE(LSTP-IABS(MQN)+1)
C
C       NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
        JSTART = ISTART0
        KSTART = ISTART0 + MAXAB*NTUV
C
C**********************************************************************C
C     STEP (2): E[LSTP  ,MQN;IT,IU,IV] -> E[LSTP+1,MQN;IT,IU,IV].      C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LSTP)
              J0 = JSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXAB
              K0 = KSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXAB
              K6 = KSTART + (IABC(IT  ,IU  ,IV+1)-1)*MAXAB
              IF(IV.NE.0) K9 = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXAB
C
C             INVOKE RECURRENCE RELATIONS ON LAYER (LSTP)
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXAB
                TZ = PZ(M)
                TP = 1.0D0/P2(M)
                ETEMP(K0+M) = ETEMP(K0+M) + TZ*RLM1*ETEMP(J0+M)
                ETEMP(K6+M) = ETEMP(K6+M) + TP*RLM1*ETEMP(J0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IV=0
              IF(IV.GE.1) THEN
                FC = DFLOAT(IV)
                DO M=1,MAXAB
                  ETEMP(K9+M) = ETEMP(K9+M) + FC*RLM1*ETEMP(J0+M)
                ENDDO
              ENDIF
C
            ENDDO
          ENDDO
        ENDDO
C
C**********************************************************************C
C     STEP (3): E[LSTP-1,MQN;IT,IU,IV] -> E[LSTP+1,MQN;IT,IU,IV].      C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM-1
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LSTP)
              I0  = ISTART+(IABC(IT  ,IU  ,IV  )-1)*MAXAB
              K0  = KSTART+(IABC(IT  ,IU  ,IV  )-1)*MAXAB
              K1  = KSTART+(IABC(IT+2,IU  ,IV  )-1)*MAXAB
              K2  = KSTART+(IABC(IT  ,IU+2,IV  )-1)*MAXAB
              K3  = KSTART+(IABC(IT  ,IU  ,IV+2)-1)*MAXAB
              K4  = KSTART+(IABC(IT+1,IU  ,IV  )-1)*MAXAB
              K5  = KSTART+(IABC(IT  ,IU+1,IV  )-1)*MAXAB
              K6  = KSTART+(IABC(IT  ,IU  ,IV+1)-1)*MAXAB
              IF(IT.GT.0) K7  = KSTART + (IABC(IT-1,IU  ,IV  )-1)*MAXAB
              IF(IU.GT.0) K8  = KSTART + (IABC(IT  ,IU-1,IV  )-1)*MAXAB
              IF(IV.GT.0) K9  = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXAB
              IF(IT.GT.1) K10 = KSTART + (IABC(IT-2,IU  ,IV  )-1)*MAXAB
              IF(IU.GT.1) K11 = KSTART + (IABC(IT  ,IU-2,IV  )-1)*MAXAB
              IF(IV.GT.1) K12 = KSTART + (IABC(IT  ,IU  ,IV-2)-1)*MAXAB
C
C             INVOKE RECURRENCE RELATIONS ON LAYER (LSTP-1)
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              TI = DFLOAT(2*(IT+IU+IV)+3)
              DO M=1,MAXAB
                T1 = 1.0D0/P22(M)
                TX = PX(M)/P(M)
                TY = PY(M)/P(M)
                TZ = PZ(M)/P(M)
                TT = PP(M) + TI/P2(M)
                ETEMP(K0+M) = ETEMP(K0+M) + RLM2*TT*ETEMP(I0+M)
                ETEMP(K1+M) = ETEMP(K1+M) + RLM2*T1*ETEMP(I0+M)
                ETEMP(K2+M) = ETEMP(K2+M) + RLM2*T1*ETEMP(I0+M)
                ETEMP(K3+M) = ETEMP(K3+M) + RLM2*T1*ETEMP(I0+M)
                ETEMP(K4+M) = ETEMP(K4+M) + RLM2*TX*ETEMP(I0+M)
                ETEMP(K5+M) = ETEMP(K5+M) + RLM2*TY*ETEMP(I0+M)
                ETEMP(K6+M) = ETEMP(K6+M) + RLM2*TZ*ETEMP(I0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.GE.1) THEN
                DO M=1,MAXAB
                  TX = DFLOAT(2*IT)*PX(M)
                  ETEMP(K7+M) = ETEMP(K7+M) + RLM2*TX*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.GE.1) THEN
                DO M=1,MAXAB
                  TY = DFLOAT(2*IU)*PY(M)
                  ETEMP(K8+M) = ETEMP(K8+M) + RLM2*TY*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IV=0
              IF(IV.GE.1) THEN
                DO M=1,MAXAB
                  TZ = DFLOAT(2*IV)*PZ(M)
                  ETEMP(K9+M) = ETEMP(K9+M) + RLM2*TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IT=0,1
              IF(IT.GE.2) THEN
                TX = DFLOAT(IT*(IT-1))
                DO M=1,MAXAB
                  ETEMP(K10+M) = ETEMP(K10+M) + RLM2*TX*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0,1
              IF(IU.GE.2) THEN
                TY = DFLOAT(IU*(IU-1))
                DO M=1,MAXAB
                  ETEMP(K11+M) = ETEMP(K11+M) + RLM2*TY*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IV=0,1
              IF(IV.GE.2) THEN
                TZ = DFLOAT(IV*(IV-1))
                DO M=1,MAXAB
                  ETEMP(K12+M) = ETEMP(K12+M) + RLM2*TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
C
            ENDDO
          ENDDO
        ENDDO
C
C       UPDATE BLOCK LOCATORS
        ISTART  = ISTART0
        ISTART0 = ISTART0 + MAXAB*NTUV
C
C       UPDATE LAMBDA VALUE
        LAM = LAM+1
C
C     END OF LOOP OVER LSTP FOR FIXED MQN
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESTEPN(ESG,ENSG,LAM,MAXAB,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  NN    NN          C
C         EE      SS    SS   TT    EE       PP    PP NNN   NN          C
C         EE      SS         TT    EE       PP    PP NNNN  NN          C
C         EEEEEE   SSSSSS    TT    EEEEEE   PP    PP NN NN NN          C
C         EE            SS   TT    EE       PPPPPPP  NN  NNNN          C
C         EE      SS    SS   TT    EE       PP       NN   NNN          C
C         EEEEEEEE SSSSSS    TT    EEEEEEEE PP       NN    NN          C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE QUANTUM NUMBER (NQN):                                 C
C                E[NQN  ,LQN,MQN] -> E[NQN+1,LQN,MQN].                 C
C -------------------------------------------------------------------- C
C  ▶ ONLY PERFORMS A SINGLE STEP IN NQN.                               C
C  ▶ LAM IS THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE INPUT COEFFS.  C
C    EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE OUTPUT COEFFS IS LAM+2.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ESG    EQ-COEFFICIENT BATCH.                                      C
C  ▶ LAM   - EFFECTIVE TOTAL ANGULAR MOMENTUM.                         C
C  ▶ MAXAB - NUMBER OF EXPONENT/DENSITY PAIRS.                         C
C  ▶ IZ    - CENTRE TO STEP UP.                                        C
C  OUTPUT:                                                             C
C  ▶ ENSG - EQ-COEFFICIENT BATCH AFTER NQN HAS BEEN STEPPED UP.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM WITH N'=N+1
      NTUV = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C     INITIALISE NEW ARRAY
      DO ITUV=1,NTUV
        DO M=1,MAXAB
          ENSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXAB
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C**********************************************************************C
C     INDEX MAPPINGS: I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                C
C                     K0 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                C
C                     K1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                C
C                     K2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                C
C                     K3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                C
C                     K4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                C
C                     K5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                C
C                     K6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                C
C                     K7 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                C
C                     K8 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                C
C                     K9 -> E[LQN+1,MQN;IT  ,IU  ,IV-1]                C
C                     K10-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                C
C                     K11-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                C
C                     K12-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                C
C**********************************************************************C
C
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
C           STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (NQN)
            I0  = IABC(IT  ,IU  ,IV  )
            K0  = IABC(IT  ,IU  ,IV  )
            K1  = IABC(IT+2,IU  ,IV  )
            K2  = IABC(IT  ,IU+2,IV  )
            K3  = IABC(IT  ,IU  ,IV+2)
            K4  = IABC(IT+1,IU  ,IV  )
            K5  = IABC(IT  ,IU+1,IV  )
            K6  = IABC(IT  ,IU  ,IV+1)
            IF(IT.GT.0) K7  = IABC(IT-1,IU  ,IV  )
            IF(IU.GT.0) K8  = IABC(IT  ,IU-1,IV  )
            IF(IV.GT.0) K9  = IABC(IT  ,IU  ,IV-1)
            IF(IT.GT.1) K10 = IABC(IT-2,IU  ,IV  )
            IF(IU.GT.1) K11 = IABC(IT  ,IU-2,IV  )
            IF(IV.GT.1) K12 = IABC(IT  ,IU  ,IV-2)
C
C           INVOKE RECURRENCE RELATIONS ON LAYER (NQN+1)
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            TT = DFLOAT((2*(IT+IU+IV))+3)
            DO M=1,MAXAB
              T1 = 1.0D0/P22(M)
              TX = PX(M)/P(M)
              TY = PY(M)/P(M)
              TZ = PZ(M)/P(M)
              TP = PP(M) + TT/P2(M)
              ENSG(M,K0) = ENSG(M,K0) + TP*ESG(M,I0)
              ENSG(M,K1) = ENSG(M,K1) + T1*ESG(M,I0)
              ENSG(M,K2) = ENSG(M,K2) + T1*ESG(M,I0)
              ENSG(M,K3) = ENSG(M,K3) + T1*ESG(M,I0)
              ENSG(M,K4) = ENSG(M,K4) + TX*ESG(M,I0)
              ENSG(M,K5) = ENSG(M,K5) + TY*ESG(M,I0)
              ENSG(M,K6) = ENSG(M,K6) + TZ*ESG(M,I0)
            ENDDO
C
C           SPECIAL CASE EXCLUDES IT=0
            IF(IT.GE.1) THEN
              RT2 = DFLOAT(2*IT)
              DO M=1,MAXAB
                T0 = PX(M)*RT2
                ENSG(M,K7) = ENSG(M,K7) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IU=0
            IF(IU.GE.1) THEN
              RU1 = DFLOAT(2*IU)
              DO M=1,MAXAB
                T0 = PY(M)*RU1
                ENSG(M,K8) = ENSG(M,K8) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IV=0
            IF(IV.GE.1) THEN
              RV1 = DFLOAT(2*IV)
              DO M=1,MAXAB
                T0 = PZ(M)*RV1
                ENSG(M,K9) = ENSG(M,K9) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IT=0,1
            IF(IT.GE.2) THEN
              RT2 = DFLOAT(IT*(IT-1))
              DO M=1,MAXAB
                ENSG(M,K10) = ENSG(M,K10) + RT2*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IU=0,1
            IF(IU.GE.2) THEN
              RU2 = DFLOAT(IU*(IU-1))
              DO M=1,MAXAB
                ENSG(M,K11) = ENSG(M,K11) + RU2*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IV=0,1
            IF(IV.GE.2) THEN
              RV2 = DFLOAT(IV*(IV-1))
              DO M=1,MAXAB
                ENSG(M,K12) = ENSG(M,K12) + RV2*ESG(M,I0)
              ENDDO
            ENDIF

          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNORM1(RNTT,EXL,LQN,NBAS,ITT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  NN    NN  OOOOOO  RRRRRRR  MM       MM  11          C
C         RR    RR NNN   NN OO    OO RR    RR MMM     MMM 111          C
C         RR    RR NNNN  NN OO    OO RR    RR MMMM   MMMM  11          C
C         RR    RR NN NN NN OO    OO RR    RR MM MM MM MM  11          C
C         RRRRRRR  NN  NNNN OO    OO RRRRRRR  MM  MMM  MM  11          C
C         RR    RR NN   NNN OO    OO RR    RR MM   M   MM  11          C
C         RR    RR NN    NN  OOOOOO  RR    RR MM       MM 1111         C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNORM1 GENERATES TT' RADIAL BASIS FUNCTION NORMALISATION CONSTANTS, C
C  BUT KEEPS THEM ISOLATED IN A PAIR OF COLUMNS.                       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ LQN  - PAIR OF ORBITAL QUANTUM NUMBERS.                           C
C  ▶ NBAS - PAIR OF PARAMETER LIST LENGTHS.                            C
C  ▶ ITT  - COMPONENT-TYPE OVERLAPS.                                   C
C  OUTPUT:                                                             C
C  ▶ RNTT - BATCH OF NORMALISATION CONSTANTS.                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RNTT(MBS,MBS)
      DIMENSION RN1(MBS),RN2(MBS)
      DIMENSION EXL(MBS,2),LQN(2),NBAS(2)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     LEFT-HAND NORMALISATION LIST
      GL = TWLG-GAMLOG(2*LQN(1)+3)
      GS = TWLG-GAMLOG(2*LQN(1)+5)
      UL = DFLOAT(LQN(1))+1.5D0
      US = DFLOAT(LQN(1))+0.5D0
      DO IBAS=1,NBAS(1)
        ELOG = DLOG(2.0D0*EXL(IBAS,1))
        IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
          RN1(IBAS) = DEXP(0.5D0*(GL+UL*ELOG))
        ELSEIF(ITT.EQ.3.OR.ITT.EQ.4) THEN
          RN1(IBAS) = DEXP(0.5D0*(GS+US*ELOG))
        ENDIF
      ENDDO
C
C     RIGHT-HAND NORMALISATION LIST
      GL = TWLG-GAMLOG(2*LQN(2)+3)
      GS = TWLG-GAMLOG(2*LQN(2)+5)
      UL = DFLOAT(LQN(2))+1.5D0
      US = DFLOAT(LQN(2))+0.5D0
      DO JBAS=1,NBAS(2)
        ELOG = DLOG(2.0D0*EXL(JBAS,2))
        IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
          RN2(JBAS) = DEXP(0.5D0*(GL+UL*ELOG))
        ELSEIF(ITT.EQ.2.OR.ITT.EQ.4) THEN
          RN2(JBAS) = DEXP(0.5D0*(GS+US*ELOG))
        ENDIF
      ENDDO
C
C     FULL MATRIX SET OF NORMALISATION CONSTANTS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          RNTT(IBAS,JBAS) = RN1(IBAS)*RN2(JBAS)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DNORM(NMAX,ECFF,ICMP,SCL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           DDDDDDD  NN    NN  OOOOOO  RRRRRRR  MM       MM            C
C           DD    DD NNN   NN OO    OO RR    RR MMM     MMM            C
C           DD    DD NNNN  NN OO    OO RR    RR MMMM   MMMM            C
C           DD    DD NN NN NN OO    OO RR    RR MM MM MM MM            C
C           DD    DD NN  NNNN OO    OO RRRRRRR  MM  MMM  MM            C
C           DD    DD NN   NNN OO    OO RR    RR MM   M   MM            C
C           DDDDDDD  NN    NN  OOOOOO  RR    RR MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DNORM CALCULATES A SCALE NORM FOR A REAL OR COMPLEX PART OF A LIST  C
C  ECFF OF LENGTH NMAX, AND STORES THE RESULT IN SCL.                  C
C**********************************************************************C
C
      DIMENSION ECMP(NMAX)
C
      COMPLEX*16 ECFF(NMAX)
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-10
C
C     IMPORT EITHER THE REAL OR COMPLEX COMPONENT FROM ECFF
      DO N=1,NMAX
        IF(ICMP.EQ.1) THEN
          ECMP(N) = DREAL(ECFF(N))
        ELSEIF(ICMP.EQ.2) THEN
          ECMP(N) = DIMAG(ECFF(N))
        ELSE
          WRITE(6, *) 'In DNORM: choose component 1 or 2.'
          WRITE(7, *) 'In DNORM: choose component 1 or 2.'
        ENDIF
      ENDDO
C
C     LOOP OVER ELEMENTS OF ECMP
      SSQ = 1.0D0
      SCL = 0.0D0
      DO N=1,NMAX
        IF(DABS(ECMP(N)).GT.EPS) THEN
          ABN = DABS(ECMP(N))
          IF(SCL.LT.ABN) THEN
            SSQ = 1.0D0 + SSQ*(SCL/ABN)**2
          ELSE
            SSQ = SSQ   +     (ABN/SCL)**2
          ENDIF
        ENDIF
      ENDDO
      SCL = SCL*DSQRT(SSQ)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [14] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] SCHWARZ: APPROXIMATES UPPER BOUND OF BLOCK OF COULOMB INTS.    C
C   [B] CLMDIAG: GENERATES ARRAY OF COULOMB SELF-OVERLAPS.             C
C   [C] BRTDIAG: GENERATES ARRAY OF BREIT SELF-OVERLAPS.               C
C**********************************************************************C
C
C
      SUBROUTINE SCHWARZ(GDIR,SENS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS   CCCCCC  HH    HH WW        WW    AA    RRRRRRR  ZZZZZZZZ  C
C  SS    SS CC    CC HH    HH WW        WW   AAAA   RR    RR      ZZ   C
C  SS       CC       HH    HH WW   WW   WW  AA  AA  RR    RR     ZZ    C
C   SSSSSS  CC       HHHHHHHH WW  WWWW  WW AA    AA RR    RR    ZZ     C
C        SS CC       HH    HH WW WW  WW WW AAAAAAAA RRRRRRR    ZZ      C
C  SS    SS CC    CC HH    HH WWWW    WWWW AA    AA RR    RR  ZZ       C
C   SSSSSS   CCCCCC  HH    HH WW        WW AA    AA RR    RR ZZZZZZZZ  C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCHWARZ APPROXIMATES THE UPPER BOUND TO A BLOCK OF TWO-ELECTRON     C
C  INTEGRALS AND ITS CONTRIBUTION TO THE GDIR/GXCH MATRIX.             C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ GDIR - FULL ARRAY OF PAIR-WISE MATRIX ELEMENTS.                   C
C  ▶ SENS - SENSITIVITY LIMIT FOR MAXIMUM FOCK MATRIX CONTRIBUTION.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION GDIR(MDM,MDM)
      DIMENSION R(8),D(4)
      DIMENSION NBAS(4),MQN(4)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,MQN,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
C
C     RESET SCREENING COUNTERS
      IBCH = 1
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
        DO ITG=1,11
          IMTX(M,ITG) = 1
        ENDDO
      ENDDO
      MAXN = NBAS(3)*NBAS(4)
C
C     IF TOGGLE SWITCHED OFF, DO NOT SCREEN
      IF(ITOG.EQ.0) GOTO 99
C
C     FIND LARGEST UPPER BOUND AND DENSITY PRODUCT FOR EACH M
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT INTEGRALS
          R(1) = GDIR(NA1+IBAS,NB1+JBAS)
          R(2) = GDIR(NA1+IBAS,NB2+JBAS)
          R(3) = GDIR(NA2+IBAS,NB1+JBAS)
          R(4) = GDIR(NA2+IBAS,NB2+JBAS)
          R(5) = GDIR(NC1+KBAS,ND1+LBAS)
          R(6) = GDIR(NC1+KBAS,ND2+LBAS)
          R(7) = GDIR(NC2+KBAS,ND1+LBAS)
          R(8) = GDIR(NC2+KBAS,ND2+LBAS)
C
C         LARGEST OF THE DIRECT INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 1 AND IFLG = 2
          D(1) = ABS(DENT(NC1+KBAS,ND1+LBAS))
          D(2) = ABS(DENT(NC1+KBAS,ND2+LBAS))
          D(3) = ABS(DENT(NC2+KBAS,ND1+LBAS))
          D(4) = ABS(DENT(NC2+KBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 1) = 0
            IMTX(M, 2) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 3 AND IFLG = 4
          D(1) = ABS(DENT(NA1+IBAS,NB1+JBAS))
          D(2) = ABS(DENT(NA1+IBAS,NB2+JBAS))
          D(3) = ABS(DENT(NA2+IBAS,NB1+JBAS))
          D(4) = ABS(DENT(NA2+IBAS,NB2+JBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 3) = 0
            IMTX(M, 4) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (FIRST TYPE)
          R(1) = GDIR(NB1+JBAS,NC1+KBAS)
          R(2) = GDIR(NB1+JBAS,NC2+KBAS)
          R(3) = GDIR(NB2+JBAS,NC1+KBAS)
          R(4) = GDIR(NB2+JBAS,NC2+KBAS)
          R(5) = GDIR(NA1+IBAS,ND1+LBAS)
          R(6) = GDIR(NA1+IBAS,ND2+LBAS)
          R(7) = GDIR(NA2+IBAS,ND1+LBAS)
          R(8) = GDIR(NA2+IBAS,ND2+LBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 8 AND IFLG = 9
          D(1) = ABS(DENT(NA1+IBAS,ND1+LBAS))
          D(2) = ABS(DENT(NA1+IBAS,ND2+LBAS))
          D(3) = ABS(DENT(NA2+IBAS,ND1+LBAS))
          D(4) = ABS(DENT(NA2+IBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 8) = 0
            IMTX(M, 9) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 5
          D(1) = ABS(DENT(NB1+JBAS,NC1+KBAS))
          D(2) = ABS(DENT(NB1+JBAS,NC2+KBAS))
          D(3) = ABS(DENT(NB2+JBAS,NC1+KBAS))
          D(4) = ABS(DENT(NB2+JBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 5) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (SECOND TYPE)
          R(1) = GDIR(NB1+JBAS,ND1+LBAS)
          R(2) = GDIR(NB1+JBAS,ND2+LBAS)
          R(3) = GDIR(NB2+JBAS,ND1+LBAS)
          R(4) = GDIR(NB2+JBAS,ND2+LBAS)
          R(5) = GDIR(NA1+IBAS,NC1+KBAS)
          R(6) = GDIR(NA1+IBAS,NC2+KBAS)
          R(7) = GDIR(NA2+IBAS,NC1+KBAS)
          R(8) = GDIR(NA2+IBAS,NC2+KBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 7 AND IFLG = 11
          D(1) = ABS(DENT(NA1+IBAS,NC1+KBAS))
          D(2) = ABS(DENT(NA1+IBAS,NC2+KBAS))
          D(3) = ABS(DENT(NA2+IBAS,NC1+KBAS))
          D(4) = ABS(DENT(NA2+IBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 7) = 0
            IMTX(M,11) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 6 AND IFLG = 10
          D(1) = ABS(DENT(NB1+JBAS,ND1+LBAS))
          D(2) = ABS(DENT(NB1+JBAS,ND2+LBAS))
          D(3) = ABS(DENT(NB2+JBAS,ND1+LBAS))
          D(4) = ABS(DENT(NB2+JBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 6) = 0
            IMTX(M,10) = 0
          ENDIF
C
C         SCREEN THIS BATCH M
          ISCR(M) = 0
          GOTO 1001
C
C         SCREENING FAILED FOR THIS BATCH
1000      CONTINUE
          N = N+1
          IMAP(N) = M
          ISCR(M) = 1
C
1001      CONTINUE
C
        ENDDO
      ENDDO
C
C     NUMBER OF INTEGRALS TO CALCULATE
      MAXN = N
C
C     NONE OF THE ELEMENTS WERE ABOVE SENSITIVITY LIMIT
      IF(N.EQ.0) THEN
        IBCH = 0
      ENDIF
C
C     SKIP POINT WHEN SCREENING COUNTER SWITCHED OFF
99    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE CLMDIAG
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      CCCCCC  LL       MM       MM DDDDDDD IIII    AA     GGGGGG      C
C     CC    CC LL       MMM     MMM DD    DD II    AAAA   GG    GG     C
C     CC       LL       MMMM   MMMM DD    DD II   AA  AA  GG           C
C     CC       LL       MM MM MM MM DD    DD II  AA    AA GG           C
C     CC       LL       MM  MMM  MM DD    DD II  AAAAAAAA GG   GGG     C
C     CC    CC LL       MM   M   MM DD    DD II  AA    AA GG    GG     C
C      CCCCCC  LLLLLLLL MM       MM DDDDDDD IIII AA    AA  GGGGGG      C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMDIAG GENERATES DIAGONAL COULOMB INTERACTION ELEMENTS FOR LATER   C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1100 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF 'CENTRE C'
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTRE D
      DO 1200 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF 'CENTRE D'
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        LQN(3) = LVAL(KQN(3))
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        LQN(4) = LVAL(KQN(4))
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3001 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4001 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4002 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = MAPTTTT(IT1,IT2)
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO GMAT/QMAT.  C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL ERI(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|--) = (++|++) AND (-+|-+) = (+-|+-)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                GDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 1)))
                GDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 6)))
                GDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,11)))
                GDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,16)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4002  CONTINUE
4001  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3001  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2002  CONTINUE
2001  CONTINUE
C     END LOOP OVER CENTRES
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     SELF-COULOMB MATRIX COMPLETE.                                    C
C**********************************************************************C

      RETURN
      END
C
C
      SUBROUTINE BRTDIAG
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       BBBBBBB  RRRRRRR TTTTTTTT DDDDDDD IIII    AA     GGGGGG        C
C       BB    BB RR    RR   TT    DD    DD II    AAAA   GG    GG       C
C       BB    BB RR    RR   TT    DD    DD II   AA  AA  GG             C
C       BBBBBBB  RR    RR   TT    DD    DD II  AA    AA GG             C
C       BB    BB RRRRRRR    TT    DD    DD II  AAAAAAAA GG   GGG       C
C       BB    BB RR    RR   TT    DD    DD II  AA    AA GG    GG       C
C       BBBBBBB  RR    RR   TT    DDDDDDD IIII AA    AA  GGGGGG        C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTDIAG GENERATES DIAGONAL BREIT INTERACTION ELEMENTS FOR LATER     C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4)
      DIMENSION ICNT(4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,NCD,IGAB,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
        RETURN
      ELSE
        ITSTRT = 2
        ITSTOP = 3
        ITSKIP = 1
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1001 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1002 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE C'
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTRE D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE D'
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2001 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2002 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        LQN(3) = LVAL(KQN(3))
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        LQN(4) = LVAL(KQN(4))
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3001 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3002 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4001 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.2) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4002 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.2) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1

C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = MAPTTTT(IT1,IT2)
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO BDSC.       C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         OVERRIDE GAUNT REPLACEMENT TOGGLE
          BGAUNT = .FALSE.
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL BII(RR,XYZ,ICNT,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|++) = (++|--) AND (-+|+-) = (+-|-+)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                BDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 4)))
                BDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 7)))
                BDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,10)))
                BDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,13)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4002  CONTINUE
4001  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3002  CONTINUE
3001  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2002  CONTINUE
2001  CONTINUE
C     END LOOP OVER CENTRES
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1002  CONTINUE
1001  CONTINUE
C
C**********************************************************************C
C     SELF-BREIT MATRIX COMPLETE.                                      C
C**********************************************************************C
C
      DO I=1,NDIM-NSKP
        DO J=1,I
          BDSC(J,I) = BDSC(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION EXTINT11(Y,I,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE XX     XX TTTTTTTT IIII NN    NN TTTTTTTT 11   11       C
C     EE        XX   XX     TT     II  NNN   NN    TT   111  111       C
C     EE         XX XX      TT     II  NNNN  NN    TT    11   11       C
C     EEEEEE      XXX       TT     II  NN NN NN    TT    11   11       C
C     EE         XX XX      TT     II  NN  NNNN    TT    11   11       C
C     EE        XX   XX     TT     II  NN   NNN    TT    11   11       C
C     EEEEEEEE XX     XX    TT    IIII NN    NN    TT   1111 1111      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EXTINT11 DETERMINES THE VALUE OF THE CONTRIBUTION TO AN INTEGRAL    C
C  BASED ON THE REPEATED 11-POINT NEWTON-COTES FORMULA, WHERE Y IS     C
C  THE VALUE F(X_I), I IS THE INDEX OF INTEREST, AND THE START AND     C
C  END POINTS OF THE INTEGRAL ARE F(X_0) AND F(X_N) RESPECTIVELY.      C
C  IT IS NUMERICALLY ADVANTAGEOUS TO MULTIPLY BY 5.0D+0/2.99376D+5     C
C  AFTER THE SUM IS CALCULATED.                                        C
C**********************************************************************C
C
C     FUNCTION ONLY ALLOWS I BETWEEN 0 AND N
      IF(I.LT.0.OR.I.GT.N) THEN
        WRITE(6, *) 'In EXTINT11: invalid index I. I = ',I
        WRITE(7, *) 'In EXTINT11: invalid index I. I = ',I
        STOP
      ENDIF
C
C     FOR THIS FORMULA TO APPLY, N MUST BE A MULTIPLE OF 10
      IF(MOD(N,10).NE.0.OR.N.LT.10) THEN
        M = MOD(N,10)
        WRITE(6, *) 'In EXTINT11: invalid discretisation N. N = ',M
        WRITE(7, *) 'In EXTINT11: invalid discretisation N. N = ',M
        STOP
      ENDIF
C
      IF(I.EQ.0.OR.I.EQ.N) THEN
        EXTINT11 = 16067.0D0*Y
      ELSEIF(MOD(I,10).EQ.0) THEN
        EXTINT11 = 32134.0D0*Y
      ELSEIF(MOD(I,10).EQ.1.OR.MOD(I,10).EQ.9) THEN
        EXTINT11 = 106300.0D0*Y
      ELSEIF(MOD(I,10).EQ.2.OR.MOD(I,10).EQ.8) THEN
        EXTINT11 =-48525.0D0*Y
      ELSEIF(MOD(I,10).EQ.3.OR.MOD(I,10).EQ.7) THEN
        EXTINT11 = 272400.0D0*Y
      ELSEIF(MOD(I,10).EQ.4.OR.MOD(I,10).EQ.6) THEN
        EXTINT11 =-260550.0D0*Y
      ELSEIF(MOD(I,10).EQ.5) THEN
        EXTINT11 = 427368.0D0*Y
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ZGNUMAP(ARRAY,TITLE,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  ZZZZZZZZ  GGGGGG  NN    NN UU    UU MM       MM    AA    PPPPPPP    C
C       ZZ  GG    GG NNN   NN UU    UU MMM     MMM   AAAA   PP    PP   C
C      ZZ   GG       NNNN  NN UU    UU MMMM   MMMM  AA  AA  PP    PP   C
C     ZZ    GG       NN NN NN UU    UU MM MM MM MM AA    AA PP    PP   C
C    ZZ     GG   GGG NN  NNNN UU    UU MM  MMM  MM AAAAAAAA PPPPPPP    C
C   ZZ      GG    GG NN   NNN UU    UU MM   M   MM AA    AA PP         C
C  ZZZZZZZZ  GGGGGG  NN    NN  UUUUUU  MM       MM AA    AA PP         C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZGNUMAP EXPORTS AN ARRAY OF COMPLEX DOUBLE-PRECISION NUMBERS TO AN  C
C  EXTERNAL DATA FILE AND PLOTS IT AS TWO HEAT MAPS.                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*80 TITLE
C
      COMPLEX*16 ARRAY(MDM,MDM)
C
C     PRINT TO EXTERNAL DATA FILES
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//"_r.dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (DREAL(ARRAY(I,J)),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//"_i.dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (DIMAG(ARRAY(I,J)),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      XEND = DFLOAT(NDIM)-0.5D0
      YEND = DFLOAT(NDIM)-0.5D0
C
C     WRITE GNUPLOT MAKE FILES
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'_i.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'_i.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'_i.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'_i.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/jet2.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'_i.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'_r.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'_r.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'_r.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'_r.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/jet2.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'_r.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'_r.gnuplot')
C     CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'_i.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'_r.pdf')
C     CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'_i.pdf')
C
      RETURN
      END
